[{"id":"ab7fec85f604492a9899cdf945faa570","title":"Docker 疑难杂症汇总","content":"1. Docker 迁移存储目录默认情况系统会将 Docker 容器存放在 &#x2F;var&#x2F;lib&#x2F;docker 目录下\n\n[问题起因] 今天通过监控系统，发现公司其中一台服务器的磁盘快慢，随即上去看了下，发现 &#x2F;var&#x2F;lib&#x2F;docker 这个目录特别大。由上述原因，我们都知道，在 &#x2F;var&#x2F;lib&#x2F;docker 中存储的都是相关于容器的存储，所以也不能随便的将其删除掉。\n\n那就准备迁移 docker 的存储目录吧，或者对 &#x2F;var 设备进行扩容来达到相同的目的。更多关于 dockerd 的详细参数，请点击查看 官方文档 地址。\n\n但是需要注意的一点就是，尽量不要用软链， 因为一些 docker 容器编排系统不支持这样做，比如我们所熟知的 k8s 就在内。\n# 发现容器启动不了了 \nERROR：cannot  create temporary directory! \n# 查看系统存储情况 \n$ du -h --max-depth=1 \n\n[解决方法 1] 添加软链接\n# 1.停止docker服务 \n$ sudo systemctl stop docker \n# 2.开始迁移目录 \n$ sudo mv /var/lib/docker /data/\n# 3.添加软链接 \n$ sudo ln -s /data/docker /var/lib/docker \n# 4.启动docker服务 \n$ sudo systemctl start docker \n\n[解决方法 2] 改动 docker 配置文件\n# [方式一] 改动docker启动配置文件 \n$ sudo vim /lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd --graph=/data/docker/ \n# [方式二] 改动docker启动配置文件 \n$ sudo vim /etc/docker/daemon.json &#123;     \"live-restore\": true,     \"graph\": [ \"/data/docker/\" ] &#125; \n\n[操作注意事项] 在迁移 docker 目录的时候注意使用的命令，要么使用 mv 命令直接移动，要么使用 cp 命令复制文件，但是需要注意同时复制文件权限和对应属性，不然在使用的时候可能会存在权限问题。如果容器中，也是使用 root 用户，则不会存在该问题，但是也是需要按照正确的操作来迁移目录。\n# 使用mv命令 \n$ sudo mv /var/lib/docker /data/docker \n# 使用cp命令 \n$ sudo cp -arv /data/docker /data2/docker \n\n因为启动的容器使用的是普通用户运行进程的，且在运行当中需要使用 &#x2F;tmp 目录，结果提示没有权限。在我们导入容器镜像的时候，其实是会将容器启动时需要的各个目录的权限和属性都赋予了。如果我们直接是 cp 命令单纯复制文件内容的话，就会出现属性不一致的情况，同时还会有一定的安全问题。\n\n\n\n2. Docker 设备空间不足Increase Docker container size from default 10GB on rhel7.\n\n[问题起因一] 容器在导入或者启动的时候，如果提示磁盘空间不足的，那么多半是真的因为物理磁盘空间真的有问题导致的。如下所示，我们可以看到 &#x2F; 分区确实满了。\n# 查看物理磁盘空间 \n$ df -Th \nFilesystem    Size    Used    Avail    Use%    Mounted on \n/dev/vda1      40G     40G       0G    100%    / \ntmpfs         7.8G       0     7.8G      0%    /dev/shm \n/dev/vdb1     493G    289G     179G     62%    /mnt \n\n如果发现真的是物理磁盘空间满了的话，就需要查看到底是什么占据了如此大的空间，导致因为容器没有空间无法启动。其中，docker 自带的命令就是一个很好的能够帮助我们发现问题的工具。\n# 查看基本信息 \n# 硬件驱动使用的是devicemapper，空间池为docker-252 \n# 磁盘可用容量仅剩16.78MB，可用供我们使用 \n$ docker info \nContainers: 1 \nImages: 28 \nStorage Driver: devicemapper\n  Pool Name: docker-252:1-787932-pool\n  Pool Blocksize: 65.54 kB\n  Backing Filesystem: extfs\n  Data file: /dev/loop0\n  Metadata file: /dev/loop1\n  Data Space Used: 1.225 GB\n  Data Space Total: 107.4 GB\n  Data Space Available: 16.78 MB\n  Metadata Space Used: 2.073 MB\n  Metadata Space Total: 2.147 GB \n\n[解决方法] 通过查看信息，我们知道正是因为 docker 可用的磁盘空间不足，所以导致启动的时候没有足够的空间进行加载启动镜像。解决的方法也很简单，第一就是清理无效数据文件释放磁盘空间(清除日志)，第二就是修改 docker 数据的存放路径(大分区)。\n# 显示哪些容器目录具有最大的日志文件 \n$ du -d1 -h /var/lib/docker/containers | sort -h \n# 清除您选择的容器日志文件的内容 \n$ cat /dev/null > /var/lib/docker/containers/container_id/container_log_name \n\n\n\n[问题起因二] 显然我遇到的不是上一种情况，而是在启动容器的时候，容器启动之后不久就显示是 unhealthy 的状态，通过如下日志发现，原来是复制配置文件启动的时候，提示磁盘空间不足。\n\n后面发现是因为 CentOS7 的系统使用的 docker 容器默认的创建大小就是 10G 而已，然而我们使用的容器却超过了这个限制，导致无法启动时提示空间不足。\n2019-08-16 11:11:15,816 INFO spawned: 'app-demo' with pid 835 \n2019-08-16 11:11:16,268 INFO exited: app (exit status 1; not expected) \n2019-08-16 11:11:17,270 INFO gave up: app entered FATAL state, too many start retries too quickly \ncp: cannot create regular file '/etc/supervisor/conf.d/grpc-app-demo.conf': No space left on device \ncp: cannot create regular file '/etc/supervisor/conf.d/grpc-app-demo.conf': No space left on device \ncp: cannot create regular file '/etc/supervisor/conf.d/grpc-app-demo.conf': No space left on device \ncp: cannot create regular file '/etc/supervisor/conf.d/grpc-app-demo.conf': No space left on device \n\n[解决方法 1] 改动 docker 启动配置文件\n# /etc/docker/daemon.json \n&#123;     \n  \"live-restore\": true,     \n  \"storage-opt\": [ \"dm.basesize=20G\" ] \n&#125; \n\n[解决方法 2] 改动 systemctl 的 docker 启动文件\n# 1.stop the docker service \n$ sudo systemctl stop docker \n# 2.rm exised container \n$ sudo rm -rf /var/lib/docker \n# 2.edit your docker service file \n$ sudo vim /usr/lib/systemd/system/docker.service \n# 3.find the execution line\n ExecStart=/usr/bin/dockerd \nand change it to: \nExecStart=/usr/bin/dockerd --storage-opt dm.basesize=20G \n# 4.start docker service again \n$ sudo systemctl start docker \n# 5.reload daemon \n$ sudo systemctl daemon-reload \n\n\n\n[问题起因三] 还有一种情况也会让容器无法启动，并提示磁盘空间不足，但是使用命令查看发现并不是因为物理磁盘真的不足导致的。而是，因为对于分区的 inode 节点数满了导致的。\n# 报错信息 No space left on device \n\n[解决方法] 因为 ext3 文件系统使用 inode table 存储 inode 信息，而 xfs 文件系统使用 B+ tree 来进行存储。考虑到性能问题，默认情况下这个 B+ tree 只会使用前 1TB 空间，当这 1TB 空间被写满后，就会导致无法写入 inode 信息，报磁盘空间不足的错误。我们可以在 mount 时，指定 inode64 即可将这个 B+ tree 使用的空间扩展到整个文件系统。\n# 查看系统的inode节点使用情况 \n$ sudo df -i \n# 尝试重新挂载 \n$ sudo mount -o remount -o noatime,nodiratime,inode64,nobarrier /dev/vda1 \n\n[补充知识] 文件储存在硬盘上，硬盘的最小存储单位叫做 扇区(Sector)。每个扇区储存 512 字节(相当于0.5KB)。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块(block)。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个 sector 组成一个 block 块。文件数据都储存在块中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做索引节点(inode)。每一个文件都有对应的 inode，里面包含了除了文件名以外的所有文件信息。\n\ninode 也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是 inode 区(inode table)，存放 inode 所包含的信息。每个 inode 节点的大小，一般是 128 字节或 256 字节。inode 节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个 inode 节点。\n# 每个节点信息的内容 \n$ stat check_port_live.sh \n   File: check_port_live.sh\n   Size: 225           Blocks: 8          IO Block: 4096   regular file \nDevice: 822h/2082d    Inode: 99621663    Links: 1 \nAccess: (0755/-rwxr-xr-x)  Uid: ( 1006/  escape)   Gid: ( 1006/  escape) \nAccess: 2019-07-29 14:59:59.498076903 +0800 \nModify: 2019-07-29 14:59:59.498076903 +0800 \nChange: 2019-07-29 23:20:27.834866649 +0800  \n  Birth: - \n# 磁盘的inode使用情况 \n$ df -i Filesystem                 Inodes   IUsed     IFree IUse% Mounted on \nudev                     16478355     801  16477554    1% /dev \ntmpfs                    16487639    2521  16485118    1% /run \n/dev/sdc2               244162560 4788436 239374124    2% / \ntmpfs                    16487639       5  16487634    1% /dev/shm \n\n\n3. Docker 缺共享链接库Docker 命令需要对&#x2F;tmp 目录下面有访问权限\n\n[问题起因] 给系统安装完 compose 之后，查看版本的时候，提示缺少一个名为 libz.so.1 的共享链接库。第一反应就是，是不是系统少安装那个软件包导致的。随即，搜索了一下，将相关的依赖包都给安装了，却还是提示同样的问题。\n# 提示错误信息 \n$ docker-compose --version \nerror while loading shared libraries: libz.so.1: failed to map segment from shared object: Operation not permitted \n\n[解决方法] 后来发现，是因为系统中 docker 没有对 &#x2F;tmp 目录的访问权限导致，需要重新将其挂载一次，就可以解决了。\n# 重新挂载 \n$ sudo mount /tmp -o remount,exec \n\n\n4. Docker 容器文件损坏对 dockerd 的配置有可能会影响到系统稳定\n\n[问题起因] 容器文件损坏，经常会导致容器无法操作。正常的 docker 命令已经无法操控这台容器了，无法关闭、重启、删除。正巧，前天就需要这个的问题，主要的原因是因为重新对 docker 的默认容器进行了重新的分配限制导致的。\n# 操作容器遇到类似的错误 \nb'devicemapper: Error running deviceCreate (CreateSnapDeviceRaw) dm_task_run failed' \n\n[解决方法] 可以通过以下操作将容器删除&#x2F;重建。\n# 1.关闭docker \n$ sudo systemctl stop docker \n# 2.删除容器文件 \n$ sudo rm -rf /var/lib/docker/containers\n # 3.重新整理容器元数据 \n$ sudo thin_check /var/lib/docker/devicemapper/devicemapper/metadata \n$ sudo thin_check --clear-needs-check-flag /var/lib/docker/devicemapper/devicemapper/metadata\n# 4.重启docker \n$ sudo systemctl start docker \n\n\n5. Docker 容器优雅重启不停止服务器上面运行的容器，重启 dockerd 服务是多么好的一件事\n\n[问题起因] 默认情况下，当 Docker 守护程序终止时，它会关闭正在运行的容器。从 Docker-ce 1.12 开始，可以在配置文件中添加 live-restore 参数，以便在守护程序变得不可用时容器保持运行。需要注意的是 Windows 平台暂时还是不支持该参数的配置。\n# Keep containers alive during daemon downtime \n$ sudo vim /etc/docker/daemon.yaml \n&#123;  \n \"live-restore\": true \n&#125; \n# 在守护进程停机期间保持容器存活 \n$ sudo dockerd --live-restore \n# 只能使用reload重载 #\n 相当于发送SIGHUP信号量给dockerd守护进程 \n$ sudo systemctl reload docker \n# 但是对应网络的设置需要restart才能生效 \n$ sudo systemctl restart docker \n\n[解决方法] 可以通过以下操作将容器删除&#x2F;重建。\n\n\njson\n# /etc/docker/daemon.yaml\n&#123;\n    \"registry-mirrors\": [\"https://vec0xydj.mirror.aliyuncs.com\"],  # 配置获取官方镜像的仓库地址\n    \"experimental\": true,  # 启用实验功能\n    \"default-runtime\": \"nvidia\",  # 容器的默认OCI运行时(默认为runc)\n    \"live-restore\": true,  # 重启dockerd服务的时候容易不终止\n    \"runtimes\": &#123;  # 配置容器运行时\n        \"nvidia\": &#123;\n            \"path\": \"/usr/bin/nvidia-container-runtime\",\n            \"runtimeArgs\": []\n        &#125;\n    &#125;,\n    \"default-address-pools\": [  # 配置容器使用的子网地址池\n        &#123;\n            \"scope\": \"local\",\n            \"base\":\"172.17.0.0/12\",\n            \"size\":24\n        &#125;\n    ]\n&#125;\n\n$ vim /etc/docker/daemon.json\n&#123;\n  \"default-address-pools\" : [\n    &#123;\n      \"base\" : \"172.240.0.0/16\",\n      \"size\" : 24\n    &#125;\n  ]\n&#125;\n\n\n6. Docker 容器无法删除找不到对应容器进程是最吓人的\n\n[问题起因] 今天遇到 docker 容器无法停止&#x2F;终止&#x2F;删除，以为这个容器可能又出现了 dockerd 守护进程托管的情况，但是通过 ps -ef  无法查到对应的运行进程。哎，后来开始开始查 supervisor 以及 Dockerfile 中的进程，都没有。这种情况的可能原因是容器启动之后，主机因任何原因重新启动并且没有优雅地终止容器。剩下的文件现在阻止你重新生成旧名称的新容器，因为系统认为旧容器仍然存在。\n# 删除容器\n$ sudo docker rm -f f8e8c3..\nError response from daemon: Conflict, cannot remove the default name of the container\n\n[解决方法] 找到 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F; 下的对应容器的文件夹，将其删除，然后重启一下 dockerd 即可。我们会发现，之前无法删除的容器没有了。\n# 删除容器文件\n$ sudo rm -rf /var/lib/docker/containers/f8e8c3...65720\n\n# 重启服务\n$ sudo systemctl restart docker.service\n\n\n7. Docker 容器中文异常容器存在问题话，记得优先在官网查询\n\n[问题起因] 今天登陆之前部署的 MySQL 数据库查询，发现使用 SQL 语句无法查询中文字段，即使直接输入中文都没有办法显示。\n# 查看容器支持的字符集\nroot@b18f56aa1e15:# locale -a\nC\nC.UTF-8\nPOSIX\n\n[解决方法] Docker 部署的 MySQL 系统使用的是 POSIX 字符集。然而 POSIX 字符集是不支持中文的，而 C.UTF-8 是支持中文的只要把系统中的环境 LANG 改为 “C.UTF-8” 格式即可解决问题。同理，在 K8S 进入 pod 不能输入中文也可用此方法解决。\n# 临时解决\ndocker exec -it some-mysql env LANG=C.UTF-8 /bin/bash\n# 永久解决\ndocker run --name some-mysql \\\n    -e MYSQL_ROOT_PASSWORD=my-secret-pw \\\n    -d mysql:tag --character-set-server=utf8mb4 \\\n    --collation-server=utf8mb4_unicode_ci\n\n\n8. Docker 容器网络互通了解 Docker 的四种网络模型\n\n[问题起因] 在本机部署 Nginx 容器想代理本机启动的 Python 后端服务程序，但是对代码服务如下的配置，结果访问的时候一直提示 502 错误。\n# 启动Nginx服务\n$ docker run -d -p 80:80 $PWD:/etc/nginx nginx\nserver &#123;\n    ...\n    location /api &#123;\n        proxy_pass http://localhost:8080\n    &#125;\n    ...\n&#125;\n\n[解决方法] 后面发现是因为 nginx.conf 配置文件中的 localhost 配置的有问题，由于 Nginx 是在容器中运行，所以 localhost 为容器中的 localhost，而非本机的 localhost，所以导致无法访问。\n\n可以将 nginx.conf 中的 localhost 改为宿主机的 IP 地址，就可以解决 502 的错误。\n# 查询宿主机IP地址 => 172.17.0.1\n$ ip addr show docker0\ndocker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default\n    link/ether 02:42:d5:4c:f2:1e brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.1/16 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::42:d5ff:fe4c:f21e/64 scope link\n       valid_lft forever preferred_lft forever\nserver &#123;\n    ...\n    location /api &#123;\n        proxy_pass http://172.17.0.1:8080\n    &#125;\n    ...\n&#125;\n\n当容器使用 host 网络时，容器与宿主共用网络，这样就能在容器中访问宿主机网络，那么容器的 localhost 就是宿主机的 localhost 了。\n# 服务的启动方式有所改变(没有映射出来端口)\n# 因为本身与宿主机共用了网络，宿主机暴露端口等同于容器中暴露端口\n$ docker run -d -p 80:80 --network=host $PWD:/etc/nginx nginxx\n\n\n9. Docker 容器总线错误总线错误看到的时候还是挺吓人了\n\n[问题起因] 在 docker 容器中运行程序的时候，提示 bus error 错误。\n# 总线报错\n$ inv app.user_op --name=zhangsan\nBus error (core dumped)\n\n[解决方法] 原因是在 docker 运行的时候，shm 分区设置太小导致 share memory 不够。不设置 –shm-size 参数时，docker 给容器默认分配的 shm 大小为 64M，导致程序启动时不足。具体原因还是因为安装 pytorch 包导致了，多进程跑任务的时候，docker 容器分配的共享内存太小，导致 torch 要在 tmpfs 上面放模型数据用于子线程的 共享不足，就出现报错了。\n# 问题原因\nroot@18...35:/opt/app# df -TH\nFilesystem     Type     Size  Used Avail Use% Mounted on\noverlay        overlay  2.0T  221G  1.4T   3% /\ntmpfs          tmpfs     68M     0   68M   0% /dev\nshm            tmpfs     68M   41k   68M   1% /dev/shm\n\n# 启动docker的时候加上--shm-size参数(单位为b,k,m或g)\n$ docker run -it --rm --shm-size=200m pytorch/pytorch:latest\n\n# 在docker-compose添加对应配置\n$ shm_size: '2gb'\n\n[解决方法] 还有一种情况就是容器内的磁盘空间不足，也会导致 bus error 这样的报错，所以如果出现了，清除多余文件和目录或者分配一个大的磁盘空间，就可以解决了。\n# 磁盘空间不足\n$ df -Th\nFilesystem     Type     Size  Used Avail Use% Mounted on\noverlay        overlay    1T    1T    0G 100% /\nshm            tmpfs     64M   24K   64M   1% /dev/shm\n\n\n10. Docker NFS 挂载报错NFS 挂载之后容器程序使用异常为内核版本太低导致的\n\n[问题起因] 我们将服务部署到 openshift 集群中，启动服务调用资源文件的时候，报错信息如下所示。从报错信息中，得知是在 Python3 程序执行 read_file() 读取文件的内容，给文件加锁的时候报错了。但是奇怪的是，本地调试的时候发现服务都是可以正常运行的，文件加锁也是没问题的。后来发现，在 openshift 集群中使用的是 NFS 挂载的共享磁盘。\n# 报错信息\nTraceback (most recent call last):\n    ......\n    File \"xxx/utils/storage.py\", line 34, in xxx.utils.storage.LocalStorage.read_file\nOSError: [Errno 9] Bad file descriptor\n# 文件加锁代码\n...\n    with open(self.mount(path), 'rb') as fileobj:\n        fcntl.flock(fileobj, fcntl.LOCK_EX)\n        data = fileobj.read()\n    return data\n...\n\n[解决方法] 从下面的信息得知，要在 Linux 中使用 flock() 的话，就需要升级内核版本到 2.6.11+ 才行。后来才发现，这实际上是由 RedHat 內核中的一个错误引起的，并在 kernel-3.10.0-693.18.1.el7 版本中得到修复。 所以对于 NFSv3 和 NFSv4 服务而已，就需要升级 Linux 内核版本才能够解决这个问题。\n# https://t.codebug.vip/questions-930901.htm\n$ In Linux kernels up to 2.6.11, flock() does not lock files over NFS (i.e.,\nthe scope of locks was limited to the local system). [...] Since Linux 2.6.12,\nNFS clients support flock() locks by emulating them as byte-range locks on the entire file.\n\n\n11. Docker 使用默认网段启动的容器网络无法相互通信，很是奇怪！\n\n[问题起因] 我们在使用 Docker 启动服务的时候，发现有时候服务之前可以相互连通，而有时启动的多个服务之前却出现了无法访问的情况。究其原因，发现原来是因为使用的内部私有地址网段不一致导致的。有的服务启动到了 172.17 - 172.31 的网段，有的服务跑到了 192.169.0 - 192.168.224 的网段，这样导致服务启动之后出现无法访问的情况(默认情况下，有下面这个两个网段可供其使用)。Docker默认使用网段\n\n[解决方法] 上述问题的处理方式，就是手动指定 Docker 服务的启动网段，二选一就可以了。\n# 查看docker容器配置\n$ cat /etc/docker/daemon.json\n&#123;\n    \"registry-mirrors\": [\"https://vec0xydj.mirror.aliyuncs.com\"],\n    \"default-address-pools\":[&#123;\"base\":\"172.17.0.0/12\", \"size\":24&#125;],\n    \"experimental\": true,\n    \"default-runtime\": \"nvidia\",\n    \"live-restore\": true,\n    \"runtimes\": &#123;\n        \"nvidia\": &#123;\n            \"path\": \"/usr/bin/nvidia-container-runtime\",\n            \"runtimeArgs\": []\n        &#125;\n    &#125;\n&#125;\n\n\n12. Docker 服务启动串台使用 docker-compose 命令各自启动两组服务，发现服务会串台！\n\n[问题起因] 在两个不同名称的目录目录下面，使用 docker-compose 来启动服务，发现当 A 组服务启动完毕之后，再启动 B 组服务的时候，发现 A 组当中对应的一部分服务又重新启动了一次，这就非常奇怪了！因为这个问题的存在会导致，A 组服务和 B 组服务无法同时启动。之前还以为是工具的 Bug，后来请教了 “上峰”，才知道了原因，恍然大悟。\n# 服务目录结构如下所示\nA: /data1/app/docker-compose.yml\nB: /data2/app/docker-compose.yml\n\n[解决方法] 发现 A 和 B 两组服务会串台的原因，原来是 docker-compose 会给启动的容器加 label 标签，然后根据这些 label 标签来识别和判断对应的容器服务是由谁启动的、谁来管理的，等等。而这里，我们需要关注的 label 变量是 com.docker.compose.project，其对应的值是使用启动配置文件的目录的最底层子目录名称，即上面的 app 就是对应的值。我们可以发现， A 和 B 两组服务对应的值都是 app，所以启动的时候被认为是同一个，这就出现了上述的问题。如果需要深入了解的话，可以去看对应源代码。Docker服务启动串台\n# 可以将目录结构调整为如下所示\nA: /data/app1/docker-compose.yml\nB: /data/app2/docker-compose.yml\n\nA: /data1/app-old/docker-compose.yml\nB: /data2/app-new/docker-compose.yml\n\n或者使用 docker-compose 命令提供的参数 -p 手动指定标签，来规避该问题的发生。\n# 指定项目项目名称\n$ docker-compose -f ./docker-compose.yml -p app1 up -d\n\n\n13. Docker 命令调用报错在编写脚本的时候常常会执行 docker 相关的命令，但是需要注意使用细节！\n\n[问题起因] CI 更新环境执行了一个脚本，但是脚本执行过程中报错了，如下所示。通过对应的输出信息，可以看到提示说正在执行的设备不是一个 tty。Docker命令调用报错\n\n随即，查看了脚本发现报错地方是执行了一个 exec 的 docker 命令，大致如下所示。很奇怪的是，手动执行或直接调脚本的时候，怎么都是没有问题的，但是等到 CI 调用的时候怎么都是有问题。后来好好看下，下面这个命令，注意到 -it 这个参数了。\n# 脚本调用docker命令\ndocker exec -it &lt;container_name> psql -Upostgres ......\n\n我们可以一起看下 exec 命令的这两个参数，自然就差不多理解了。\n\n\n\n编号\n参数\n解释说明\n\n\n\n1\n-i&#x2F;-interactive\n即使没有附加也保持 STDIN 打开；如果你需要执行命令则需要开启这个选项\n\n\n2\n-t&#x2F;–tty\n分配一个伪终端进行执行；一个连接用户的终端与容器 stdin 和 stdout 的桥梁\n\n\n\n[解决方法] docker exec 的参数 -t 是指 Allocate a pseudo-TTY 的意思，而 CI 在执行 job 的时候并不是在 TTY 终端中执行，所以 -t 这个参数会报错。同时在 『stackoverflow』也有人给出原因，可以自行查看。Docker命令调用报错\n\n\n\n14. Docker 定时任务异常在 Crontab 定时任务中也存在 Docker 命令执行异常的情况！\n\n[问题起因] 今天发现了一个问题，就是在备份 Mysql 数据库的时候，使用 docker 容器进行备份，然后使用 Crontab 定时任务来触发备份。但是发现备份的 MySQL 数据库居然是空的，但是手动执行对应命令切是好的，很奇怪。\n# Crontab定时任务\n0 */6 * * * \\\n    docker exec -it &lt;container_name> sh -c \\\n        'exec mysqldump --all-databases -uroot -ppassword ......'\n\n[解决方法] 后来发现是因为执行的 docker 命令多个 -i 导致的。因为 Crontab 命令执行的时候，并不是交互式的，所以需要把这个去掉才可以。总结就是，如果你需要回显的话则需要 -t 选项，如果需要交互式会话则需要 -i 选项。\n\n\n\n编号\n参数\n解释说明\n\n\n\n1\n-i&#x2F;-interactive\n即使没有附加也保持 STDIN 打开；如果你需要执行命令则需要开启这个选项\n\n\n2\n-t&#x2F;–tty\n分配一个伪终端进行执行；一个连接用户的终端与容器 stdin 和 stdout 的桥梁\n\n\n\n\n\n15. Docker 变量使用引号compose 里边环境变量带不带引号的问题！\n\n[问题起因] 使用过 compose 的朋友可能都遇到过，在编写启服务启动配置文件的时候，添加环境变量时到底是使用单引号、双引号还是不使用引号的问题？时间长了，我们可能会将三者混用，认为其效果是一样的。但是后来，发现的坑越来越多，才发现其越来越隐晦。\n\n反正我是遇到过很多问题，都是因为添加引号导致的服务启动异常的，后来得出的结论就是一律不使引号。裸奔，体验前所未有的爽快！直到现在看到了 Github 中对应的 issus 之后，才终于破案了。\n# 在Compose中进行引用TEST_VAR变量，无法找到\nTEST_VAR=\"test\"\n\n# 在Compose中进行引用TEST_VAR变量，可以找到\nTEST_VAR=test\n\n# 后来发现docker本身其实已经正确地处理了引号的使用\ndocker run -it --rm -e TEST_VAR=\"test\" test:latest\n\n[解决方法] 得到的结论就是，因为 Compose 解析 yaml 配置文件，发现引号也进行了解释包装。这就导致原本的 TEST_VAR&#x3D;”test” 被解析成了 ‘TEST_VAR&#x3D;”test”‘，所以我们在引用的时候就无法获取到对应的值。现在解决方法就是，不管是我们直接在配置文件添加环境变量或者使用 env_file 配置文件，能不使用引号就不适用引号。\n\n需要注意的是环境变量配置的是日志格式的话(2022-01-01)，如果使用的是 Python 的 yaml.load 模块的话，会被当做是 date 类型的，这是如果希望保持原样信息的话，可以使用 ‘&#x2F;“ 引起来将其变成字符串格式的。\n\n\n\n16. Docker 删除镜像报错无法删除镜像，归根到底还是有地方用到了！\n\n[问题起因] 清理服器磁盘空间的时候，删除某个镜像的时候提示如下信息。提示需要强制删除，但是发现及时执行了强制删除依旧没有效果。\n# 删除镜像\n$ docker rmi 3ccxxxx2e862\nError response from daemon: conflict: unable to delete 3ccxxxx2e862 (cannot be forced) - image has dependent child images\n\n# 强制删除\n$ dcoker rmi -f 3ccxxxx2e862\nError response from daemon: conflict: unable to delete 3ccxxxx2e862 (cannot be forced) - image has dependent child images\n\n[解决方法] 后来才发现，出现这个原因主要是因为 TAG，即存在其他镜像引用了这个镜像。这里我们可以使用如下命令查看对应镜像文件的依赖关系，然后根据对应 TAG 来删除镜像。\n# 查询依赖 - image_id表示镜像名称\n$ docker image inspect --format='&#123;&#123;.RepoTags&#125;&#125; &#123;&#123;.Id&#125;&#125; &#123;&#123;.Parent&#125;&#125;' $(docker image ls -q --filter since=&lt;image_id>)\n\n# 根据TAG删除镜像\n$ docker rmi -f c565xxxxc87f\n# 删除悬空镜像\n$ docker rmi $(docker images --filter \"dangling=true\" -q --no-trunc)\n\n\n17. Docker 普通用户切换切换 Docker 启动用户的话，还是需要注意下权限问题的！\n\n[问题起因] 我们知道在 Docker 容器里面使用 root 用户的话，是不安全的，很容易出现越权的安全问题，所以一般情况下，我们都会使用普通用户来代替 root 进行服务的启动和管理的。今天给一个服务切换用户的时候，发现 Nginx 服务一直无法启动，提示如下权限问题。因为对应的配置文件也没有配置 var 相关的目录，无奈 🤷‍♀ ！️\n# Nginx报错信息\nnginx: [alert] could not open error log file: open() \"/var/log/nginx/error.log\" failed (13: Permission denied)\n2020/11/12 15:25:47 [emerg] 23#23: mkdir() \"/var/cache/nginx/client_temp\" failed (13: Permission denied)\n\n[解决方法] 后来发现还是 nginx.conf 配置文件，配置的有问题，需要将 Nginx 服务启动时候需要的文件都配置到一个无权限的目录，即可解决。\nuser  www-data;\nworker_processes  1;\n\nerror_log  /data/logs/master_error.log warn;\npid        /dev/shm/nginx.pid;\n\nevents &#123;\n    worker_connections  1024;\n&#125;\n\nhttp &#123;\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    gzip               on;\n    sendfile           on;\n    tcp_nopush         on;\n    keepalive_timeout  65;\n\n    client_body_temp_path  /tmp/client_body;\n    fastcgi_temp_path      /tmp/fastcgi_temp;\n    proxy_temp_path        /tmp/proxy_temp;\n    scgi_temp_path         /tmp/scgi_temp;\n    uwsgi_temp_path        /tmp/uwsgi_temp;\n\n    include /etc/nginx/conf.d/*.conf;\n&#125;\n\n\n18. Docker 绑定到 IPv6 上Docker 服务在启动的时候，将地址绑定到 IPv6 地址上面了，提示报错信息！\n\n[问题起因] 物理机器更新了对应补丁之后，重启了服务，导致原本可以正常启动的 docker-compose 服务提示如下报错信息。不清楚是否修改了操作系统的相关配置，还是对应 docker 进行的其他方面的配置，比如修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 或者 docker 的 service 启动文件。\n# Docker的报错信息\ndocker run -p 80:80 nginx:alpine succeeds. Previously, this was failing with Error \\\nstarting userland proxy: listen tcp6 [::]:80: socket: address family not supported by protocol.\n\n[解决方法] 通过如上所示的报错信息，可以看到服务的启动端口绑定到了 tcp6 上面了，但是对应的 socket 发现系统本身并不支持。这时，我们一看下对应的操作系统 ipv6 的设置，发现系统禁用了，所有的 ipv6 地址。需要了解的朋友，可以参考 fix port forwarding with ipv6.disable&#x3D;1 和 cannot start if ipv6 is disabled on host 这两个 issus 来获取更多信息。\n# 操作系统配置\n$ cat /etc/sysctl.conf | grep ipv6\nnet.ipv6.conf.all.disable_ipv6=1\n\n[方法一] 最为简单的解决方法，就是在 docker-compose.yml 文件中，手动指定将对应服务的端口绑定到 ipv4 上面，如下所示。\nversion: \"3\"\n\nservices:\n  app:\n    restart: on-failure\n    container_name: app_web\n    image: app:latest\n    ports:\n      - \"0.0.0.0:80:80/tcp\"\n    volumes:\n      - \"./app_web:/data\"\n    networks:\n      - app_network\n\n[方法二] 或者修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件，在配置中，阻止 Docker 错误的将端口映射到 IPv6 上，即可达到同样的效果，且不用再次修改多个服务的启动配置文件了。\n# 修改配置\n$ vim /etc/docker/daemon.json\n&#123;\n  \"ipv6\": false,\n  \"fixed-cidr-v6\": \"2001:db8:1::/64\"\n&#125;\n\n# 重启服务\n$ systemctl reload docker\n\n[方法三] Docker 默认情况下会同时将端口映射于 IPv4 与 IPv6 两者上，而且有的时候会出现只绑定到了 IPv6，导致服务无法正常访问的情况。现在通用的始终还是 IPv4 地址，因此最简单的做法就是关闭 IPv6 地址。详细的配置，可以参考 Port redirecting binding to IPv6 but not IPv4 interfaces 这个 issus 地址。\n# 修改系统配置\necho '1' > /proc/sys/net/ipv6/conf/lo/disable_ipv6\necho '1' > /proc/sys/net/ipv6/conf/lo/disable_ipv6\necho '1' > /proc/sys/net/ipv6/conf/all/disable_ipv6\necho '1' > /proc/sys/net/ipv6/conf/default/disable_ipv6\n\n# 重启网络\n$ /etc/init.d/networking restart\n\n# 最后检测是否已关闭IPv6\nip addr show | grep net6\n\n\n19. Docker 容器启动超时Docker 服务在启动的时候，提示超时，被直接终止了！\n\n[问题起因] 使用 docker-compose 启动容器的时候，等待了很久的时候(大约 2-3 分钟左右)，之后提示如下信息。通过阅读信息内容，可以看到是因为超时导致的，提示可以通过设置环境变量，加大超时的时间。\n$ docker-compose up -d\nERROR: for xxx  UnixHTTPConnectionPool(host='localhost', port=None): Read timed out. (read timeout=70)\nERROR: An HTTP request took too long to complete. Retry with --verbose to obtain debug information.\nIf you encounter this issue regularly because of slow network conditions, consider setting COMPOSE_HTTP_TIMEOUT to a higher value (current value: 60).\n\n[解决方法] 按照提示设置的环境变量之后，再次启动发现确实可以正常启动了，但是还是能够感觉到有些慢。\n$ sudo vim /etc/profile\nexport COMPOSE_HTTP_TIMEOUT=500\nexport DOCKER_CLIENT_TIMEOUT=500\n\n排除了下启动流程，因为容器启动有映射目录到容器里面且目录大小比较大，所以怀疑是因为 i&#x2F;o 导致的。随即使用 iotop 命令查看服务器目前的 i&#x2F;o 情况，发现存在很多个 rg 命令，且都处于 100% 左右。查了下，发现是 vscode 远程服务器启动的搜索目录结构的进程，西八，有些坑呀！\n$ sudo iotop\n 4269 be/4 escape     15.64 K/s    0.00 B/s  0.00 % 98.36 % rg --files --hidden\n 4270 be/4 escape     28.15 K/s    0.00 B/s  0.00 % 97.46 % rg --files --hidden\n 4272 be/4 escape     31.27 K/s    0.00 B/s  0.00 % 97.39 % rg --files --hidden\n 4276 be/4 escape     34.40 K/s    0.00 B/s  0.00 % 96.98 % rg --files --hidden\n\n\n20. Docker 端口网络限制如果发现服务都一切正常，但是无法无法访问的话，则多为网络问题！\n\n[问题起因] 启用服务之后，登录跳转发现直接 502 报错了。排除了配置等相关原因都没有任何问题(做过相关测试)，这就非常奇怪了！\n# 部署服务架构\nnginx(80) -> web1(8080)\n          -> web2(8081)\n\n# 报错信息如下所示\nnginx connect() failed (113: No route to host) while connecting to upstream\n\n[解决方法] 根据错误信息可知，是因为没有路由到指定的 host 导致了，随即看了下防火墙是开着的，看了日志发现被过滤掉了，西八！问题找到了，现在需要做的就是，要么添加防火墙规则，要么关闭防火墙。\n# 检查开放的端口\n$ sudo firewall-cmd --permanent --zone=public --list-ports\n\n# 开启需要路由的端口\n$ sudo firewall-cmd --permanent --zone=public --add-port=8080/tcp\n$ sudo firewall-cmd --permanent --zone=public --add-port=8081/tcp\n\n# 配置立即生效\nfirewall-cmd --reload\n# 关闭防火墙\n$ sudo systemctl stop firewalld.service\n\n# 禁用自启动\n$ sudo systemctl disable firewalld.service\n\n\n21. Docker 无法获取镜像新初始化的机器，无法获取私有仓库的镜像文件！\n\n[问题起因] 机器初始化之后，使用如下命令登录私有 docker 仓库，发现提示无法获取对应镜像，但是在其他机器上面获取该镜像就可以执行成功，这就非常奇怪了！\n# 登录私有仓库\n$ echo '123456' | docker login -u escape --password-stdin docker.escapelife.site\n\n# 异常信息提示\n$ sudo docker pull docker.escapelife.site/app:0.10\nError response from daemon: manifest for docker.escapelife.site/app:0.10 not found: manifest unknown: manifest unknown\n\n[解决方法] 太坑了，我还以为我发现某个隐藏的 bug 了，可劲的排查，最后发现，原来是自己镜像包名字写错了，应该写成 0.0.10 的，自己却写成了 0.10。这里，纪念一下，以后碰到上述报错，那肯定是镜像不存在的。\n# 登录私有仓库之后会在用户家目录下生成一个docker配置\n# 其用来记录docker私有仓库的登录认证信息(是加密过的信息但不安全) => base64\n$ cat .docker/config.json\n&#123;\n    \"auths\": &#123;\n        \"docker.escapelife.site\": &#123;\n            \"auth\": \"d00u11Fu22B3355VG2xasE12w==\"\n        &#125;\n    &#125;\n&#125;\n\n\n22. Docker 使容器不退出如何使使用 docker-compose 启动的容器服务 hang 住而不退出\n\n[问题起因] 有时候我们启动的服务，因为某些问题(bug)导致服务无法正常启动，就会出现容器无限重启(restart: on-failure)的情况，这时就很不利于排除问题。\n➜ docker ps -a\n4e6xxx9a4   app:latest   \"/xxx/…\"   26 seconds ago   Restarting (1) 2 seconds ago\n\n[解决方法] 这时我们就需要根据，服务构建使用命令来决定是用什么命令来 hang 住服务。卡住的原理，就类似于使用 &#x2F;bin&#x2F;bash 进入容器是一样的，这里我就不过多解释了。\n# 类似原理\ndocker run -it --rm --entrypoint=/bin/bash xxx/app:latest\n\n# 使用Command命令\ntty: true\ncommand: tail -f /dev/null\n\n# 使用Entrypoint命令\ntty: true\nentrypoint: tail -f /dev/null\n\n同理，我们在使用 docker-compose 或者 k8s 平台部署服务的时候，也有时会因为启动问题需要，使启动的服务不直接退出，来手动调试和排查问题原因。所以，我这里记录下其不同部署方式的，暂停方式。\n# Compose\n\nversion: \"3\"\nservices:\n  app:\n    image: ubuntu:latest\n    tty: true\n    entrypoint: /usr/bin/tail\n    command: \"-f /dev/null\"\n# K8S\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: ubuntu\nspec:\n  containers:\n    - name: ubuntu\n      image: ubuntu:latest\n      command: [\"/bin/bash\", \"-c\", \"--\"]\n      args: [\"while true; do sleep 30; done;\"]\n      # command: [\"sleep\"]\n      # args: [\"infinity\"]\n\n\n23. Docker 不使用默认网段有些情况，内部规划的网段和可能和 Dockerd 默认的网段有冲突，导致异常出现！\n\n[问题起因] 今天在新机器上面，部署了一整套服务(多台机器)，服务部署完毕之后，通过前置 Nginx 服务发现并不能访问，后置机器开放的端口，发现发到对应端口的请求都没有转发出去。这就比较奇怪了，因为端口控制是已经开通了的，不应该出现不通的情况。\n➜ nc -v 172.16.100.12 8000\nnc: connect to 172.16.100.12 port 8000 (tcp) failed: Connection refused\n\n[解决方法] 发现服务器端口不通，我这里怀疑可能是 dockerd 服务启动导致的，所以我先将服务都停掉，直接在机器上面启动了 Python 的服务端程序(Linux 机器自带 Python2.7.x 的版本)，然后在前置 Nginx 服务发现，端口确实是通的。后来，排除发现是内部服务默认网段和 dockerd 服务启动的默认网段是冲突的，导致重写了机器的防火墙规则，导致出现上述异常的。\n$ python -m SimpleHTTPServer 8000\nServing HTTP on 0.0.0.0 port 8000 ...\n\n➜ nc -v 172.16.100.12 8000\nConnection to 172.16.100.12 8000 port [tcp/*] succeeded!\n\n既然问题已经知道了，现在需要做的就是非常简单了：不适用默认网段！通过 『mirantis』 里面，我们可以选择进行设置，然后重启服务 dockerd 服务，即可。\n# 修改配置\n$ sudo cat /etc/docker/daemon.json\n&#123;\n  \"default-address-pools\":[&#123;\"base\":\"192.168.100.0/20\",\"size\":24&#125;]\n&#125;\n\n# 重启服务\n$ sudo systemctl restart docker\n\n# 启动服务验证是否生效\n$ ip a\n$ docker network inspect app | grep Subnet\nDocker 不使用默认网段\n\n这时，就到了考验我们网络的子网划分的能力了：如何在给定的网段下面合理且高效的进行划分呢？咳咳，确实难倒我了，这时我们可以再这个在线网站上面 JSON 在线解析 进行划分，然后选定合理的 base 和 size 就可以了。\n# 报错信息\nError response from daemon: could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network\n\n# 按照下图我们可以对 pool 进行合理划分\n# 给定 10.210.200.0 + 255.255.255.0 的网段来划分子网\n$ sudo cat /etc/docker/daemon.json\n&#123;\n  \"default-address-pools\":[&#123;\"base\":\"10.210.200.0/24\",\"size\":28&#125;]\n&#125;\n\n其中，base 告诉我们划分子网的网段是什么(从来开始)，是从前两位(&#x2F;16)开始，还是第三位开始(&#x2F;24)呢？而 size 则告诉我们划分的每个子网有多少 IP 地址可以使用呢？从 “10.210.200.0&#x2F;24” 我们可以知道，该网络下面只有 254 个可用的 IP 地址(直接使用肯定不够)，然后我们需要给 docker 使用，划分每个子网可用 16 个 IP 地址，所以子网就应该写成 28 了。Docker 不使用默认网段\n\n\n\n24. Docker 添加私有仓库有些情况，我们服务器上面需要使用内部私有的容器镜像地址！\n\n[问题起因] 如果新机器上面需要使用私有仓库的话，但是又没有配置，再获取镜像的时候就会出现如下报错信息。\n# 拉取/登陆私库时提示\n$ docker pull 192.168.31.191:5000/nginx:latest\nx509: certificate signed by unknown authority\n\n[解决方法] 该问题的处理方式很简单，如下所示，配置一下仓库地址，重启服务并登陆私有仓库就可以了。\n# 添加配置\n$ sudo cat /etc/docker/daemon.json\n&#123;\n    \"insecure-registries\": [\"192.168.31.191:5000\"]\n&#125;\n\n# 重启docker\n$ sudo systemctl restart docker\n\n# 重新登录即可\n$ docker login 私库地址 -u 用户名 -p 密码\n\n\n25. Docker 解决时间同步解决 Docker 容器时间时区和宿主机不同步的问题！\n\n[问题起因] 有时间我们会遇到新创建的容器，容器内部和外部时间不一致，这就导致服务的日志、定时任务等不能按照我们既定的时间触发，非常麻烦。\n# 容器内部时间(CST - 东八区 - 北京时间)\n[root@server ~]# date\nFri Apr 27 22:49:47 CST 2022\n\n# 容器外部时间(UTC - 格林尼治 - 标准时间)\n[root@server ~]# docker run --rm nginx date\nFri Apr 27 14:49:51 UTC 2022\n\n[解决方法] 宿主机设置了时区，而 Docker 容器并没有设置，导致两者相差 8 小时。\n# 以 docker run 方式启动\n$ docker run -d --name 'app' \\\n    -v /etc/localtime:/etc/localtime \\\n    escape/nginx:v1\n\n# 以 Dockerfile 构建\nENV TimeZone=Asia/Shanghai\nRUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n# 以 docker-compose 方式启动\nenvironment:\n  TZ: Asia/Shanghai\n\n\n26. Docker 容器磁盘不足启动很多容器服务，导致存储和运行的容器目录(&#x2F;var&#x2F;lib&#x2F;docker&#x2F;)磁盘消耗很大！\n\n[问题起因] 服务器使用久了，就会出现磁盘不足的问题，这时候就需要排除到底是什么服务或者数据导致的。但如果使用容器化部署服务的话(docker)，大多数都是因为启动的容器导致，即启动的服务占用了大量的磁盘空间。Docker 容器导致磁盘不足\n\n[分析思路] 我们知道 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2 目录下的文件夹名基本都是以 md5 编码命名的，而 overlay2 是 docker 使用的文件存储驱动，也就是说该目录里面存储的就是现在服务器运行的容器。同时，我们知道镜像是分层的结构，所以这容器每次层都在这里得到了体现。\n# 查看容器的默认文件驱动\n$ docker info | grep \"Storage Driver\"\nStorage Driver: overlay2\n\n# 查看磁盘消耗大户\n$ sudo du -sh /var/lib/docker/overlay2\n900G    /var/lib/docker/overlay2\nDocker 容器导致磁盘不足\n\n[分析思路] 如果我们临时启动了一个服务，当时只是打算只是临时使用，但是后续因为某些原因导致长期使用。同时因为运行中产生的数据或者文件并没有挂载映射到宿主机，导致写入容器内本地的文件最终到了一个很大的量级(比如容器产生的日志文件、数据文件)。这就导致我们看到，对应层下面 diff 和 merged 目录很大的原因。\n\ndiff -&gt; 保存的就是差分信息 -&gt; 容器的可读可写层且初始为空\nmerged -&gt; 容器运行时才会出现的存储情况集合 -&gt; 容器的挂载点\nupperdir -&gt; 容器层\nlowerdir -&gt; 初始镜像层\n\n\n\n# 里面到底存储的啥\n# diff文件夹占用100G+，merged文件夹占用200+G\n$ sudo ls -lh /var/lib/docker/overlay2/1e3137...9706bca6\ndrwxr-xr-x  10 root root  4096 8月   5  2021 diff/   # 大\n-rw-r--r--   1 root root    26 8月   5  2021 link\n-rw-r--r--   1 root root   376 8月   5  2021 lower\ndrwxr-xr-x   1 root root  4096 8月   5  2021 merged/ # 大\ndrwx------   3 root root  4096 4月  24 12:22 work/\n\n# link文件的内容对应了/var/lib/docker/overlay2/l的文件夹名称\n# 保存了镜像层的短标识；用于解决mount参数中长字符超过页大小限制的问题\nDocker 容器导致磁盘不足\n\n[解决方法] 宿主机设置了时区，而 Docker 容器并没有设置，导致两者相差 8 小时。\n\n# 查看那个容器层占用了大量磁盘空间\n$ sudo du -sh /var/lib/docker/overlay2/* | grep G | sort -rn\n121G    1e3137...9706bca6\n33G     9d50b3...ef3ae1b0\n12G     462157...03ce3935\n\n# 查找对应层所属于那个容器镜像\n$ docker ps -q | \\\n    xargs docker inspect --format '&#123;&#123;.State.Pid&#125;&#125;, &#123;&#123;.Id&#125;&#125;, &#123;&#123;.Name&#125;&#125;, &#123;&#123;.GraphDriver.Data.WorkDir&#125;&#125;' | \\\n    grep xxx\n\n# 可以根据容器id和名称查看他的层数信息(从低到高)\n$ docker inspect xxx | grep -E \"LowerDir|UpperDir|MergedDir|WorkDir\"\n\n# 在该目录下也存在一个同样名字容器的文件夹(xxx)\n$ ls -lh /var/lib/docker/image/overlay2/layerdb/mounts/\nfff30d...bc6a0222\n8078cf...73bda80b\nb801ce...cc78e234\n\n# mount-id: 表示了我们刚才创建的容器的目录(/var/lib/docker/overlay2)\n$ ls -lh /var/lib/docker/image/overlay2/layerdb/mounts/ff30d...bc6a0222/\n-rw-r--r--  1 root root    69 8月   5  2021 init-id\n-rw-r--r--  1 root root    64 8月   5  2021 mount-id\n-rw-r--r--  1 root root    71 8月   5  2021 parent\n","slug":"Docker/Docker疑难杂症汇总","date":"2020-06-23T05:32:16.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Anchor"},{"id":"d8253a8b0f6101721f69eb1f7316985f","title":"Mybatis一级缓存导致的内存溢出","content":"\n\n\n\n\n\n\n\n\n接上篇 Druid 监控导致的内存溢出问题定位处理 JVM 内存溢出相关，废话不多说直接上分析过程。\n\n\n1、服务器内存快照分析  首先通过快照查看最大的二十个对象如下图：  \n根据反馈数据可以发现前十个对象大小基本差不多，猜测应该由一个问题导致，点击去进一步定位问题。\n2、定位引起内存溢出的关键对象  发现引起内存溢出的对象很明确为 mybatis 的 PerpetualCache 对象：    \n3、分析引起内存溢出的原因\n猜测溢出\nPerpetualCache 其实是 Mybatis 的一级缓存对象，且全部为 HashMap 类型对象，所以可以大胆猜测是由于 Mybatis 一级缓存不正确使用造成的，敢于如此猜测是因为：\nMyBatis 对会话（Session）级别的一级缓存设计的比较简单，就简单地使用了 HashMap 来维护，并没有对 HashMap 的容量和大小进行限制。\n所以如果我们一直使用某一个 SqlSession 对象查询数据，这样会不会导致 HashMap 太大，而导致 java.lang.OutOfMemoryError 错误？\n\n\n\n验证溢出\nMybatis 的一级缓存是事务级别的，一旦事务提交就会清空。因此可能该线程的事务一直未结束和提交。那就从一个拥有大量查询业务繁杂的功能入手验证，结合二阶段定位到的零星线索，发现服务器内存溢出时正在处理的业务是数据下发，那我们就以次为入手点验证：\nA.首先设置 JVM 参数，为了尽快实现内存溢出效果，设定一个合适的参数，可根据本地环境调整：\n-server -XX:PermSize=256M -XX:MaxPermSize=256m\n-Xms300M -Xmx300M\n-Dcom.sun.management.jmxremote.port=8999\n-Dcom.sun.management.jmxremote.ssl=false\n-Dcom.sun.management.jmxremote.authenticate=false\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n\nB.开启 Jvisualvm 监控，应用中开启下发业务，获取监控数据：\n如下图所示可以看到，本地程序在运行一段时间后已经处于假死状态，GC 回收活动频繁，可堆内存基本未见有效回收，CPU 过山车式的起伏，很快内存溢出了，至此可以得出结论我们找对了入手点：\n\n\n\n\n\n修改溢出\n加断点分析下发业务发现，下发业务存在大量 for 循环引发大量数据库查询操作，且该操作参数不重复，也就导致了 Mybatis 的一级缓存一直无法命中，所以正好验证我们的猜测，在一次下发请求中 Mybatis 创建了海量的缓存数据，改部分数据在下发业务完成之前是无法释放的，占用了大量的内存资源，如果此时刚好服务器内存有限很容易引发 GC overhead limit exceded 错误，进而造成服务假死内存溢出：\n\n\n\n  结合项目实际情况针对一级缓存的可利用率实在过低，由于参数一直变动，缓存命中几率极低，从 MyBatis 一级缓存来看，它以单纯的 HashMap 做缓存，没有容量控制，而一次 SqlSession 中通常来说并不会有大量的查询操作，因此只适用于一次 SqlSession，且项目中已开启二级缓存，所以我们考虑修改一级缓存规则：\n  &lt;!-设置一级缓存模式为STATEMENT，默认为SESSION，SESSION为会话级别，STATEMENT为SQL级别-&gt;\n&lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;STATEMENT&quot;&#x2F;&gt;\n&lt;!-PS：一级缓存的范围有SESSION和STATEMENT两种，默认是SESSION，如果我们不需要使用一级缓存，那么我们可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper语句后都会将一级缓存清除。如果需要更改一级缓存的范围，请在Mybatis的配置文件中，在&lt;settings&gt;下通过localCacheScope指定。-&gt;\n\n\n\n再次验证\n启动项目，开启下发业务，打开监控，效果如下：\n\n\n\n  818 家门店下发业务正常完成，期间堆内存回收稳定，无溢出情况出现（坡度较陡是因为本地 JVM 内存设置较低，为提高内存利用率，GC 回收频繁）。\n4、总结\n疑问：既然一级缓存会导致内存溢出，为什么 Mybatis 还如此设计？\nMyBatis 这样设计也有它自己的理由：\n\n\n\n\n\n\n\n\n\na.一般而言 SqlSession 的生存时间很短。一般情况下使用一个 SqlSession 对象执行的操作不会太多，执行完就会消亡；\n\n\n\n\n\n\n\n\n\nb.对于某一个 SqlSession 对象而言，只要执行 update 操作（update、insert、delete），都会将这个 SqlSession 对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响 JVM 内存空间的问题；\n\n\n\n\n\n\n\n\n\nc.可以手动地释放掉 SqlSession 对象中的缓存。\n\n收获：Mybatis 一级缓存的存储流程\n\n\n\n\n\n\n\n\n\na.MyBatis 的一级缓存是 SqlSession 级别的，但是它并不定义在 SqlSessio 接口的实现类 DefaultSqlSession 中，而是定义在 DefaultSqlSession 的成员变量 Executor 中，Executor 是在 openSession 的时候被实例化出来的，它的默认实现为 SimpleExecutor。\n\n\n\n\n\n\n\n\n\nb.MyBatis 中的一级缓存，与有没有配置无关，只要 SqlSession 存在，MyBastis 一级缓存就存在，localCache 的类型是 PerpetualCache，它其实很简单，一个 id 属性+一个 HashMap 属性而已，id 是一个名为”localCache”的字符串，HashMap 用于存储数据，Key 为 CacheKey，Value 为查询结果。\n\n\n\n\n\n\n\n\n\nc.MyBatis 的一级缓存查询的时候默认都是会先尝试从一级缓存中获取数据的，即想每次查询都走 DB 也行，将&lt;select&gt;标签中的 flushCache 属性设置为 true 即可，这意味着每次查询的时候都会清理一遍 PerpetualCache，PerpetualCache 中没数据，自然只能走 DB。\n\n\n","slug":"Java/Mybatis一级缓存导致的内存溢出","date":"2018-09-29T12:06:29.000Z","categories_index":"JAVA","tags_index":"JVM,OOM,Mybatis","author_index":"Anchor"},{"id":"9736882d32005a945dbd1b55fb5920ee","title":"Druid监控导致的内存溢出问题定位处理","content":"0、起因  一台部署于商户私有云中的应用频繁宕机，经查为 OOM，周期大约一周一次，较规律，所谓千里之堤毁于蚁穴，初步怀疑是轻微的内存泄漏不断积累导致的内存溢出，所以再次宕机出现时果断 dump 内存镜像开始分析\n1、内存溢出原理\n常见内存溢出：\n相信通过写 java 程序讨生活的人对内存溢出并不陌生，先看三张图：\n\n\n\nHeap space（堆空间）\n\nPermgen（永久代）\n\n元空间（Metaspace）\n\nJVM 内存模型\n\n\n  Java 应用程序在启动时会指定所需要的内存大小，它被分割成两个不同的区域：Heap space（堆空间）和Permgen（永久代）。\n  java.lang.OutOfMemoryError\n\n  正如字面意思，当应用程序试图向这两个空间添加更多的数据，但却没有足够的空间来容纳这些数据时，将会触发java.lang.OutOfMemoryError。\n\n内存溢出原因分析\n1、java.lang.OutOfMemoryError: PermGen space\nPermGen space的全称是Permanent Generation space,是指内存的永久保存区域, 这块内存主要是被 JVM 存放 Class 和 Meta 信息的,Class 在被 Load 时就会被放到PermGen space中, 同时 GC(Garbage Collection)不会在主程序运行期对 PermGen space进行清理。\n所以如果你的应用中有很多 CLASS 的话,就很可能出现 PermGen space 错误。\n通过上面的描述就可以得出：如果要加载的 class 与 jar 文件大小超过-XX:MaxPermSize 就有可能会产生 java.lang.OutOfMemoryError: PermGen space 。\n换句话说-XX:MaxPermSize 的大小要超过 class 与 jar 的大小。\n2、java.lang.OutOfMemoryError: Java heap space\n虽然各种 java 虚拟机的实现机制不一,但是heap space内存溢出产生的原因相同：那就是堆内存不够虚拟机分配了。\n由于内存的分配机制与 GC 是有联系的，也就是说内存不够用时有部分内存 GC 肯定无法释放，而我们要找的就是为什么 GC 释放不了堆内存。\n所以当产生heap space内存溢出时，堆内存中对象数量过多的就可能是问题的根源了。例外的情况是，程序确实需要那么多内存，这时就要考虑增大堆内存。\n\n\n2、内存溢出时应该做什么\n收集案发现场数据，尽快恢复系统\n获取内存快照，根据适用场景有以下三种方式：\n1、使用 jmap 命令在案发现场手动生成 dump 文件\njmap -dump:format=b,file=heap.dump \\`pid of java\\`\n2、使用 JVM 参数自动在案发当场获取 dump 文件\n-XX:+HeapDumpOnOutOfMemoryError\n3、使用其它工具获取 dump 文件，主要针对本地开发环境：\n分析 Heap Dump 的工具都可以获取 Heap Dump 文件。比如：jdk 自带的工具 jvisualvm。其它工具：Eclipse memory analyzer（jmat）、JProfiler 等。\n\n本地复现之 jvisualvm 的使用\n无论是为了再现案发场景还是验证修复效果，都需要我们在本地环境中监控 JVM 的运行情况，SO 以我熟悉的jvisualvm为例，简单说下使用方法\n\n\n\n\n\n\n\n\n\nVisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。（摘自官方）简单说来，VisualVM 是一种集成了多个 JDK 命令行工具的可视化工具，它能为您提供强大的分析能力。所有这些都是免费的！它囊括的命令行工具包括 jstat, JConsole, jstack, jmap 和 jinfo，这些工具与 JDK 的标准版本是一致的。 可以使用 VisualVM 生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析。尽管 VisualVM 自身要在 JDK6 这个版本上运行，但是 JDK1.4 以上版本的程序它都能监控。VisualVM 的一个最大好处就是，它已经在你的 JDK bin 目录里了，只要你使用的是 JDK1.6 Update7 之后的版本。点击一下 jvisualvm.exe 图标它就可以运行了，也可以终端或者 CMD 中使用 jvisualvm 命令启动。\nJvisualvm 本地联调的两种常用方法：\n1、Jvisualvm与IDEA集成，Intelij Idea -&gt; Preferences -&gt; Plugins -&gt;Browers Repositrories，搜索visualvm，选择install：安装成功后会添加visualvm的启动选项，启动 Tomcat 的同时会打开一个VisualVM的窗口。\n\n2、不通过插件直接启动，与本地 Tomcat 联调，需要配置一下 Tomcat，添加参数：\n-Dcom.sun.management.jmxremote.port&#x3D;8999\n-Dcom.sun.management.jmxremote.ssl&#x3D;false\n-Dcom.sun.management.jmxremote.authenticate&#x3D;false\n\n3、自造案发现场\n\n\n\n\n\n\n\n\n为了快速验证我们的工具以及加深对 OOM 的理解，我们自造几种内存溢出场景，代码我已准备妥当，可以直接复制运行验证，开始前记得根据示例调整 JVM 参数~\n\nPermGen OOM\n/**\n * @program: jvisualvmDemo\n * @description: jdk1.7永久区内存溢出\n * -XX:MaxPermSize=5m\n * -XX:+HeapDumpOnOutOfMemoryError\n * -XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n * @author: Anchor\n * @create: 2018-07-31\n **/\npublic class PermGenOOM &#123;\n    public static void main(String[] args) &#123;\n        while (true) &#123;\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(MetaOOM.OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() &#123;\n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;\n                    return proxy.invokeSuper(obj, args);\n                &#125;\n            &#125;);\n            //无限创建动态代理，生成Class对象\n            enhancer.create();\n        &#125;\n    &#125;\n    static class OOMObject &#123;\n\n    &#125;\n&#125;\n\n\nMetaOOM\n/**\n * @program: jvisualvmDemo\n * @description: 方法区内存异常\n * -XX:MetaspaceSize=8m\n * -XX:MaxMetaspaceSize=8m\n * -XX:+HeapDumpOnOutOfMemoryError\n * -XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n * @author: Anchor\n * @create: 2018-07-27\n **/\npublic class MetaOOM &#123;\n\n    public static void main(String[] args) &#123;\n        while (true) &#123;\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() &#123;\n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;\n                    return proxy.invokeSuper(obj, args);\n                &#125;\n            &#125;);\n            //无限创建动态代理，生成Class对象\n            enhancer.create();\n        &#125;\n    &#125;\n\n    static class OOMObject &#123;\n\n    &#125;\n&#125;\n\nHeapOOM\n/**\n * @program: jvisualvmDemo\n * @description: 堆内存异常\n * VM Args:\n *     //这两个参数保证了堆中的可分配内存固定为20M\n *     -Xms20m\n *     -Xmx20m\n *     -XX:+HeapDumpOnOutOfMemoryError\n *     -XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n * @author: Anchor\n * @create: 2018-07-27\n **/\npublic class HeapOOM &#123;\n    //创建一个内部类用于创建对象使用\n    static class OOMObject &#123;\n    &#125;\n    public static void main(String[] args) &#123;\n        List&lt;OOMObject> list = new ArrayList&lt;OOMObject>();\n        //无限创建对象，在堆中\n        while (true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n&#125;\n\nJavaVMStackSOF\n/**\n * @program: jvisualvmDemo\n * @description: 栈内存异常\n * VM Args：\n *     //设置栈容量为160K，默认1M\n *    -Xss160k\n * @author: Anchor\n * @create: 2018-07-27\n **/\npublic class JavaVMStackSOF &#123;\n    private int stackLength = 1;\n    public void stackLeak() &#123;\n        stackLength++;\n        //递归调用，触发异常\n        stackLeak();\n    &#125;\n\n    public static void main(String[] args) throws Throwable &#123;\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try &#123;\n            oom.stackLeak();\n        &#125; catch (Throwable e) &#123;\n            System.out.println(\"stack length:\" + oom.stackLength);\n            throw e;\n        &#125;\n    &#125;\n&#125;\n\n4、案例分析\n\n\n\n\n\n\n\n\n啰里啰嗦这么终于要进入正题了 😹\n\n准备环境，测试脚本\n根据本地机器性能配置 JVM 参数：\n-server -XX:PermSize&#x3D;256M -XX:MaxPermSize&#x3D;256m -Xms300M -Xmx300M\n-Dcom.sun.management.jmxremote.port&#x3D;8999\n-Dcom.sun.management.jmxremote.ssl&#x3D;false\n-Dcom.sun.management.jmxremote.authenticate&#x3D;false\n\n准备测试脚本：\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom multiprocessing import Process,Pool\nimport os,time\nimport requests\n\ndef run_proc(name):\n    for i in range(30000):\n        postdata = &#123;'code': i&#125;\n        r = requests.post(\"http://localhost:8080/OOM.do\", data=postdata)\n\nif __name__ =='__main__':\n    print('Run the main process (%s).' % (os.getpid()))\n    mainStart = time.time()\n    p = Pool(8)\n    for i in range(16):\n        p.apply_async(run_proc,args=('Process'+str(i),))\n\n    print('Waiting for all subprocesses done ...')\n    p.close()\n    p.join()\n    print('All subprocesses done')\n    mainEnd = time.time()\n    print ('All process ran %0.2f seconds.' % (mainEnd-mainStart))\n\n内存快照分析\n快照导入 visualvm，简单翻了一下很快发现问题，内存中存在大量 SQL 片段未回收，如图：\n\n为何内存会被大量 SQL 片段占领，莫非？？？果断开启断言（瞎猜）模式，我们要复现问题！\n\n\n\n\n\n\n\n\n\n假设 A：使用了静态变量定义 SQL 片段，导致资源未回收翻代码确认，发现 SQL 使用 String 对象拼接，非静态变量，但是该 SQL 进行了上百次的拼接必然造成资源浪费加重 GC 负担,有优化空间改 StringBuild，测试之。\n脚本跑起来~ Emm~~ 貌似没啥效果\n\n\n\n\n\n\n\n\n\n假设 B：连接池不够用？\n翻代码确认，发现配置正常，改小连接池大小，测试之，无效。\n\n\n\n\n\n\n\n\n\n假设 C：数据库有死锁？\n但是与运维确认每次内存溢出只需重启应用即可恢复，数据库无需操作，PASS\n\n\n\n\n\n\n\n\n\n假设 D：。。。。。\n\n\n\n\n\n\n\n\n\n假设 X：难道 Druid 连接池会导致内存溢出？\n检查 Druid 配置，发现代码中除了使用了连接池还配置了 SQL 监控，URL 监控，那么监控数据存储在哪里了？难道默认是内存中？百度 Google 无果，直接动手压测，模拟 50W 请求，得到如下数据：成功的看到了内存溢出。\n\n对比生产机内存快照，发现有戏！组成结果基本一致，可是没道理啊，难度 Druid 还有这种大坑？不行不敢确定，那么我们反向验证下，如果我关掉 Druid 的监控呢？说干就干，再跑 50W 请求：\n\n欧克，果然有点意思，OOM 消失了(๑•̀ㅂ•́)و✧\n既然问题找到了，那么就要分析为啥会出现这种大坑，先从官网入手，翻下 Druid 的 lssues 发现竟然有前辈已经问过该类问题\n\nbut，官方并未回复，那么看起来这个问题太 low？\nEmm…. 那自己研究下好了\n\n进一步扩展\n翻阅官方文档， 在 SQL 合并配置 ，发现如下内容：\n\n\n\n\n\n\n\n\n\n当你程序中存在没有参数化的 sql 执行时，sql 统计的效果会不好。比如：select _ from t where id &#x3D; 1select _ from t where id &#x3D; 2select _ from t where id &#x3D; 3在统计中，显示为 3 条 sql，这不是我们希望要的效果。StatFilter 提供合并的功能，能够将这 3 个 SQL 合并为如下的 SQLselect _ from t where id &#x3D; ?\n问题到此已经基本明了，不规范的入参导致StatFilter未能成功合并 SQL，Druid 成功记录了所有的执行语句。。。。。。。\n大家可以自行体会下这两种写法的区别：\n\n\n\n5、内存溢出排查总结\n\n\n\n\n\n\n\n\n导致 OutOfMemoryError 异常的常见原因有以下几种：\n   - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；\n   - 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；\n   - 代码中存在死循环或循环产生过多重复的对象实体；\n   - 使用的第三方软件中的BUG；\n   - 启动参数内存值设定的过小；\n   - 编码不规范的隐患；\n\n","slug":"Java/Druid监控导致的内存溢出问题定位处理","date":"2018-08-06T06:03:15.000Z","categories_index":"JAVA","tags_index":"JVM,OOM,Druid","author_index":"Anchor"},{"id":"b778d1ad8e59c9ee0ece8d1989b81254","title":"SpringBoot集成TrueLicense实现授权管理","content":"前言之前做低代码平台，为了保护平台知识产权，需要对低代码平台增加授权管理功能。功能已经实现好久了，最近梳理总结。所谓授权（License）就是对软件使用时间及使用范围进行管控，初步想法是校验部署机器特征码并添加时间范围校验，调研许久发现TrueLicense方案比较成熟，SO 安排~\n一、公钥、私钥及证书在互联网通信中，为了保证信息传输的安全，通常使用对称秘钥、非对称秘钥以及密码散列函数的方式对通信信息进行加密以及通信身份进行验证。对称秘钥即通信双方使用相同的秘钥对通信内容进行加密，这种方式应该是比较老旧的通信加密方式，通信安全程度较低。现在使用的较多的应该是非对称加密，每个人有自己的私钥，然后拥有授权的公钥。每人可以利用自己的私钥对要发送的信息进行加密，然后接受者通过发送者的公钥对信息进行解密。可以类比信箱，拥有公钥的人，可以向 信箱投送信件，拥有私钥的人可以打开信箱，读取信件。在这种通信方式中，可能存在C偷偷将B持有的A公钥换成自己的公钥，而B不知道自己拥有的A的公钥已经被替换，那么C就可以冒充A给B发送信息，而B相信此信息来自A。为了解决这个问题，需要对B持有的A的公钥进行认证，从而确定此公钥确实是A的公钥，而不是被别人篡改过的。而认证机构必须是第三方可信赖的机构，就是CA，由此发送过程就变成如下：\n\nA发给B数据的时候，除了要发送签名和数据实体，还要发送CA颁发的证书。\nB接收到A发送过来的数据后，首先用CA的公钥区解密证书，如果能解，表明这个证书里的信息可信赖，从而得到证书里A的公钥，然后B再用到后的公钥去做下一步动作。\n\n综上，我们就有实现思路了：在Truelicense中，license将和公钥一起发送给被授权者，在程序中，使用公钥对license进行解密，并校验其许可信息。\n二、使用Java自带的KeyTool生成公私钥库\n\n\n\n\n\n\n\n\nKeytool 是一个Java 数据证书的管理工具 ,Keytool 将密钥（key）和证书（certificates）存在一个称为keystore的文件中 在keystore里，包含两种数据：密钥条目（Key entity）——密钥（secret key）又或者是私钥和配对公钥（采用非对称加密）可信任的证书实体（trusted certificate entries）——只包含公钥\n1、生成秘钥库anchor@Alihaiwu > ~/Downloads/KeyTool> keytool -genkey -alias privatekeys -keysize 1024 -keystore privateKeys.store -validity 3650 # -alias别名 –validity 3650表示10年有效\n输入密钥库口令:  #密码，注意使用字母+数字，否则后期校验会抛异常\n再次输入新口令: \n您的名字与姓氏是什么?\n  [Unknown]:  Anchor\n您的组织单位名称是什么?\n  [Unknown]:  Alihai5\n您的组织名称是什么?\n  [Unknown]:  阿里孩舞\n您所在的城市或区域名称是什么?\n  [Unknown]:  beijing\n您所在的省/市/自治区名称是什么?\n  [Unknown]:  beijing\n该单位的双字母国家/地区代码是什么?\n  [Unknown]:  cn\nCN=Anchor, OU=Alihai5, O=阿里孩舞, L=beijing, ST=beijing, C=cn是否正确?\n  [否]:  y\n\n输入 &lt;privatekeys> 的密钥口令\n        (如果和密钥库口令相同, 按回车):  #密码，注意使用字母+数字，否则后期校验会抛异常\n再次输入新口令: \n\nWarning:\nJKS 密钥库使用专用格式,建议使用 \"keytool -importkeystore -srckeystore privateKeys.store -destkeystore privateKeys.store -deststoretype pkcs12\" 迁移到行业标准格式 PKCS12\n2、导出证书及私钥# 然后将密钥库中名称为privatekeys的证书条目导出到证书文件certfile.cer中\nkeytool -export -alias privatekeys -file certfile.cer -keystore privateKeys.store\n输入密钥库口令:  #输入第一步创建秘钥库时使用的密码\n存储在文件 &lt;certfile.cer> 中的证书\n\nWarning:\nJKS 密钥库使用专用格式,建议使用 \"keytool -importkeystore -srckeystore privateKeys.store -destkeystore privateKeys.store -deststoretype pkcs12\" 迁移到行业标准格式 PKCS12\n3、导出公钥anchor@Alihaiwu > ~/Downloads/KeyTool> keytool -import -alias publicCerts -file certfile.cer -keystore publicCerts.store\n输入密钥库口令:  #输入秘钥密码\n再次输入新口令: \n所有者: CN=Anchor, OU=Alihai5, O=阿里孩舞, L=beijing, ST=beijing, C=cn\n发布者: CN=Anchor, OU=Alihai5, O=阿里孩舞, L=beijing, ST=beijing, C=cn\n序列号: 731c7b1b\n有效期为 Wed Jan 04 13:08:18 CST 2023 至 Sat Jan 01 13:08:18 CST 2033\n证书指纹:\n         MD5:  E2:7E:AE:07:6C:74:50:CD:08:BF:68:74:79:84:27:66\n         SHA1: C9:52:ED:A6:A2:97:FC:4A:23:97:0B:C2:85:42:D3:3A:60:E5:D5:83\n         SHA256: 88:A7:0C:5E:78:1B:B1:3E:7B:6F:F9:93:99:FE:24:5F:4F:21:C7:8D:FB:2D:49:F2:FB:92:F6:2A:B4:80:C9:3D\n签名算法名称: SHA256withDSA\n主体公共密钥算法: 1024 位 DSA 密钥\n版本: 3\n\n扩展: \n\n#1: ObjectId: 2.5.29.14 Criticality=false\nSubjectKeyIdentifier [\nKeyIdentifier [\n0000: 57 25 93 29 B5 7D 87 0B   BA F8 B3 A4 CE 25 51 82  W%.).........%Q.\n0010: 58 BD 29 C4                                        X.).\n]\n]\n\n是否信任此证书? [否]:  y\n证书已添加到密钥库中\n按以上步骤执行完成后，会在当前目录下生成3个文件：\nanchor@Alihaiwu > ~/Downloads/KeyTool> ll\ntotal 24\n-rw-r--r--  1 anchor  staff   827B Jan  4 13:14 certfile.cer #此为临时文件可以删除\n-rw-r--r--  1 anchor  staff   1.3K Jan  4 13:08 privateKeys.store #此为私钥，用于生成License文件\n-rw-r--r--  1 anchor  staff   895B Jan  4 13:16 publicCerts.store #此为公钥，用于解密License文件并校验其许可信息\n三、TrueLicenseTrueLicense是一个开源的证书管理引擎，使用trueLicense来做软件产品的保护，基于TrueLicense实现产品License验证功能,给产品加上License验证功能，进行试用期授权，在试用期过后，产品不再可用。其实现原理：\n\n生成秘钥对，使用Keytool生成公私钥证书库。\n授权者保留私钥，使用私钥对包含授权信息（如使用截止日期，MAC地址等）的license进行数字签名。\n公钥给使用者（放在验证的代码中使用），用于验证license是否符合使用条件。\n\n四、SpringBoot集成TrueLicense实现先上整体代码结构，因为使用场景是为低代码开发平台增加授权，所以整个授权逻辑为平台中的一个模块，此处仅介绍授权模块的实现，了解原理后可自行扩展集成入其他框架中：\n\nlicense-boot-start 模块为授权验证模块，兼具授权文件生成接口功能，内部使用\nlicense-core 模块为授权校验核心处理模块\nlicense-creator 模块为授权License生成模块\nlicense-verify 模块为授权校验模块\n\n在此之前先在项目中引入TrueLicense包：\n&lt;!-- truelicense的依赖配置-->\n&lt;dependency>\n    &lt;groupId>de.schlichtherle.truelicense&lt;/groupId>\n    &lt;artifactId>truelicense-core&lt;/artifactId>\n    &lt;version>1.33&lt;/version>\n&lt;/dependency>\n1、license-core还是先上代码结构，由于creator与verify模块license生成与校验逻辑一致，所以抽取出来作为core模块使用，注释比较详细，直接看代码：\nconfig\nLicenseCoreAutoConfigure\n/**\n* @program: groot-license\n* @description:自动装填配置类\n* @author: Anchor\n* @create: 2021-09-01\n**/\n@Configuration\n    @ComponentScan(basePackages = &#123;\"com.alihai5.license.core\"&#125;)\n    public class LicenseCoreAutoConfigure &#123;\n\n    &#125;\n\n\ncontroller\nHardWareInfoController\n/**\n * @program: groot-license\n * @description: 服务器硬件信息获取\n * @author: Anchor\n * @create: 2021-09-01\n **/\n@CrossOrigin\n@RestController\n@RequestMapping(\"/license\")\npublic class HardWareInfoController &#123;\n\n    @RequestMapping(value = \"/getServerInfos\")\n    public AjaxResult getServerInfos(@RequestParam(value = \"osName\",required = false) String osName) throws LicenseContentException &#123;\n        return AjaxResult.success(AServerInfos.getServer(osName).getServerInfos());\n    &#125;\n&#125;\n\n\nhelper\nParamInitHelper\n/**\n * @Description\n * GxParamInitHelper\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class ParamInitHelper &#123;\n\n    /** 证书的发行者和主体字段信息 */\n    private final static X500Principal DEFAULT_HOLDER_AND_ISSUER = new X500Principal(\"CN=a, OU=a, O=a, L=a, ST=a, C=a\");\n\n    /**\n     * &lt;p>初始化证书生成参数&lt;/p>\n     * @param param GxLicenseCreatorParam 生成证书参数\n     * @return LicenseParam 证书参数\n     */\n    public static LicenseParam initLicenseParam(LicenseCreatorParam param)&#123;\n        Preferences preferences = Preferences.userNodeForPackage(LicenseCreator.class);\n        /** 设置对证书内容加密的秘钥 */\n        CipherParam cipherParam = new DefaultCipherParam(param.getStorePass());\n        KeyStoreParam privateStoreParam = new DefaultKeyStoreParam(LicenseCreator.class\n                ,param.getPrivateKeysStorePath()\n                ,param.getPrivateAlias()\n                ,param.getStorePass()\n                ,param.getKeyPass());\n        return new DefaultLicenseParam(param.getSubject(),preferences,privateStoreParam,cipherParam);\n    &#125;\n\n    /**\n     * &lt;p>初始化证书内容信息对象&lt;/p>\n     * @param param GxLicenseCreatorParam 生成证书参数\n     * @return LicenseContent 证书内容\n     */\n    public static LicenseContent initLicenseContent(LicenseCreatorParam param)&#123;\n        LicenseContent licenseContent = new LicenseContent();\n        licenseContent.setHolder(DEFAULT_HOLDER_AND_ISSUER);\n        licenseContent.setIssuer(DEFAULT_HOLDER_AND_ISSUER);\n        /** 设置证书名称 */\n        licenseContent.setSubject(param.getSubject());\n        /** 设置证书有效期 */\n        licenseContent.setIssued(param.getIssuedTime());\n        /** 设置证书生效日期 */\n        licenseContent.setNotBefore(param.getIssuedTime());\n        /** 设置证书失效日期 */\n        licenseContent.setNotAfter(param.getExpiryTime());\n        /** 设置证书用户类型 */\n        licenseContent.setConsumerType(param.getConsumerType());\n        /** 设置证书用户数量 */\n        licenseContent.setConsumerAmount(param.getConsumerAmount());\n        /** 设置证书描述信息 */\n        licenseContent.setInfo(param.getDescription());\n        /** 设置证书扩展信息（对象 -- 额外的ip、mac、cpu等信息） */\n        licenseContent.setExtra(param.getLicenseCheck());\n        return licenseContent;\n    &#125;\n\n    /**\n     * &lt;p>初始化证书生成参数&lt;/p>\n     * @param param License校验类需要的参数\n     */\n    public static LicenseParam initLicenseParam(LicenseVerifyParam param)&#123;\n        Preferences preferences = Preferences.userNodeForPackage(LicenseVerifyManager.class);\n        CipherParam cipherParam = new DefaultCipherParam(param.getStorePass());\n        KeyStoreParam publicStoreParam = new DefaultKeyStoreParam(LicenseVerifyManager.class\n                /** 公钥库存储路径 */\n                ,param.getPublicKeysStorePath()\n                /** 公匙别名 */\n                ,param.getPublicAlias()\n                /** 公钥库访问密码 */\n                ,param.getStorePass()\n                ,null);\n        return new DefaultLicenseParam(param.getSubject(),preferences,publicStoreParam,cipherParam);\n    &#125;\n&#125;\n\n\nmodel\nLicenseCreatorManager\n/**\n * @Description\n * 系统软件证书生成管理器\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class LicenseCreatorManager &#123;\n\n    private static final Logger log = LoggerFactory.getLogger(LicenseCreatorManager.class);\n\n    private LicenseCreatorParam param;\n\n    public LicenseCreatorManager(LicenseCreatorParam param) &#123;\n        this.param = param;\n    &#125;\n\n    /**\n     * &lt;p>生成License证书&lt;/p>\n     * @return GxLicenseResult 证书生成结果\n     */\n    public LicenseResult generateLicense()&#123;\n        try &#123;\n            // 1、根据外部传入的创建Lic的参数信息初始化lic参数（秘钥部分）\n            LicenseParam licenseParam = ParamInitHelper.initLicenseParam(param);\n            // 2、根据外部传入的创建Lic的属性信息初始化lic内容（除了truelicense自带的还包括自己定义的）\n            LicenseContent licenseContent = ParamInitHelper.initLicenseContent(param);\n            // 3、构建Lic管理器\n            LicenseManager licenseManager = new LicenseCustomManager(licenseParam);\n            // 4、根据param传入的lic生成的路径创建空文件\n            File licenseFile = new File(this.param.getLicensePath());\n            // 5、通过Lic管理器，将内容写入Lic文件中\n            licenseManager.store(licenseContent, licenseFile);\n            return new LicenseResult(\"证书生成成功！\",licenseContent);\n        &#125;catch (Exception e)&#123;\n            log.error(e.getMessage());\n            String message = MessageFormat.format(\"证书生成失败！：&#123;0&#125;\", param);\n            log.error(message,e);\n            return new LicenseResult(message,e);\n        &#125;\n    &#125;\n\n    /**\n     * &lt;p>下载License证书&lt;/p>\n     * @return InputStream 证书文件输入流\n     * @throws Exception 证书下载失败\n     */\n    public InputStream download() throws Exception &#123;\n        try &#123;\n            LicenseParam licenseParam = ParamInitHelper.initLicenseParam(param);\n            LicenseContent licenseContent = ParamInitHelper.initLicenseContent(param);\n            LicenseManager licenseManager = new LicenseCustomManager(licenseParam);\n            File licenseFile = new File(param.getLicensePath());\n            licenseManager.store(licenseContent,licenseFile);\n            return new FileInputStream(licenseFile);\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n            log.error(e.getMessage());\n            log.error(MessageFormat.format(\"证书下载失败：&#123;0&#125;\",param),e);\n            throw new UtilException(\"证书下载失败\",e);\n        &#125;\n    &#125;\n\n&#125;\n\n\n\nLicenseCreatorParam\n/**\n * @Description\n * License创建（生成）需要的参数\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class LicenseCreatorParam implements Serializable &#123;\n\n    private static final long serialVersionUID = -7793154252684580872L;\n\n    /**证书主题*/\n    private String subject;\n\n    /**私钥别名*/\n    private String privateAlias;\n\n    /**私钥密码（需要妥善保管，不能让使用者知道*/\n    private String keyPass;\n\n    /**私钥库存储路径*/\n    private String privateKeysStorePath;\n\n    /**访问私钥库的密码*/\n    private String storePass;\n\n    /**证书生成路径*/\n    private String licensePath;\n\n    /** 证书生效时间*/\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date issuedTime = new Date();\n\n    /** 证书失效时间*/\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private Date expiryTime;\n\n    /**用户类型*/\n    private String consumerType = \"user\";\n\n    /**用户数量*/\n    private Integer consumerAmount = 1;\n\n    /**描述信息*/\n    private String description = \"\";\n\n    /**额外的服务器硬件校验信息*/\n    private LicenseExtraParam licenseCheck;\n\n    /**证书下载地址 == 一旦证书create成功，这个值就会填充上*/\n    private String licUrl;\n\n    public LicenseCreatorParam()&#123;\n\n    &#125;\n\n    public static long getSerialVersionUID() &#123;\n        return serialVersionUID;\n    &#125;\n\n    public String getSubject() &#123;\n        return subject;\n    &#125;\n\n    public void setSubject(String subject) &#123;\n        this.subject = subject;\n    &#125;\n\n    public String getPrivateAlias() &#123;\n        return privateAlias;\n    &#125;\n\n    public void setPrivateAlias(String privateAlias) &#123;\n        this.privateAlias = privateAlias;\n    &#125;\n\n    public String getKeyPass() &#123;\n        return keyPass;\n    &#125;\n\n    public void setKeyPass(String keyPass) &#123;\n        this.keyPass = keyPass;\n    &#125;\n\n    public String getStorePass() &#123;\n        return storePass;\n    &#125;\n\n    public void setStorePass(String storePass) &#123;\n        this.storePass = storePass;\n    &#125;\n\n    public String getLicensePath() &#123;\n        return licensePath;\n    &#125;\n\n    public void setLicensePath(String licensePath) &#123;\n        this.licensePath = licensePath;\n    &#125;\n\n    public String getPrivateKeysStorePath() &#123;\n        return privateKeysStorePath;\n    &#125;\n\n    public void setPrivateKeysStorePath(String privateKeysStorePath) &#123;\n        this.privateKeysStorePath = privateKeysStorePath;\n    &#125;\n\n    public Date getIssuedTime() &#123;\n        return issuedTime;\n    &#125;\n\n    public void setIssuedTime(Date issuedTime) &#123;\n        this.issuedTime = issuedTime;\n    &#125;\n\n    public Date getExpiryTime() &#123;\n        return expiryTime;\n    &#125;\n\n    public void setExpiryTime(Date expiryTime) &#123;\n        this.expiryTime = expiryTime;\n    &#125;\n\n    public String getConsumerType() &#123;\n        return consumerType;\n    &#125;\n\n    public void setConsumerType(String consumerType) &#123;\n        this.consumerType = consumerType;\n    &#125;\n\n    public Integer getConsumerAmount() &#123;\n        return consumerAmount;\n    &#125;\n\n    public void setConsumerAmount(Integer consumerAmount) &#123;\n        this.consumerAmount = consumerAmount;\n    &#125;\n\n    public String getDescription() &#123;\n        return description;\n    &#125;\n\n    public void setDescription(String description) &#123;\n        this.description = description;\n    &#125;\n\n    public LicenseExtraParam getLicenseCheck() &#123;\n        return licenseCheck;\n    &#125;\n\n    public void setLicenseCheck(LicenseExtraParam licenseCheck) &#123;\n        this.licenseCheck = licenseCheck;\n    &#125;\n\n    public String getLicUrl() &#123;\n        return licUrl;\n    &#125;\n\n    public void setLicUrl(String licUrl) &#123;\n        this.licUrl = licUrl;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"LicenseCreatorParam&#123;\" +\n                \"subject='\" + subject + '\\'' +\n                \", privateAlias='\" + privateAlias + '\\'' +\n                \", keyPass='\" + keyPass + '\\'' +\n                \", privateKeysStorePath='\" + privateKeysStorePath + '\\'' +\n                \", storePass='\" + storePass + '\\'' +\n                \", licensePath='\" + licensePath + '\\'' +\n                \", issuedTime=\" + issuedTime +\n                \", expiryTime=\" + expiryTime +\n                \", consumerType='\" + consumerType + '\\'' +\n                \", consumerAmount=\" + consumerAmount +\n                \", description='\" + description + '\\'' +\n                \", licenseCheck=\" + licenseCheck +\n                \", licUrl='\" + licUrl + '\\'' +\n                '&#125;';\n    &#125;\n&#125;\n\n\n\nLicenseCustomManager\n/**\n * @Description\n * 自定义LicenseManager，用于增加额外的服务器硬件信息校验\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class LicenseCustomManager extends LicenseManager &#123;\n\n    private static final Logger log = LoggerFactory.getLogger(LicenseCustomManager.class);\n\n    /** XML编码 */\n    private static final String XML_CHARSET = \"UTF-8\";\n    /** 默认BUFF_SIZE */\n    private static final int DEFAULT_BUFF_SIZE = 8 * 1024;\n\n    public LicenseCustomManager() &#123;\n    &#125;\n\n    public LicenseCustomManager(LicenseParam param) &#123;\n        super(param);\n    &#125;\n\n    /**\n     * &lt;p>重写LicenseManager的create方法&lt;/p>\n     * @param content LicenseContent 证书信息\n     * @param notary notary 公正信息\n     * @return byte[]\n     * @throws Exception 默认异常\n     */\n    @Override\n    protected synchronized byte[] create(LicenseContent content, LicenseNotary notary) throws Exception &#123;\n        initialize(content);\n        /** 加入自己额外的许可内容信息认证 == 主要友情提示 */\n        this.validateCreate(content);\n        final GenericCertificate certificate = notary.sign(content);\n        return getPrivacyGuard().cert2key(certificate);\n    &#125;\n\n\n    /**\n     * &lt;p>重写install方法&lt;/p>\n     * @param key 密匙\n     * @param notary 公正信息\n     * @return LicenseContent 证书信息\n     * @throws Exception 默认异常\n     */\n    @Override\n    protected synchronized LicenseContent install(final byte[] key, final LicenseNotary notary) throws Exception &#123;\n        final GenericCertificate certificate = getPrivacyGuard().key2cert(key);\n        notary.verify(certificate);\n        final LicenseContent licenseContent = (LicenseContent)this.load(certificate.getEncoded());\n        /** 增加额外的自己的license校验方法，校验ip、mac、cpu序列号等 */\n        this.validate(licenseContent);\n        setLicenseKey(key);\n        setCertificate(certificate);\n        return licenseContent;\n    &#125;\n\n    /**\n     * &lt;p>重写verify方法&lt;/p>\n     * @param notary 公正信息\n     * @return LicenseContent 证书信息\n     * @throws Exception 默认异常\n     */\n    @Override\n    protected synchronized LicenseContent verify(final LicenseNotary notary) throws Exception &#123;\n        final byte[] key = getLicenseKey();\n        if (null == key)&#123;\n            throw new NoLicenseInstalledException(getLicenseParam().getSubject());\n        &#125;\n        GenericCertificate certificate = getPrivacyGuard().key2cert(key);\n        notary.verify(certificate);\n        final LicenseContent content = (LicenseContent)this.load(certificate.getEncoded());\n        /** 增加额外的自己的license校验方法，校验ip、mac、cpu序列号等 */\n        this.validate(content);\n        setCertificate(certificate);\n        return content;\n    &#125;\n\n    /**\n     * &lt;p>校验生成证书的参数信息&lt;/p>\n     * @param content LicenseContent 证书内容\n     * @throws LicenseContentException 证书内容错误异常\n     */\n    protected synchronized void validateCreate(final LicenseContent content) throws LicenseContentException &#123;\n\n        // 当前时间\n        final Date now = new Date();\n        // 生效时间\n        final Date notBefore = content.getNotBefore();\n        // 失效时间\n        final Date notAfter = content.getNotAfter();\n\n        if (null != notAfter &amp;&amp; now.after(notAfter))&#123;\n            String message = \"证书失效时间不能早于当前时间\";\n            log.error(message);\n            throw new LicenseContentException(message);\n        &#125;\n        if (null != notBefore &amp;&amp; null != notAfter &amp;&amp; notAfter.before(notBefore))&#123;\n            String message = \"证书生效时间不能晚于证书失效时间\";\n            log.error(message);\n            throw new LicenseContentException(message);\n        &#125;\n        final String consumerType = content.getConsumerType();\n        if (null == consumerType)&#123;\n            String message = \"用户类型不能为空\";\n            log.error(message);\n            throw new LicenseContentException(message);\n        &#125;\n\n    &#125;\n\n    /**\n     * &lt;p>重写validate方法，增加ip地址、mac地址、cpu序列号等其他信息的校验&lt;/p>\n     * @param content LicenseContent 证书内容\n     */\n    @Override\n    protected synchronized void validate(final LicenseContent content) throws LicenseContentException &#123;\n        // 当前时间\n        final Date now = new Date();\n        final Date notAfter = content.getNotAfter();\n        if(now.after(notAfter))&#123;\n            throw new LicenseContentException(\"系统证书过期，当前时间已超过证书有效期 -- \"+\n                    DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS,notAfter));\n        &#125;\n        //1、 首先调用父类的validate方法\n        super.validate(content);\n        //2、 然后校验自定义的License参数 License中可被允许的参数信息\n        LicenseExtraParam expectedCheck = (LicenseExtraParam) content.getExtra();\n        //当前服务器真实的参数信息\n        LicenseExtraParam serverCheckModel = AServerInfos.getServer(null).getServerInfos();\n        if(expectedCheck != null &amp;&amp; serverCheckModel != null)&#123;\n            //校验IP地址\n            if(expectedCheck.isIpCheck() &amp;&amp; !checkIpAddress(expectedCheck.getIpAddress(),serverCheckModel.getIpAddress()))&#123;\n                String message = \"系统证书无效，当前服务器的IP没在授权范围内\";\n                log.error(message);\n                throw new LicenseContentException(message);\n            &#125;\n            //校验Mac地址\n            if(expectedCheck.isMacCheck() &amp;&amp; !checkIpAddress(expectedCheck.getMacAddress(),serverCheckModel.getMacAddress()))&#123;\n                String message = \"系统证书无效，当前服务器的Mac地址没在授权范围内\";\n                log.error(message);\n                throw new LicenseContentException(message);\n            &#125;\n            //校验主板序列号\n            if(expectedCheck.isBoardCheck() &amp;&amp; !checkSerial(expectedCheck.getMainBoardSerial(),serverCheckModel.getMainBoardSerial()))&#123;\n                String message = \"系统证书无效，当前服务器的主板序列号没在授权范围内\";\n                log.error(message);\n                throw new LicenseContentException(message);\n            &#125;\n            //校验CPU序列号\n            if(expectedCheck.isCpuCheck() &amp;&amp; !checkSerial(expectedCheck.getCpuSerial(),serverCheckModel.getCpuSerial()))&#123;\n                String message = \"系统证书无效，当前服务器的CPU序列号没在授权范围内\";\n                log.error(message);\n                throw new LicenseContentException(message);\n            &#125;\n        &#125;else&#123;\n            throw new LicenseContentException(\"不能获取服务器硬件信息\");\n        &#125;\n    &#125;\n\n    /**\n     * &lt;p>重写XMLDecoder解析XML&lt;/p>\n     */\n    private Object load(String encoded)&#123;\n        BufferedInputStream inputStream = null;\n        XMLDecoder decoder = null;\n        try &#123;\n            inputStream = new BufferedInputStream(new ByteArrayInputStream(encoded.getBytes(XML_CHARSET)));\n            decoder = new XMLDecoder(new BufferedInputStream(inputStream, DEFAULT_BUFF_SIZE),null,null);\n            return decoder.readObject();\n        &#125; catch (UnsupportedEncodingException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            try &#123;\n                if(decoder != null)&#123;\n                    decoder.close();\n                &#125;\n                if(inputStream != null)&#123;\n                    inputStream.close();\n                &#125;\n            &#125; catch (Exception e) &#123;\n                log.error(\"XMLDecoder解析XML失败\",e);\n            &#125;\n        &#125;\n        return null;\n\n    &#125;\n\n    /**\n     * &lt;p>\n     *     校验当前服务器的IP/Mac地址是否在可被允许的IP范围内&lt;br/>\n     *     如果存在IP在可被允许的IP/Mac地址范围内，则返回true\n     * &lt;/p>\n     *\n     */\n    private boolean checkIpAddress(List&lt;String> expectedList, List&lt;String> serverList)&#123;\n\n        /** 如果期望的IP列表空直接返回false，因为既然验证ip，这一项必须要有元素 */\n        if(CommonUtils.isEmpty(expectedList))&#123;\n            return false ;\n        &#125;\n        /** 如果当前服务器的IP列表空直接返回false，因为服务器不可能获取不到ip，没有的话验证个锤子 */\n        if(CommonUtils.isEmpty(serverList))&#123;\n            return false ;\n        &#125;\n        for(String expected : expectedList)&#123;\n            if(serverList.contains(expected.trim()))&#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n\n    &#125;\n\n    /**\n     * &lt;p>校验当前服务器硬件（主板、CPU等）序列号是否在可允许范围内&lt;/p>\n     * @param expectedSerial 主板信息\n     * @param serverSerial 服务器信息\n     * @return boolean\n     */\n    private boolean checkSerial(String expectedSerial, String serverSerial)&#123;\n        if(CommonUtils.isNotEmpty(expectedSerial))&#123;\n            if(CommonUtils.isNotEmpty(serverSerial))&#123;\n                return expectedSerial.equals(serverSerial);\n            &#125;\n            return false;\n        &#125;else&#123;\n            return true;\n        &#125;\n    &#125;\n&#125;\n\n\n\nLicenseExtraParam\n/**\n* @Description\n* 自定义需要校验的License参数\n* @author Anchor\n* @Date 2021/9/1\n*/\npublic class LicenseExtraParam implements Serializable &#123;\n\n    private static final long serialVersionUID = 8600137500316662317L;\n\n    /** 是否认证ip*/\n    private boolean isIpCheck ;\n\n    /** 可被允许的IP地址*/\n    private List&lt;String> ipAddress;\n\n    /**是否认证mac*/\n    private boolean isMacCheck ;\n\n    /** 可被允许的mac地址*/\n    private List&lt;String> macAddress;\n\n    /**是否认证cpu序列号*/\n    private boolean isCpuCheck ;\n\n    /** 可被允许的CPU序列号*/\n    private String cpuSerial;\n\n    /** 是否认证主板号*/\n    private boolean isBoardCheck ;\n\n    /**可被允许的主板序列号*/\n    private String mainBoardSerial;\n\n    /** 是否限制注册人数*/\n    private boolean isRegisterCheck;\n\n    /** 限制系统中可注册的人数*/\n    private Long registerAmount;\n\n    /**其他可自行扩展字段*/\n\n    public LicenseExtraParam()&#123;\n\n    &#125;\n\n    public static long getSerialVersionUID() &#123;\n        return serialVersionUID;\n    &#125;\n\n    public List&lt;String> getIpAddress() &#123;\n        return ipAddress;\n    &#125;\n\n    public void setIpAddress(List&lt;String> ipAddress) &#123;\n        this.ipAddress = ipAddress;\n    &#125;\n\n    public List&lt;String> getMacAddress() &#123;\n        return macAddress;\n    &#125;\n\n    public void setMacAddress(List&lt;String> macAddress) &#123;\n        this.macAddress = macAddress;\n    &#125;\n\n    public String getCpuSerial() &#123;\n        return cpuSerial;\n    &#125;\n\n    public void setCpuSerial(String cpuSerial) &#123;\n        this.cpuSerial = cpuSerial;\n    &#125;\n\n    public String getMainBoardSerial() &#123;\n        return mainBoardSerial;\n    &#125;\n\n    public void setMainBoardSerial(String mainBoardSerial) &#123;\n        this.mainBoardSerial = mainBoardSerial;\n    &#125;\n\n    public boolean isIpCheck() &#123;\n        return isIpCheck;\n    &#125;\n\n    public void setIpCheck(boolean ipCheck) &#123;\n        isIpCheck = ipCheck;\n    &#125;\n\n    public boolean isMacCheck() &#123;\n        return isMacCheck;\n    &#125;\n\n    public void setMacCheck(boolean macCheck) &#123;\n        isMacCheck = macCheck;\n    &#125;\n\n    public boolean isCpuCheck() &#123;\n        return isCpuCheck;\n    &#125;\n\n    public void setCpuCheck(boolean cpuCheck) &#123;\n        isCpuCheck = cpuCheck;\n    &#125;\n\n    public boolean isBoardCheck() &#123;\n        return isBoardCheck;\n    &#125;\n\n    public void setBoardCheck(boolean boardCheck) &#123;\n        isBoardCheck = boardCheck;\n    &#125;\n\n    public Long getRegisterAmount() &#123;\n        return registerAmount;\n    &#125;\n\n    public void setRegisterAmount(Long registerAmount) &#123;\n        this.registerAmount = registerAmount;\n    &#125;\n\n    public boolean isRegisterCheck() &#123;\n        return isRegisterCheck;\n    &#125;\n\n    public void setRegisterCheck(boolean registerCheck) &#123;\n        isRegisterCheck = registerCheck;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"LicenseExtraParam&#123;\" +\n            \"ipAddress=\" + ipAddress +\n            \", macAddress=\" + macAddress +\n            \", cpuSerial='\" + cpuSerial + '\\'' +\n            \", mainBoardSerial='\" + mainBoardSerial + '\\'' +\n            \", registerAmount='\" + registerAmount + '\\'' +\n            '&#125;';\n    &#125;\n&#125;\n\n\n\nLicenseResult\n/**\n * @Description\n * License证书验证结果对象\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class LicenseResult &#123;\n\n    /** 检验结果 */\n    private Boolean result;\n    /** 附加信息 */\n    private String message;\n    /** 证书内容 */\n    private LicenseContent content;\n    /** 检验失败错误 */\n    private Exception exception;\n\n    public LicenseResult(LicenseContent content) &#123;\n        this.result = true;\n        this.content = content;\n    &#125;\n\n    public LicenseResult(String message, LicenseContent content) &#123;\n        this.result = true;\n        this.message = message;\n        this.content = content;\n    &#125;\n\n    public LicenseResult(Exception exception) &#123;\n        this.result = false;\n        this.exception = exception;\n    &#125;\n\n    public LicenseResult(String message, Exception exception) &#123;\n        this.result = false;\n        this.message = message;\n        this.exception = exception;\n    &#125;\n\n    public LicenseResult(boolean result , String message, Exception exception) &#123;\n        this.result = result;\n        this.message = message;\n        this.exception = exception;\n    &#125;\n\n    public Boolean getResult() &#123;\n        return result;\n    &#125;\n\n    public void setResult(Boolean result) &#123;\n        this.result = result;\n    &#125;\n\n    public String getMessage() &#123;\n        return message;\n    &#125;\n\n    public void setMessage(String message) &#123;\n        this.message = message;\n    &#125;\n\n    public LicenseContent getContent() &#123;\n        return content;\n    &#125;\n\n    public void setContent(LicenseContent content) &#123;\n        this.content = content;\n    &#125;\n\n    public Exception getException() &#123;\n        return exception;\n    &#125;\n\n    public void setException(Exception exception) &#123;\n        this.exception = exception;\n    &#125;\n&#125;\n\n\n\nLicenseVerifyManager\n/**\n * @Description\n * License校验类\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class LicenseVerifyManager &#123;\n\n    private static final Logger log = LoggerFactory.getLogger(LicenseVerifyManager.class);\n\n    /**\n     * &lt;p>安装License证书&lt;/p>\n     * @param param License校验类需要的参数\n     */\n    public synchronized LicenseResult install(LicenseVerifyParam param)&#123;\n        try&#123;\n            /** 1、初始化License证书参数 */\n            LicenseParam licenseParam = ParamInitHelper.initLicenseParam(param);\n            /** 2、创建License证书管理器对象 */\n//          LicenseManager licenseManager =new LicenseManager(licenseParam);\n            //走自定义的Lic管理\n            LicenseCustomManager licenseManager = new LicenseCustomManager(licenseParam);\n            /** 3、获取要安装的证书文件 */\n            File licenseFile = ResourceUtils.getFile(param.getLicensePath());\n            /** 4、如果之前安装过证书，先卸载之前的证书 == 给null */\n            licenseManager.uninstall();\n            /** 5、开始安装 */\n            LicenseContent content = licenseManager.install(licenseFile);\n            String message = MessageFormat.format(\"证书安装成功，证书有效期：&#123;0&#125; - &#123;1&#125;\",\n                    DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS,content.getNotBefore()),\n                    DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS,content.getNotAfter()));\n            log.info(message);\n            return new LicenseResult(message,content);\n        &#125;catch (LicenseContentException contentExc)&#123;\n            String message = contentExc.getMessage();\n            log.error(message);\n            return new LicenseResult(false,message,contentExc);\n        &#125; catch (Exception e)&#123;\n            log.error(e.getMessage(),e);\n            return new LicenseResult(false,e.getMessage(),e);\n        &#125;\n    &#125;\n\n    /**\n     * &lt;p>校验License证书&lt;/p>\n     * @param param License校验类需要的参数\n     */\n    public LicenseResult verify(LicenseVerifyParam param)&#123;\n\n        /** 1、初始化License证书参数 */\n        LicenseParam licenseParam = ParamInitHelper.initLicenseParam(param);\n        /** 2、创建License证书管理器对象 */\n        LicenseManager licenseManager = new LicenseCustomManager(licenseParam);\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        /** 3、开始校验证书 */\n        try &#123;\n            LicenseContent licenseContent = licenseManager.verify();\n            String message = MessageFormat.format(\"证书校验通过，证书有效期：&#123;0&#125; - &#123;1&#125;\",\n                    format.format(licenseContent.getNotBefore()),format.format(licenseContent.getNotAfter()));\n            log.info(message);\n            return new LicenseResult(message,licenseContent);\n        &#125;catch (NoLicenseInstalledException ex)&#123;\n            String message = \"证书未安装！\";\n            log.error(message,ex);\n            return new LicenseResult(false,message,ex);\n        &#125;catch (LicenseContentException cex)&#123;\n            log.error(cex.getMessage(),cex);\n            return new LicenseResult(false,cex.getMessage(),cex);\n        &#125; catch (Exception e)&#123;\n            String message = \"证书校验失败！\";\n            log.error(message,e);\n            return new LicenseResult(false,message,e);\n        &#125;\n    &#125;\n\n\n&#125;\n\n\n\nLicenseVerifyParam\n/**\n * @Description\n * License校验类需要的参数\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class LicenseVerifyParam &#123;\n\n    /**证书主题*/\n    private String subject;\n\n    /**公钥别名*/\n    private String publicAlias;\n\n    /** 访问公钥库的密码*/\n    private String storePass;\n\n    /**证书生成路径*/\n    private String licensePath;\n\n    /**公钥库存储路径*/\n    private String publicKeysStorePath;\n\n    public LicenseVerifyParam() &#123;\n\n    &#125;\n\n    public LicenseVerifyParam(String subject, String publicAlias, String storePass, String licensePath, String publicKeysStorePath) &#123;\n        this.subject = subject;\n        this.publicAlias = publicAlias;\n        this.storePass = storePass;\n        this.licensePath = licensePath;\n        this.publicKeysStorePath = publicKeysStorePath;\n    &#125;\n\n    public String getSubject() &#123;\n        return subject;\n    &#125;\n\n    public void setSubject(String subject) &#123;\n        this.subject = subject;\n    &#125;\n\n    public String getPublicAlias() &#123;\n        return publicAlias;\n    &#125;\n\n    public void setPublicAlias(String publicAlias) &#123;\n        this.publicAlias = publicAlias;\n    &#125;\n\n    public String getStorePass() &#123;\n        return storePass;\n    &#125;\n\n    public void setStorePass(String storePass) &#123;\n        this.storePass = storePass;\n    &#125;\n\n    public String getLicensePath() &#123;\n        return licensePath;\n    &#125;\n\n    public void setLicensePath(String licensePath) &#123;\n        this.licensePath = licensePath;\n    &#125;\n\n    public String getPublicKeysStorePath() &#123;\n        return publicKeysStorePath;\n    &#125;\n\n    public void setPublicKeysStorePath(String publicKeysStorePath) &#123;\n        this.publicKeysStorePath = publicKeysStorePath;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"LicenseVerifyParam&#123;\" +\n                \"subject='\" + subject + '\\'' +\n                \", publicAlias='\" + publicAlias + '\\'' +\n                \", storePass='\" + storePass + '\\'' +\n                \", licensePath='\" + licensePath + '\\'' +\n                \", publicKeysStorePath='\" + publicKeysStorePath + '\\'' +\n                '&#125;';\n    &#125;\n&#125;\n\n\nservice\nAServerInfos\n/**\n * @Description\n * 服务器硬件信息抽象类 -- 模板方法，将通用的方法抽离到父类中\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic abstract class AServerInfos &#123;\n\n    private static class GxServerInfosContainer &#123;\n        private static List&lt;String> ipAddress = null;\n        private static List&lt;String> macAddress = null;\n        private static String cpuSerial = null;\n        private static String mainBoardSerial = null;\n    &#125;\n\n    /**\n     * @Description\n     * 组装需要额外校验的License参数\n     * @return LicenseExtraParam 自定义校验参数\n     * @author 陈际栋\n     * @Date 2021/9/1\n    */\n    public LicenseExtraParam getServerInfos() throws LicenseContentException &#123;\n        LicenseExtraParam result = new LicenseExtraParam();\n        try &#123;\n            initServerInfos();\n            result.setIpAddress(GxServerInfosContainer.ipAddress);\n            result.setMacAddress(GxServerInfosContainer.macAddress);\n            result.setCpuSerial(GxServerInfosContainer.cpuSerial);\n            result.setMainBoardSerial(GxServerInfosContainer.mainBoardSerial);\n        &#125; catch (Exception e) &#123;\n            throw new LicenseContentException(\"获取服务器硬件信息失败\");\n        &#125;\n        return result;\n    &#125;\n\n    /**\n     * &lt;p>初始化服务器硬件信息，并将信息缓存到内存&lt;/p>\n     *\n     * @throws Exception 默认异常\n     */\n    private void initServerInfos() throws Exception &#123;\n        if (GxServerInfosContainer.ipAddress == null) &#123;\n            GxServerInfosContainer.ipAddress = this.getIpAddress();\n        &#125;\n        if (GxServerInfosContainer.macAddress == null) &#123;\n            GxServerInfosContainer.macAddress = this.getMacAddress();\n        &#125;\n        if (GxServerInfosContainer.cpuSerial == null) &#123;\n            GxServerInfosContainer.cpuSerial = this.getCPUSerial();\n        &#125;\n        if (GxServerInfosContainer.mainBoardSerial == null) &#123;\n            GxServerInfosContainer.mainBoardSerial = this.getMainBoardSerial();\n        &#125;\n    &#125;\n\n    /**\n     * &lt;p>获取IP地址&lt;/p>\n     *\n     * @return List&lt;String> IP地址\n     * @throws Exception 默认异常\n     */\n    public List&lt;String> getIpAddress() throws Exception &#123;\n        /** 获取所有网络接口 */\n        List&lt;InetAddress> inetAddresses = getLocalAllInetAddress();\n        if (CommonUtils.isNotEmpty(inetAddresses)) &#123;\n            return inetAddresses.stream().map(InetAddress::getHostAddress).distinct().map(String::toLowerCase).collect(Collectors.toList());\n        &#125;\n        return null;\n    &#125;\n\n    /**\n     * &lt;p>获取Mac地址&lt;/p>\n     *\n     * @return List&lt;String> Mac地址\n     * @throws Exception 默认异常\n     */\n    public List&lt;String> getMacAddress() throws Exception &#123;\n        /** 获取所有网络接口 */\n        List&lt;InetAddress> inetAddresses = getLocalAllInetAddress();\n        if (CommonUtils.isNotEmpty(inetAddresses)) &#123;\n            return inetAddresses.stream().map(this::getMacByInetAddress).distinct().collect(Collectors.toList());\n        &#125;\n        return null;\n    &#125;\n\n    /**\n     * &lt;p>获取服务器信息&lt;/p>\n     *\n     * @param osName 系统类型\n     * @return AGxServerInfos 服务信息\n     */\n    public static AServerInfos getServer(String osName) &#123;\n        if (\"\".equals(osName) || osName == null) &#123;\n            osName = System.getProperty(\"os.name\").toLowerCase();\n        &#125;\n        AServerInfos abstractServerInfos;\n        //根据不同操作系统类型选择不同的数据获取方法\n        if (osName.startsWith(OsType.WINDOWS.getCode())) &#123;\n            abstractServerInfos = new WindowsServerInfos();\n        &#125; else if (osName.startsWith(OsType.LINUX.getCode())) &#123;\n            abstractServerInfos = new LinuxServerInfos();\n        &#125; else if (osName.startsWith(OsType.MACOS.getCode()))&#123;\n            abstractServerInfos = new MacintoshServerInfos();\n        &#125; else &#123;//其他服务器类型\n            abstractServerInfos = new LinuxServerInfos();\n        &#125;\n        return abstractServerInfos;\n    &#125;\n\n    /**\n     * &lt;p>获取CPU序列号&lt;/p>\n     *\n     * @return String 主板序列号\n     * @throws Exception 默认异常\n     */\n    protected abstract String getCPUSerial() throws Exception;\n\n    /**\n     * &lt;p>获取主板序列号&lt;/p>\n     *\n     * @return String 主板序列号\n     * @throws Exception 默认异常\n     */\n    protected abstract String getMainBoardSerial() throws Exception;\n\n    /**\n     * &lt;p>获取当前服务器所有符合条件的网络地址&lt;/p>\n     *\n     * @return List&lt;InetAddress> 网络地址列表\n     * @throws Exception 默认异常\n     */\n    private List&lt;InetAddress> getLocalAllInetAddress() throws Exception &#123;\n        List&lt;InetAddress> result = new ArrayList&lt;>(4);\n        // 遍历所有的网络接口\n        for (Enumeration networkInterfaces = NetworkInterface.getNetworkInterfaces(); networkInterfaces.hasMoreElements(); ) &#123;\n            NetworkInterface ni = (NetworkInterface) networkInterfaces.nextElement();\n            // 在所有的接口下再遍历IP\n            for (Enumeration addresses = ni.getInetAddresses(); addresses.hasMoreElements(); ) &#123;\n                InetAddress address = (InetAddress) addresses.nextElement();\n                //排除LoopbackAddress、SiteLocalAddress、LinkLocalAddress、MulticastAddress类型的IP地址\n                if (!address.isLoopbackAddress()\n                        &amp;&amp; !address.isLinkLocalAddress() &amp;&amp; !address.isMulticastAddress()) &#123;\n                    result.add(address);\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n\n    /**\n     * &lt;p>获取服务器临时磁盘位置&lt;/p>\n     */\n    public static String getServerTempPath() &#123;\n        String property = System.getProperty(\"user.dir\");\n        return property;\n    &#125;\n\n    /**\n     * &lt;p>获取某个网络地址对应的Mac地址&lt;/p>\n     *\n     * @param inetAddr 网络地址\n     * @return String Mac地址\n     */\n    private String getMacByInetAddress(InetAddress inetAddr) &#123;\n        try &#123;\n            byte[] mac = NetworkInterface.getByInetAddress(inetAddr).getHardwareAddress();\n            StringBuilder stringBuilder = new StringBuilder();\n            for (int i = 0; i &lt; mac.length; i++) &#123;\n                if (i != 0) &#123;\n                    stringBuilder.append(\"-\");\n                &#125;\n                /** 将十六进制byte转化为字符串 */\n                String temp = Integer.toHexString(mac[i] &amp; 0xff);\n                if (temp.length() == 1) &#123;\n                    stringBuilder.append(\"0\").append(temp);\n                &#125; else &#123;\n                    stringBuilder.append(temp);\n                &#125;\n            &#125;\n            return stringBuilder.toString().toUpperCase();\n        &#125; catch (SocketException e) &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n\n&#125;\n\n\n\nLinuxServerInfos\n/**\n * @Description\n * 用于获取客户Linux服务器的基本信息\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class LinuxServerInfos extends AServerInfos &#123;\n\n    private final String[] CPU_SHELL = &#123;\"/bin/bash\",\"-c\",\"dmidecode -t processor | grep 'ID' | awk -F ':' '&#123;print $2&#125;' | head -n 1\"&#125;;\n    private final String[] MAIN_BOARD_SHELL = &#123;\"/bin/bash\",\"-c\",\"dmidecode | grep 'Serial Number' | awk -F ':' '&#123;print $2&#125;' | head -n 1\"&#125;;\n\n    @Override\n    protected String getCPUSerial() throws Exception &#123;\n        String result = \"\";\n        String CPU_ID_CMD = \"dmidecode\";\n        BufferedReader bufferedReader = null;\n        Process p = null;\n        try &#123;\n            p = Runtime.getRuntime().exec(new String[] &#123; \"sh\", \"-c\", CPU_ID_CMD &#125;);\n            bufferedReader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line = null;\n            int index = -1;\n            while ((line = bufferedReader.readLine()) != null) &#123;\n                // 寻找标示字符串[hwaddr]\n                index = line.toLowerCase().indexOf(\"uuid\");\n                if (index >= 0) &#123;\n                    // 取出mac地址并去除2边空格\n                    result = line.substring(index + \"uuid\".length() + 1).trim();\n                    break;\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            throw new LicenseException(\"获取cpu信息错误\", e);\n        &#125;\n        return result.trim();\n    &#125;\n\n    @Override\n    protected String getMainBoardSerial() throws Exception &#123;\n        String result = \"\";\n        String maniBord_cmd = \"dmidecode | grep 'Serial Number' | awk '&#123;print $3&#125;' | tail -1\";\n        Process p;\n        try &#123;\n            p = Runtime.getRuntime().exec(new String[] &#123; \"sh\", \"-c\", maniBord_cmd &#125;);\n            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line;\n            while ((line = br.readLine()) != null) &#123;\n                result += line;\n                break;\n            &#125;\n            br.close();\n        &#125; catch (IOException e) &#123;\n            throw new LicenseException(\"获取主板信息错误\", e);\n        &#125;\n        return  result;\n    &#125;\n\n\n&#125;\n\n\n\nMacintoshServerInfos\n/**\n * @program: license\n * @description: Macintosh系统信息获取\n * @author: Anchor\n * @create: 2021-08-30\n **/\npublic class MacintoshServerInfos extends AServerInfos &#123;\n\n    private final String SERIAL_SHELL = \"system_profiler SPHardwareDataType | grep Serial | awk '&#123;print $4&#125;'\";\n    private final String UUID_SHELL = \"system_profiler SPHardwareDataType | grep UUID | awk  '&#123;print $3&#125;'\";\n\n    @Override\n    protected String getCPUSerial() throws Exception &#123;\n        String result = \"\";\n        try &#123;\n            // 管道\n            Process p = Runtime.getRuntime().exec(new String[] &#123; \"sh\", \"-c\", SERIAL_SHELL &#125;);\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            result = bufferedReader.readLine();\n        &#125; catch (IOException e) &#123;\n            throw new LicenseException(\"获取cpu信息错误\", e);\n        &#125;\n        return result.trim();\n    &#125;\n\n    @Override\n    protected String getMainBoardSerial() throws Exception &#123;\n        String result = \"\";\n        try &#123;\n            // 管道\n            Process p = Runtime.getRuntime().exec(new String[] &#123; \"sh\", \"-c\", UUID_SHELL &#125;);\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            result = bufferedReader.readLine();\n        &#125; catch (IOException e) &#123;\n            throw new LicenseException(\"获取主板信息错误\", e);\n        &#125;\n        return result.trim();\n    &#125;\n&#125;\n\n\n\nWindowsServerInfos\n/**\n * @Description\n * 用于获取客户Windows服务器的基本信息\n * @author Anchor\n * @Date 2021/9/1\n*/\npublic class WindowsServerInfos extends AServerInfos &#123;\n\n    private final String CPU_COMMAND = \"wmic cpu get processorid\";\n    private final String MAIN_BOARD_COMMAND = \"wmic baseboard get serialnumber\";\n\n    @Override\n    protected String getCPUSerial() throws Exception &#123;\n        String result = \"\";\n        try &#123;\n            File file = File.createTempFile(\"tmp\", \".vbs\");\n            file.deleteOnExit();\n            FileWriter fw = new FileWriter(file);\n            String vbs = \"Set objWMIService = GetObject(\\\"winmgmts:\\\\\\\\.\\\\root\\\\cimv2\\\")\\n\"\n                    + \"Set colItems = objWMIService.ExecQuery _ \\n\" + \"   (\\\"Select * from Win32_Processor\\\") \\n\"\n                    + \"For Each objItem in colItems \\n\" + \"    Wscript.Echo objItem.ProcessorId \\n\"\n                    + \"    exit for  ' do the first cpu only! \\n\" + \"Next \\n\";\n\n            fw.write(vbs);\n            fw.close();\n            Process p = Runtime.getRuntime().exec(\"cscript //NoLogo \" + file.getPath());\n            BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line;\n            while ((line = input.readLine()) != null) &#123;\n                result += line;\n            &#125;\n            input.close();\n            file.delete();\n        &#125; catch (Exception e) &#123;\n            throw new LicenseException(\"获取cpu信息错误\", e);\n        &#125;\n        return result.trim();\n    &#125;\n\n    @Override\n    protected String getMainBoardSerial() throws Exception &#123;\n\n        String result = \"\";\n        try &#123;\n            File file = File.createTempFile(\"realhowto\", \".vbs\");\n            file.deleteOnExit();\n            FileWriter fw = new FileWriter(file);\n\n            String vbs = \"Set objWMIService = GetObject(\\\"winmgmts:\\\\\\\\.\\\\root\\\\cimv2\\\")\\n\"\n                    + \"Set colItems = objWMIService.ExecQuery _ \\n\" + \"   (\\\"Select * from Win32_BaseBoard\\\") \\n\"\n                    + \"For Each objItem in colItems \\n\" + \"    Wscript.Echo objItem.SerialNumber \\n\"\n                    + \"    exit for  ' do the first cpu only! \\n\" + \"Next \\n\";\n\n            fw.write(vbs);\n            fw.close();\n            Process p = Runtime.getRuntime().exec(\"cscript //NoLogo \" + file.getPath());\n            BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            String line;\n            while ((line = input.readLine()) != null) &#123;\n                result += line;\n            &#125;\n            input.close();\n        &#125; catch (Exception e) &#123;\n            throw new LicenseException(\"获取主板信息错误\", e);\n        &#125;\n        return result.trim();\n    &#125;\n\n\n&#125;\n\n\n2、license-creatorcreator模块主要作用是根据获取到的机器特征信息生成授权license文件，所以模块中会用到第二章生成的私钥文件，整体代码结构如下：\nconfig\nLicenseCreatorAutoConfigure\n/**\n* @Description\n* License生成模块自动扫包/装配Bean实例\n* @author Anchor\n* @Date 2021/9/1\n*/\n@Configuration\n    @ComponentScan(basePackages = &#123;\"com.alihai5.license.creator\"&#125;)\n    @EnableConfigurationProperties(&#123;LicenseCreatorProperties.class&#125;)\n    public class LicenseCreatorAutoConfigure &#123;\n        public LicenseCreatorAutoConfigure()&#123;\n\n        &#125;\n    &#125;\n\n\n\nLicenseCreatorProperties\n/**\n * @Description\n * License生成配置类\n * @author Anchor\n * @Date 2021/9/1\n*/\n@ConfigurationProperties(prefix = \"springboot.license.generate\")\npublic class LicenseCreatorProperties &#123;\n\n    /**证书生成临时存放路径*/\n    private String tempPath;\n\n    public LicenseCreatorProperties() &#123;\n    &#125;\n\n    public String getTempPath() &#123;\n        return tempPath;\n    &#125;\n\n    public void setTempPath(String tempPath) &#123;\n        this.tempPath = tempPath;\n        File file = new File(tempPath);\n        if(!file.exists())&#123;\n            file.mkdirs();\n        &#125;\n    &#125;\n&#125;\n\n\ncontroller\nLicenseCreatorController\n/**\n * @Description\n * 用于生成证书文件\n * @author Anchor\n * @Date 2021/9/1\n*/\n@CrossOrigin\n@RestController\n@RequestMapping(\"/license\")\npublic class LicenseCreatorController &#123;\n\n    @Value(\"$&#123;springboot.license.server.prefix:http://localhost:8080/license/&#125;\")\n    private String licPrefixUrl ;\n\n    @Autowired\n    private LicenseCreatorService creatorService ;\n\n    @Autowired\n    private LicenseCreatorProperties properties;\n\n    /**\n     * &lt;p>生成证书（硬件信息经过加密处理）&lt;/p>\n     * @param param 生成证书需要的参数，如：\n     *\n     */\n    @PostMapping(\"/generateFirst\")\n    public AjaxResult generateFirst(@RequestBody LicenseCreatorParam param,\n                                    @RequestParam String extraParam) throws Exception &#123;\n        // 解密加密后的硬件信息\n        LicenseExtraParam orginExtraParam = JSONObject.parseObject(new String(Base64.decode(extraParam),\n                StandardCharsets.UTF_8), LicenseExtraParam.class);\n        // 将解密后的硬件信息复制给处理对象\n        LicenseExtraParam licenseExtraParam = param.getLicenseCheck();\n        licenseExtraParam.setCpuSerial(orginExtraParam.getCpuSerial());\n        licenseExtraParam.setIpAddress(orginExtraParam.getIpAddress());\n        licenseExtraParam.setMacAddress(orginExtraParam.getMacAddress());\n        licenseExtraParam.setMainBoardSerial(orginExtraParam.getMainBoardSerial());\n\n        // 生成授权证书\n        return generate(param);\n    &#125;\n\n    /**\n     * &lt;p>生成证书&lt;/p>\n     * @param param 生成证书需要的参数，如：\n     *\n     */\n    @PostMapping(\"/generate\")\n    public AjaxResult generate(@RequestBody LicenseCreatorParam param) throws Exception &#123;\n        // 如果没有人为的指定lic要生成的位置，则程序自动处理\n        if(CommonUtils.isEmpty(param.getLicensePath()))&#123;\n            //设置格式\n            SimpleDateFormat format =  new SimpleDateFormat(\"yyyyMMddHHmmss\");\n            String tempPath = properties.getTempPath();\n            if(tempPath == null || \"\".equals(tempPath))&#123;\n                // 如果默认临时文件等于空的话，就获取当前服务执行的路径\n                tempPath = AServerInfos.getServerTempPath();\n            &#125;\n            // 根据时间戳，命名lic文件\n            String licDir = tempPath+\"/license/\"+format.format(System.currentTimeMillis());\n            File file = new File(licDir);\n            if(!file.exists())&#123;\n               if(!file.mkdirs())&#123;\n                   throw new CustomException(\"创建目录\"+licDir+\",失败，请检查是是否有创建目录的权限或者手动进行创建！\");\n               &#125;\n            &#125;\n            param.setLicensePath(licDir + \"/license.lic\");\n        &#125;\n        param.setLicUrl(licPrefixUrl+\"download?path=\"+param.getLicensePath());\n        return creatorService.generateLicense(param);\n    &#125;\n\n    @GetMapping(\"/download\")\n    public void downLoad(@RequestParam(value = \"path\") String path, HttpServletRequest request, HttpServletResponse response) throws Exception&#123;\n        File file = new File(path);\n        if(!file.exists())&#123;\n            response.setStatus(HttpStatus.NOT_FOUND.value());\n            return;\n        &#125;\n        InputStream is = new FileInputStream(file);\n        String fileName = file.getName();\n        // 设置文件ContentType类型，这样设置，会自动判断下载文件类型\n        response.setContentType(\"multipart/form-data\");\n        // 设置编码格式\n        response.setCharacterEncoding(\"UTF-8\");\n        // 设置可以识别Html文件\n        response.setContentType(\"text/html\");\n        // 设置头中附件文件名的编码\n        setAttachmentCoding(request, response, fileName);\n        BufferedInputStream bis = new BufferedInputStream(is);\n        OutputStream os = response.getOutputStream();\n        byte[] buffer = new byte[1024 * 10];\n        int length ;\n        while ((length = bis.read(buffer, 0, buffer.length)) != -1) &#123;\n            os.write(buffer, 0, length);\n        &#125;\n        os.close();\n        bis.close();\n        is.close();\n    &#125;\n\n    private void setAttachmentCoding(HttpServletRequest request, HttpServletResponse response, String fileName) &#123;\n        String browser;\n        try &#123;\n            browser = request.getHeader(\"User-Agent\");\n            if (-1 &lt; browser.indexOf(\"MSIE 6.0\") || -1 &lt; browser.indexOf(\"MSIE 7.0\")) &#123;\n                // IE6, IE7 浏览器\n                response.addHeader(\"content-disposition\", \"attachment;filename=\"\n                        + new String(fileName.getBytes(), \"ISO8859-1\"));\n            &#125; else if (-1 &lt; browser.indexOf(\"MSIE 8.0\")) &#123;\n                // IE8\n                response.addHeader(\"content-disposition\", \"attachment;filename=\"\n                        + URLEncoder.encode(fileName, \"UTF-8\"));\n            &#125; else if (-1 &lt; browser.indexOf(\"MSIE 9.0\")) &#123;\n                // IE9\n                response.addHeader(\"content-disposition\", \"attachment;filename=\"\n                        + URLEncoder.encode(fileName, \"UTF-8\"));\n            &#125; else if (-1 &lt; browser.indexOf(\"Chrome\")) &#123;\n                // 谷歌\n                response.addHeader(\"content-disposition\",\n                        \"attachment;filename*=UTF-8''\" + URLEncoder.encode(fileName, \"UTF-8\"));\n            &#125; else if (-1 &lt; browser.indexOf(\"Safari\")) &#123;\n                // 苹果\n                response.addHeader(\"content-disposition\", \"attachment;filename=\"\n                        + new String(fileName.getBytes(), \"ISO8859-1\"));\n            &#125; else &#123;\n                // 火狐或者其他的浏览器\n                response.addHeader(\"content-disposition\",\n                        \"attachment;filename*=UTF-8''\" + URLEncoder.encode(fileName, \"UTF-8\"));\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n&#125;\n\n\nservice\nLicenseCreatorService\n/**\n * @Description\n * 证书生成接口实现\n * @author Anchor\n * @Date 2021/9/1\n*/\n@Service\npublic class LicenseCreatorService &#123;\n    /**\n     * &lt;p>生成证书&lt;/p>\n     * @param param 证书创建需要的参数对象\n     * @return Map&lt;String,Object>\n     */\n    public AjaxResult generateLicense(LicenseCreatorParam param) &#123;\n        LicenseCreatorManager licenseCreator = new LicenseCreatorManager(param);\n        LicenseResult licenseResult = licenseCreator.generateLicense();\n        if(licenseResult.getResult())&#123;\n            String message = MessageFormat.format(\"证书生成成功，证书有效期：&#123;0&#125; - &#123;1&#125;\",\n                    DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS,param.getIssuedTime()),\n                    DateUtils.parseDateToStr(DateUtils.YYYY_MM_DD_HH_MM_SS,param.getExpiryTime()));\n            return AjaxResult.success(message,param);\n        &#125;else&#123;\n            return AjaxResult.error(\"证书文件生成失败！\");\n        &#125;\n    &#125;\n\n\n&#125;\n\n\n3、license-verifyverify模块内嵌于客户端，用于校验授权license是否合法，所以模块中会用到第二章生成的公钥文件，项目启动后执行，如不合法则抛出异常并终止JVM，其结构如下：\nannotion\nVLicense\n/**\n * @Description\n * License自定义注解\n * @author Anchor\n * @Date 2021/9/2\n*/\n@Target(&#123;ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface VLicense &#123;\n    String[] verifies() default&#123;&#125;;\n&#125;\n\n\nconfig\nLicenseInterceptorConfig\n/**\n * @Description\n * License拦截器配置类\n * @author Anchor\n * @Date 2021/9/2\n*/\n@Configuration\npublic class LicenseInterceptorConfig implements WebMvcConfigurer &#123;\n\n    @Bean\n    public LicenseVerifyInterceptor getLicenseCheckInterceptor() &#123;\n        return new LicenseVerifyInterceptor();\n    &#125;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(this.getLicenseCheckInterceptor()).addPathPatterns(\"/**\");\n    &#125;\n&#125;\n\n\n\nLicenseVerifyAutoConfigure\n/**\n * @Description\n * License验证模块自动扫包/装配Bean实例\n * @author Anchor\n * @Date 2021/9/2\n*/\n@Configuration\n@ComponentScan(basePackages = &#123;\"com.alihai5.license.verify\"&#125;)\npublic class LicenseVerifyAutoConfigure &#123;\n\n    public LicenseVerifyAutoConfigure()&#123;\n        \n    &#125;\n&#125;\n\n\n\nLicenseVerifyProperties\n/**\n * @Description\n * License验证属性类\n * @author Anchor\n * @Date 2021/9/2\n*/\n@Component\n@ConfigurationProperties(prefix = \"groot.license.verify\")\npublic class LicenseVerifyProperties &#123;\n\n    private String subject = \"groot\";\n    private String publicAlias = \"publicCerts\";\n    private String publicKeysStorePath = \"/publicCerts.store\";\n    private String storePass = \"groot7758\";\n    private String licensePath;\n\n    public LicenseVerifyProperties() &#123;\n    &#125;\n\n    public String getSubject() &#123;\n        return subject;\n    &#125;\n\n    public void setSubject(String subject) &#123;\n        this.subject = subject;\n    &#125;\n\n    public String getPublicAlias() &#123;\n        return publicAlias;\n    &#125;\n\n    public void setPublicAlias(String publicAlias) &#123;\n        this.publicAlias = publicAlias;\n    &#125;\n\n    public String getPublicKeysStorePath() &#123;\n        return publicKeysStorePath;\n    &#125;\n\n    public void setPublicKeysStorePath(String publicKeysStorePath) &#123;\n        this.publicKeysStorePath = publicKeysStorePath;\n    &#125;\n\n    public String getStorePass() &#123;\n        return storePass;\n    &#125;\n\n    public void setStorePass(String storePass) &#123;\n        this.storePass = storePass;\n    &#125;\n\n    public String getLicensePath() &#123;\n        return licensePath;\n    &#125;\n\n    public void setLicensePath(String licensePath) &#123;\n        this.licensePath = licensePath;\n    &#125;\n\n    public LicenseVerifyParam getVerifyParam() &#123;\n        LicenseVerifyParam param = new LicenseVerifyParam();\n        param.setSubject(subject);\n        param.setPublicAlias(publicAlias);\n        param.setStorePass(storePass);\n        param.setLicensePath(licensePath);\n        param.setPublicKeysStorePath(publicKeysStorePath);\n        return param;\n    &#125;\n&#125;\n\n\ninterceptor\nLicenseVerifyInterceptor\n/**\n * @Description\n * License验证拦截器\n * @author Anchor\n * @Date 2021/9/2\n*/\npublic class LicenseVerifyInterceptor implements HandlerInterceptor &#123;\n\n    @Autowired\n    private LicenseVerifyProperties properties;\n\n    public LicenseVerifyInterceptor() &#123;\n    &#125;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        if (handler instanceof HandlerMethod) &#123;\n            HandlerMethod handlerMethod = (HandlerMethod) handler;\n            Method method = handlerMethod.getMethod();\n            VLicense annotation = method.getAnnotation(VLicense.class);\n            if (CommonUtils.isNotEmpty(annotation)) &#123;\n                LicenseVerifyManager licenseVerifyManager = new LicenseVerifyManager();\n                /** 1、校验证书是否有效 */\n                LicenseResult verifyResult = licenseVerifyManager.verify(properties.getVerifyParam());\n                if(!verifyResult.getResult())&#123;\n                    throw  new LicenseException(verifyResult.getMessage());\n                &#125;\n                LicenseContent content = verifyResult.getContent();\n                LicenseExtraParam licenseCheck = (LicenseExtraParam) content.getExtra();\n                if (verifyResult.getResult()) &#123;\n                    /** 增加业务系统监听，是否自定义验证 */\n                    List&lt;ACustomVerifyListener> customListenerList = ACustomVerifyListener.getCustomListenerList();\n                    boolean compare = true;\n                    for (ACustomVerifyListener listener : customListenerList) &#123;\n                        boolean verify = listener.verify(licenseCheck);\n                        compare = compare &amp;&amp; verify;\n                    &#125;\n                    return compare;\n                &#125;\n                throw new LicenseException(verifyResult.getException().getMessage());\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\n\nlistener\nACustomVerifyListener\n/**\n * @Description\n * 增加业务系统中自定义证书验证监听器\n * @author Anchor\n * @Date 2021/9/2\n*/\npublic abstract class ACustomVerifyListener &#123;\n\n    /**软件证书参数全局验证监听容器*/\n    private static final List&lt;ACustomVerifyListener> CUSTOM_VERIFY_LISTENER_LIST = new ArrayList&lt;>(16);\n\n    public static List&lt;ACustomVerifyListener> getCustomListenerList()&#123;\n        return CUSTOM_VERIFY_LISTENER_LIST;\n    &#125;\n\n    /***\n     * 默认构造函数，干了一件事情，就是会把所有实现了这个抽象类的子类实例全部添加到全局自定义验证监听器列表中\n     * 因为在调用子类的构造函数时，会首先调用父类的构造器\n     */\n    public ACustomVerifyListener() &#123;\n        addCustomListener(this);\n    &#125;\n\n    public synchronized static void addCustomListener(ACustomVerifyListener verifyListener)&#123;\n        CUSTOM_VERIFY_LISTENER_LIST.add(verifyListener);\n    &#125;\n\n    /**\n     * 业务系统自定义证书认证方法\n     * @param licenseExtra 自定义验证参数\n     * @return boolean 是否成功\n     */\n    public abstract boolean verify(LicenseExtraParam licenseExtra) throws LicenseException;\n\n&#125;\n\n\n\nLicenseVerifyListener\n/**\n * @Description\n * 项目启动时安装证书&amp;定时检测lic变化，自动更替lic\n * @author Anchor\n * @Date 2021/9/2\n*/\n@Component\npublic class LicenseVerifyListener implements ApplicationListener&lt;ContextRefreshedEvent> &#123;\n\n    private static final Logger log = LoggerFactory.getLogger(LicenseVerifyListener.class);\n\n    /**\n     * 上下文对象实例\n     */\n    private static ApplicationContext applicationContext;\n\n    @Autowired\n    private LicenseVerifyProperties properties;\n\n    /**文件唯一身份标识 == 相当于人类的指纹一样*/\n    private static String md5 = \"\";\n    private static boolean isLoad = false;\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent event) &#123;\n        if(CommonUtils.isNotEmpty(properties.getLicensePath()))&#123;\n            install();\n            try&#123;\n                String readMd5 = getMd5(properties.getLicensePath());\n                isLoad = true;\n                if(LicenseVerifyListener.md5 == null || \"\".equals(LicenseVerifyListener.md5))&#123;\n                    LicenseVerifyListener.md5 =readMd5;\n                &#125;\n            &#125;catch (Exception e)&#123;\n\n            &#125;\n        &#125; else &#123;\n            HandlerLicenseRemider();\n        &#125;\n    &#125;\n\n    private void install() &#123;\n        log.info(\"++++++++ 开始安装授权证书 ++++++++\");\n        LicenseVerifyManager licenseVerifyManager = new LicenseVerifyManager();\n        /** 走定义校验证书并安装 */\n        LicenseResult result = licenseVerifyManager.install(properties.getVerifyParam());\n        if(result.getResult())&#123;\n            log.info(\"++++++++ 授权证书安装成功 ++++++++\");\n        &#125;else&#123;\n            log.error(\"++++++++ 授权证书安装失败 ++++++++\");\n            HandlerLicenseRemider();\n        &#125;\n    &#125;\n\n    /**\n     * &lt;p>获取文件的md5&lt;/p>\n     */\n    public String getMd5(String filePath) throws Exception &#123;\n        File file;\n        String md5 = \"\";\n        try &#123;\n            file = ResourceUtils.getFile(filePath);\n            if (file.exists()) &#123;\n                FileInputStream is = new FileInputStream(file);\n                byte[] data = new byte[is.available()];\n                is.read(data);\n                md5 = DigestUtils.md5DigestAsHex(data);\n                is.close();\n            &#125;\n        &#125; catch (FileNotFoundException e) &#123;\n\n        &#125;\n        return md5;\n    &#125;\n\n    /**\n     * &lt;p>日志打印授权提醒&lt;/p>\n     */\n    private void HandlerLicenseRemider() &#123;\n        try &#123;\n            log.warn(\"无有效授权证书，请联系管理员申请！申请参数[&#123;&#125;]\",\n                    Base64.encode(JSON.toJSONString(AServerInfos.getServer(\"\").getServerInfos()).getBytes(StandardCharsets.UTF_8)));\n        &#125; catch (LicenseContentException e) &#123;\n            log.error(\"读取服务器硬件信息异常:\"+e.getMessage());\n        &#125; finally &#123;\n            ConfigurableApplicationContext ctx = (ConfigurableApplicationContext) applicationContext;\n            ctx.close();\n            ctx.stop();\n        &#125;\n    &#125;\n\n&#125;\n\n\n4、license-boot-startboot-start模块非必须，仅为了模块调试及方便授权文件生成使用，代码结构非常简单：\n启动类\nLicenseApplication\n/**\n * @program: groot-license\n * @description: 启动类\n * @author: Anchor\n * @create: 2021-09-01\n **/\n@SpringBootApplication(exclude= &#123;DataSourceAutoConfiguration.class&#125;)\npublic class LicenseApplication extends SpringBootServletInitializer &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(LicenseApplication.class, args);\n    &#125;\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;\n        return application.sources(LicenseApplication.class);\n    &#125;\n&#125;\n\n\n配置文件\nApplication.yml\nserver:\n  # 服务器的HTTP端口，默认为8080\n  port: 8080\ngroot:\n  license:\n    verify:\n      prefix: http:&#x2F;&#x2F;localhost:8080&#x2F;license&#x2F;\n      licensePath: &#x2F;Users&#x2F;anchor&#x2F;Tools&#x2F;alihai5&#x2F;license.lic\n\n\n使用效果\nHTTP请求示例\nPOST /license/generate HTTP/1.1\nContent-Type: application/json; charset=utf-8\nHost: 127.0.0.1:8080\nConnection: close\nUser-Agent: RapidAPI/4.1.0 (Macintosh; OS X/13.0.1) GCDHTTPRequest\nContent-Length: 550\n\n&#123;\"subject\":\"groot\",\"privateAlias\":\"privatekeys\",\"keyPass\":\"groot7758\",\"storePass\":\"groot7758\",\"privateKeysStorePath\":\"/privateKeys.store\",\"issuedTime\":\"2022-12-01 00:00:00\",\"expiryTime\":\"2025-12-31 00:00:00\",\"description\":\"\\u7cfb\\u7edf\\u8f6f\\u4ef6\\u8bb8\\u53ef\\u8bc1\\u4e66\",\"licenseCheck\":&#123;\"ipAddress\":[\"192.168.1.111\"],\"macAddress\":[\"B0-DE-28-10-CA-92\"],\"cpuSerial\":\"L6PHQYPWGW\",\"mainBoardSerial\":\"D1F0CA19-227C-5B4C-8149-3DE736423365\",\"registerAmount\":1000,\"macCheck\":false,\"boardCheck\":false,\"cpuCheck\":false,\"ipCheck\":false,\"registerCheck\":false&#125;&#125;\n\n\n\nResponse接口返回示例\n&#123;\n  \"msg\": \"证书生成成功，证书有效期：2022-12-01 00:00:00 - 2025-12-31 00:00:00\",\n  \"code\": 200,\n  \"data\": &#123;\n    \"subject\": \"groot\",\n    \"privateAlias\": \"privatekeys\",\n    \"keyPass\": \"groot7758\",\n    \"privateKeysStorePath\": \"/privateKeys.store\",\n    \"storePass\": \"groot7758\",\n    \"licensePath\": \"/Users/anchor/Workspase/Alihai5/groot/license/20221226162407/license.lic\",\n    \"issuedTime\": \"2022-12-01 00:00:00\",\n    \"expiryTime\": \"2025-12-31 00:00:00\",\n    \"consumerType\": \"user\",\n    \"consumerAmount\": 1,\n    \"description\": \"系统软件许可证书\",\n    \"licenseCheck\": &#123;\n      \"ipAddress\": [\n        \"192.168.1.111\"\n      ],\n      \"macAddress\": [\n        \"B0-DE-28-10-CA-92\"\n      ],\n      \"cpuSerial\": \"L6PHQYPWGW\",\n      \"mainBoardSerial\": \"D1F0CA19-227C-5B4C-8149-3DE736423365\",\n      \"registerAmount\": 1000,\n      \"ipCheck\": false,\n      \"macCheck\": false,\n      \"cpuCheck\": false,\n      \"boardCheck\": false,\n      \"registerCheck\": false\n    &#125;,\n    \"licUrl\": \"http://localhost:8080/license/download?path=/Users/anchor/Workspase/Alihai5/groot/license/20221226162407/license.lic\"\n  &#125;\n&#125;\n\n\n5、实现效果有授权启动\n授权启动日志\n2022-12-31 14:51:21 INFO  [restartedMain] org.apache.coyote.http11.Http11NioProtocol Starting ProtocolHandler [\"http-nio-8080\"]\n2022-12-31 14:51:22 INFO  [restartedMain] c.a.license.verify.listener.LicenseVerifyListener ++++++++ 开始安装授权证书 ++++++++\n2022-12-31 14:51:22 INFO  [restartedMain] c.alihai5.license.core.model.LicenseVerifyManager 证书安装成功，证书有效期：2022-12-01 00:00:00 - 2025-12-31 00:00:00\n2022-12-31 14:51:22 INFO  [restartedMain] c.a.license.verify.listener.LicenseVerifyListener ++++++++ 授权证书安装成功 ++++++++\n2022-12-31 14:51:22 INFO  [restartedMain] com.alihai5.GrootApplication Started GrootApplication in 10.422 seconds (JVM running for 11.916)\n\n\n无授权启动\n无授权启动日志\n2022-12-31 14:52:56 INFO  [restartedMain] org.apache.coyote.http11.Http11NioProtocol Starting ProtocolHandler [\"http-nio-8080\"]\n2022-12-31 14:52:56 WARN  [restartedMain] c.a.license.verify.listener.LicenseVerifyListener 无有效授权证书，请联系管理员申请！申请参数[eyJib2FyZENoZWNrIjpmYWxzZSwiY3B1Q2hlY2siOmZhbHNlLCJjcHVTZXJpYWwiOiJMNlBIUVlQV0dXIiwiaXBBZGRyZXNzIjpbIjE5Mi4xNjguMC4xNSJdLCJpcENoZWNrIjpmYWxzZSwibWFjQWRkcmVzcyI6WyJCMC1ERS0yOC0xMC1DQS05MiJdLCJtYWNDaGVjayI6ZmFsc2UsIm1haW5Cb2FyZFNlcmlhbCI6IkQxRjBDQTE5LTIyN0MtNUI0Qy04MTQ5LTNERTczNjQyMzM2NSIsInJlZ2lzdGVyQ2hlY2siOmZhbHNlfQ==]\n2022-12-31 14:52:56 INFO  [restartedMain] org.apache.coyote.http11.Http11NioProtocol Pausing ProtocolHandler [\"http-nio-8080\"]\n2022-12-31 14:52:56 INFO  [restartedMain] org.apache.catalina.core.StandardService Stopping service [Tomcat]\n2022-12-31 14:52:56 WARN  [restartedMain] org.apache.catalina.loader.WebappClassLoaderBase The web application [ROOT] appears to have started a thread named [lettuce-timer-3-1] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:\n java.lang.Thread.sleep(Native Method)\n io.netty.util.HashedWheelTimer$Worker.waitForNextTick(HashedWheelTimer.java:600)\n io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:496)\n io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n java.lang.Thread.run(Thread.java:748)\n2022-12-31 14:52:56 INFO  [restartedMain] org.apache.coyote.http11.Http11NioProtocol Stopping ProtocolHandler [\"http-nio-8080\"]\n2022-12-31 14:52:56 INFO  [restartedMain] org.apache.coyote.http11.Http11NioProtocol Destroying ProtocolHandler [\"http-nio-8080\"]\n2022-12-31 14:52:56 ERROR [restartedMain] org.springframework.boot.SpringApplication Application run failed\n\n\n五、总结有授权就一定有破解，没有绝对的防御，为防止被简单替换jar包被破解，可以尝试调整Maven引用层级，如将框架核心模块放入授权认证下，使之无法跳过验证逻辑，同时引入Allatori混淆代码等等措施，增加破解难度。\n","slug":"Java/SpringBoot集成TrueLicense实现授权管理","date":"2022-12-31T06:03:15.000Z","categories_index":"JAVA","tags_index":"JAVA,TrueLicense,SpringBoot,License","author_index":"Anchor"},{"id":"00e30bbeb7ce30522f4b80e6bd22ac09","title":"MySQL 数据库开发的三十六条军规","content":"MySQL 数据库开发的三十六条军规一、核心军规(5)1.1 尽量不在数据库做运算\n别让脚趾头想事情，那是脑瓜子的职责\n\n让数据库多做她擅长的事:\n\n尽量不在数据库做运算\n复杂运算秱到程序端 CPU\n尽可能简单应用 MySQL\n\n\n举例: md5() &#x2F; Order by Rand()\n\n\n1.2 控制单表数据量\n一年内的单表数据量预估\n\n纯 INT 不超 1000W\n含 CHAR 不超 500W\n\n\n合理分表不超载\n\nUSERID\nDATE\nAREA\n……\n\n\n建议单库不超过 300-400 个表\n\n\n1.3 保持表身段苗条\n表字段数少而精\n\nIO 高效\n全表遍历\n表修复快\n提高幵发\nalter table 快\n\n\n单表多少字段合适?\n\n单表 1G 体积 500W 行评估\n\n顺序读 1G 文件需 N 秒\n单行不超过 200Byte\n单表不超过 50 个纯 INT 字段\n单表不超过 20 个 CHAR(10)字段\n\n\n单表字段数上限控制在 20~50 个\n\n\n1.4 平衡范式不冗余\n严格遵循三大范式?\n效率优先、提升性能\n没有绝对的对不错\n适当时牺牲范式、加入冗余\n但会增加代码复杂度\n\n1.5 拒绝 3B\n数据库幵发像城市交通\n\n非线性增长\n\n\n拒绝 3B\n\n大 SQL (BIG SQL)\n大事务 (BIG Transaction)\n大批量 (BIG Batch)\n\n\n详细解析见后\n\n\n1.6 核心军规小结\n尽量不在数据库做运算\n控制单表数据量\n保持表身段苗条\n平衡范式不冗余\n拒绝 3B\n\n二、字段类军规(6)2.1 用好数值字段类型\n三类数值类型:\n\nTINYINT(1Byte)\nSMALLINT(2B)\nMEDIUMINT(3B)\nINT(4B)、BIGINT(8B)\nFLOAT(4B)、DOUBLE(8B)\nDECIMAL(M,D)\n\n\nBAD CASE:\n\nINT(1) VS INT(11)\nBIGINT AUTO_INCREMENT\nDECIMAL(18,0)\n\n\n\n2.2 将字符转化为数字\n数字型 VS 字符串型索引\n\n更高效\n查询更快\n占用空间更小\n\n\n举例:用无符号 INT 存储 IP，而非 CHAR(15)\n\nINT UNSIGNED\nINET_ATON()\nINET_NTOA()\n\n\n\n2.3 优先使用 ENUM 或 SET\n优先使用 ENUM 或 SET\n\n字符串\n可能值已知且有限\n\n\n存储\n\nENUM 占用 1 字节，转为数值运算\nSET 视节点定，最多占用 8 字节\n比较时需要加’ 单引号(即使是数值)\n\n\n举例\n\nsex enum(‘F’,’M’) COMMENT ‘性别’\nc1 enum(‘0’,’1’,’2’,’3’) COMMENT ‘职介审核’\n\n\n\n2.4 避免使用 NULL 字段\n避免使用 NULL 字段\n\n很难进行查询优化\nNULL 列加索引，需要额外空间\n含 NULL 复合索引无效\n\n\n举例\n\na char(32) DEFAULT NULL\nb int(10) NOT NULL\nc int(10) NOT NULL DEFAULT 0\n\n\n\n2.5 少用并拆分 TEXT&#x2F;BLOB\nTEXT 类型处理性能远低亍 VARCHAR\n\n强制生成硬盘临时表\n浪费更多空间\nVARCHAR(65535)&#x3D;&#x3D;&gt;64K (注意 UTF-8)\n\n\n尽量不用 TEXT&#x2F;BLOB 数据类型\n\n若必须使用则拆分到单独的表\n\n举例:\n\n\nCREATE TABLE t1 (\nid INT NOT NULL AUTO_INCREMENT, data text NOT NULL,\n‏PRIMARY KEY id\n) ENGINE=InnoDB;\n\n2.6 不在数据库里存图片2.7 字段类军规小结\n用好数值字段类型\n将字符转化为数字\n优先使用枚举 ENUM&#x2F;SET\n避免使用 NULL 字段\n少用幵拆分 TEXT&#x2F;BLOB\n不在数据库里存图片\n\n三、索引类军规(5)3.1 谨慎合理添加索引\n谨慎合理添加索引\n\n改善查询\n减慢更新\n索引不是赹多赹好\n\n\n能不加的索引尽量不加\n\n综合评估数据密度和数据分布\n最好不赸过字段数 20%\n\n\n结合核心 SQL 优先考虑覆盖索引\n\n举例\n\n不要给“性别”列创建索引\n\n\n\n3.2 字符字段必须建前缀索引\n区分度\n\n单字母区分度:26\n4 字母区分度:26_26_26*26&#x3D;456,976\n5 字母区分度:26_26_26_26_26&#x3D;11,881,376\n6 字母区分度:26_26_26_26_26*26&#x3D;308,915,776\n\n\n字符字段必须建前缀索引:\n\n\n(\n`pinyin` varchar(100) DEFAULT NULL COMMENT '小区拼音', KEY `idx_pinyin` (`pinyin`(8)),\n) ENGINE=InnoDB\n\n3.3 不在索引列做运算\n不在索引列进行数学运算或凼数运算\n\n无法使用索引\n导致全表扫描\n\n\n举例:\n\n\nBAD: SELECT * from table WHERE to_days(current_date) – to_days(date_col) &lt;= 10\nGOOD: SELECT * from table WHERE date_col >= DATE_SUB('2011-10- 22',INTERVAL 10 DAY);\n\n3.4 自增列或全局 ID 做 INNODB 主键\n对主键建立聚簇索引\n二级索引存储主键值\n主键不应更新修改\n按自增顺序揑入值\n忌用字符串做主键\n聚簇索引分裂\n推荐用独立亍业务的 AUTO_INCREMENT 列或全局 ID 生成 器做代理主键\n若不指定主键，InnoDB 会用唯一且非空值索引代替\n\n3.5 尽量不用外键\n线上 OLTP 系统(线下系统另论)\n\n外键可节省开发量\n有额外开销\n逐行操作\n可’到达’其它表，意味着锁\n高并发时容易死锁\n\n\n由程序保证约束\n\n\n3.6 索引类军规小结\n谨慎合理添加索引\n字符字段必须建前缀索引\n不在索引列做运算\n自增列或全局 ID 做 INNODB 主键\n尽量不用外键\n\n四、SQL 类军规(15)4.1 SQL 语句尽可能简单\n大 SQL VS 多个简单 SQL\n\n传统设计思想\nBUT MySQL NOT\n一条 SQL 叧能在一个 CPU 运算\n5000+ QPS 的高幵发中，1 秒大 SQL 意味着?\n可能一条大 SQL 就把整个数据库堵死\n\n\n拒绝大 SQL，拆解成多条简单 SQL\n\n简单 SQL 缓存命中率更高\n减少锁表时间，特别是 MyISAM\n用上多 CPU\n\n\n\n4.2 保持事务(连接)短小\n保持事务&#x2F;DB 连接短小精悍\n\n事务&#x2F;连接使用原则:即开即用，用完即关\n与事务无关操作放到事务外面, 减少锁资源的占用\n不破坏一致性前提下，使用多个短事务代替长事务\n\n\n举例\n\n发贴时的图片上传等待\n大量的 sleep 连接\n\n\n\n4.3 尽可能避免使用 SP&#x2F;TRIG&#x2F;FUNC\n线上 OLTP 系统(线下库另论)\n\n尽可能少用存储过程\n尽可能少用触发器\n减用使用 MySQL 凼数对结果进行处理\n\n\n由客户端程序负责\n\n\n4.4 尽量不用 SELECT\n用 SELECT * 时\n更多消耗 CPU、内存、IO、网络带宽\n先向数据库请求所有列，然后丢掉不需要列?\n尽量不用 SELECT * ，叧取需要数据列 • 更安全的设计:减少表变化带来的影响\n为使用 covering index 提供可能性\nSELECT&#x2F;JOIN 减少硬盘临时表生成，特别是有 TEXT&#x2F;BLOB 时\n举例:\n\nSELECT * FROM tag WHERE id = 999184;\nSELECT keyword FROM tag WHERE id = 999184;\n\n4.5 改写 OR 为 IN()\n同一字段，将 or 改写为 in()\nOR 效率:O(n)\nIN 效率:O(Log n)\n当 n 很大时，OR 会慢很多\n注意控制 IN 的个数，建议 n 小亍 200\n举例:\n\nSELECT * from opp WHERE phone='12347856' or phone='42242233' \\G;\nSELECT * from opp WHERE phone in ('12347856' , '42242233');\n\n4.6 改写 OR 为 UNION\n不同字段，将 or 改为 union\n减少对不同字段进行 “or” 查询\nMerge index 往往很弱智\n如果有足够信心:set global optimizer_switch&#x3D;’index_merge&#x3D;off’;\n举例:\n\nSELECT * from opp WHERE phone='010-88886666' or cellPhone='13800138000';\nSELECT * from opp WHERE phone='010-88886666' union SELECT * from opp WHERE cellPhone='13800138000';\n\n4.7 避免负向查询和% 前缀模糊查询\n避免负向查询\n\nNOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、 NOT LIKE 等\n\n\n避免 % 前缀模糊查询\n\nB+ Tree\n使用不了索引\n导致全表扫描\n\n\n举例:\n\n\nSELECT * from post WHERE title like '北京%'; -- 298 rows in set (0.01 sec)\nSELECT * from post WHERE title like '%北京%'; -- 572 rows in set (3.27 sec)\n\n4.8 COUNT(*)的几个例子\n几个有趣的例子:\n\nCOUNT(COL) VS COUNT(*)\nCOUNT(*) VS COUNT(1)\nCOUNT(1) VS COUNT(0) VS COUNT(100)\n\n\n示例:\n\n\n`id` int(10) NOT NULL AUTO_INCREMENT COMMENT '公司的id', `sale_id` int(10) unsigned DEFAULT NULL,\n\n\n结论\n\nCOUNT(*)&#x3D;count(1)\n\n\n\n*COUNT(0)&#x3D;count(1)\n\nCOUNT(1)&#x3D;count(100)\nCOUNT(*)!&#x3D;count(col)\nWHY?\n\n4.9 减少 COUNT(*)\nMyISAM VS INNODB\n\n不带 WHERE COUNT()\n带 WHERE COUNT()\n\n\nCOUNT(*)的资源开销大，尽量不用少用\n\n计数统计\n\n实时统计:用 memcache，双向更新，凌晨 跑基准\n非实时统计:尽量用单独统计表，定期重算\n\n\n\n4.10 LIMIT 高效分页\n传统分页:\n\nSELECT * from table limit 10000,10;\n\n\nLIMIT 原理:\n\nLimit 10000,10  偏秱量赹大则赹慢\n\n\n推荐分页:\n\nSELECT * from table WHERE id&gt;&#x3D;23423 limit 11;\n\n\n\n_SELECT _ from table WHERE id&gt;&#x3D;23434 limit 11;\n\n分页方式二:\n\nSELECT * from table WHERE id &gt;&#x3D; ( SELECT id from table limit 10000,1 ) limit 10;\n\n\n分页方式三:\n\nSELECT * FROM table INNER JOIN (SELECT id FROM table LIMIT 10000,10) USING (id);\n\n\n分页方式四:\n\n程序取 ID:SELECT id from table limit 10000,10;\nSELECT * from table WHERE id in (123,456…);\n\n\n可能需按场景分析幵重组索引\n\n示例:\n\n\nMySQL> SELECT sql_no_cache * from post limit 10,10; 10 row in set (0.01 sec)\nMySQL> SELECT sql_no_cache * from post limit 20000,10; 10 row in set (0.13 sec)\nMySQL> SELECT sql_no_cache * from post limit 80000,10; 10 rows in set (0.58 sec)\nMySQL> SELECT sql_no_cache id from post limit 80000,10; 10 rows in set (0.02 sec)\nMySQL> SELECT sql_no_cache * from post WHERE id>=323423 limit 10; 10 rows in set (0.01 sec)\nMySQL> SELECT * from post WHERE id >= ( SELECT sql_no_cache id from post limit 80000,1 ) limit 10; 10 rows in set (0.02 sec)\n\n4.11 用 UNION ALL 而非 UNION\n若无需对结果进行去重，则用 UNION ALL\n\nUNION 有去重开销\n\n\n举例:\n\n\nSELECT * FROM detail20091128 UNION ALL SELECT * FROM detail20110427 UNION ALL SELECT * FROM detail20110426 UNION ALL SELECT * FROM detail20110425 UNION ALL SELECT * FROM detail20110424 UNION ALL SELECT * FROM detail20110423;\n\n4.12 分解联接保证高并发\n高幵发 DB 不建议进行两个表以上的 JOIN\n\n适当分解联接保证高幵发\n\n可缓存大量早期数据\n使用了多个 MyISAM 表\n对大表的小 ID IN()\n联接引用同一个表多次\n举例:\n\n\n\nMySQL> SELECT * from tag JOIN post on tag_post.post_id=post.id WHERE tag.tag='二手玩具';\n\nMySQL> SELECT * from tag WHERE tag='二手玩具';\nMySQL> SELECT * from tag_post WHERE tag_id=1321;\nMySQL> SELECT * from post WHERE post.id in (123,456,314,141);\n\n4.13 GROUP BY 去除排序\nGROUP BY 实现\n\n分组\n自劢排序\n\n\n无需排序:Order by NULL\n\n特定排序:Group by DESC&#x2F;ASC\n\n举例:\n\n\nMySQL> SELECT phone,count(*) from post group by phone limit 1 ; 1 row in set (2.19 sec)\nMySQL> SELECT phone,count(*) from post group by phone order by null limit 1; 1 row in set (2.02 sec)\n\n4.14 同数据类型的列值比较\n原则:数字对数字，字符对字符\n\n数值列不字符类型比较\n\n同时转换为双精度\n进行比对\n\n\n字符列不数值类型比较\n\n字符列整列转数值\n不会使用索引查询\n\n\n举例:字符列不数值类型比较\n\n\n字段:`remark` varchar(50) NOT NULL COMMENT '备注, 默认为空',\n\nMySQL>SELECT `id`, `gift_code` FROM gift WHERE `deal_id` = 640 AND remark=115127; 1 row in set (0.14 sec)\nMySQL>SELECT `id`, `gift_code` FROM pool_gift WHERE `deal_id` = 640 AND remark='115127'; 1 row in set (0.005 sec)\n\n4.15 Load data 导数据\n批量数据快导入:\n\n成批装载比单行装载更快，不需要每次刷新缓存\n无索引时装载比索引装载更快\nInsert values ,values，values 减少索引刷新\nLoad data 比 insert 快约 20 倍\n\n\n尽量不用 INSERT … SELECT\n\n延迟\n同步出错\n\n\n\n4.16 打散大批量更新\n大批量更新凌晨操作，避开高峰\n凌晨不限制\n白天上限默认为 100 条&#x2F;秒(特殊再议)\n举例:\n\nupdate post set tag=1 WHERE id in (1,2,3); sleep 0.01;\nupdate post set tag=1 WHERE id in (4,5,6); sleep 0.01;\n......\n\n4.17 Know Every SQL\nSHOW PROFILE\nMySQLdumpslow\nEXPLAIN\nShow Slow Log\nSHOW QUERY_RESPONSE_TIME(Percona)\nMySQLsla\nShow Processlist\n\n4.18 SQL 类军规小结\nSQL 语句尽可能简单\n保持事务(连接)短小\n尽可能避免使用 SP&#x2F;TRIG&#x2F;FUNC\n尽量不用 SELECT *\n改写 OR 语句\n避免负向查询和% 前缀模糊查询\n减少 COUNT(*)\nLIMIT 的高效分页\n用 UNION ALL 而非 UNION\n分解联接保证高幵发\nGROUP BY 去除排序\n同数据类型的列值比较\nLoad data 导数据\n打散大批量更新\nKnow Every SQL!\n\n五、约定类军规(5)5.1 隔离线上线下\n构建数据库的生态环境\n\n开发无线上库操作权限\n\n原则:线上连线上，线下连线下\n\n实时数据用 real 库\n模拟环境用 sim 库\n测试用 qa 库\n开发用 dev 库\n\n\n\n5.2 禁止未经 DBA 确认的子查询\nMySQL 子查询\n\n大部分情况优化较差\n特别 WHERE 中使用 IN id 的子查询  一般可用 JOIN 改写\n\n\n举例:\n\n\nSELECT * from table1 where id id from table2) in (SELECT insert into table1 (SELECT * from table2); -- 可能导致复制异常\n\n5.3 永远不在程序端显式加锁\n永远不在程序端对数据库显式加锁\n\n外部锁对数据库不可控\n高并发发时是灾难\n极难调试和排查\n\n\n并发扣款等一致性问题\n\n采用事务\n相对值修改\nCommit 前二次较验冲突\n\n\n\n5.4 统一字符集为 UTF8\n字符集:\n\nMySQL 4.1 以前叧有 latin1\n为多语言支持增加多字符集\n也带来了 N 多问题\n保持简单\n\n\n统一字符集:UTF8\n\n校对规则:utf8_general_ci\n\n乱码:SET NAMES UTF8\n\n\n5.5 统一命名规范\n库表等名称统一用小写\n\nLinux VS Windows\nMySQL 库表大小写敏感\n字段名的大小写不敏感\n\n\n索引命名默认为“idx_字段名”\n\n库名用缩写，尽量在 2~7 个字母\n\nDataSharing &#x3D;&#x3D;&gt; ds\n\n\n注意避免用保留字命名\n\n……\n\n\n5.6 注意避免用保留字命名\n举例:\n\nSELECT * from return;\nSELECT * from `return`;\n\nMySQL系统关键字\n\nADD\nALL\nALTER GOTO\nGRANT\nGROUP\nPURGE\nRAID0\nRANGE\nANALYZE\nAND\nAS HAVING\nHIGH_PRIORIT Y\nHOUR_MICROSEC OND\nREAD\nREADS\nREAL\nASC\nASENSITIVE\nBEFORE HOUR_MINUTE\nHOUR_SECON D\nIF\nREFERENCES\nREGEXP\nRELEASE\nBETWEEN\nBIGINT\nBINARY IGNORE\nIN\nINDEX\nRENAME\nREPEAT\nREPLACE\nBLOB\nBOTH\nBY INFILE\nINNER\nINOUT\nREQUIRE\nRESTRICT\nRETURN\nCALL\nCASCADE\nCASE INSENSITIVE\nINSERT\nINT\nREVOKE\nRIGHT\nRLIKE\nCHANGE\nCHAR\nCHARACTER INT1\nINT2\nINT3\nSCHEMA\nSCHEMAS\nSECOND_MICROSEC OND\nCHECK\nCOLLATE\nCOLUMN INT4\nINT8\nINTEGER\nSELECT\nSENSITIVE\nSEPARATOR\nCONDITION\nCONNECTION\nCONSTRAINT INTERVAL\nINTO\nIS\nSET\nSHOW\nSMALLINT\nCONTINUE\nCONVERT\nCREATE ITERATE\nJOIN\nKEY\nSPATIAL\nSPECIFIC\nSQL\nCROSS\nCURRENT_DA TE\nCURRENT_TIM KEYS E\nKILL\nLABEL\nSQLEXCEPTION\nSQLSTATE\nSQLWARNING\nCURRENT_TIMESTA MP\nCURRENT_US ER\nCURSOR LEADING\nLEAVE\nLEFT\nSQL_BIG_RESUL T\nSQL_CALC_FOUND_R OWS\nSQL_SMALL_RESULT\nDATABASE\nDATABASES\nDAY_HOUR LIKE\nLIMIT\nLINEAR\nSSL\nSTARTING\nSTRAIGHT_JOIN\nDAY_MICROSECON D\nDAY_MINUTE\nDAY_SECOND LINES\nLOAD\nLOCALTIME\nTABLE\nTERMINATED\nTHEN\nDEC\nDECIMAL\nDECLARE LOCALTIMESTAMP\nLOCK\nLONG\nTINYBLOB\nTINYINT\nTINYTEXT\nDEFAULT\nDELAYED\nDELETE LONGBLOB\nLONGTEXT\nLOOP\nTO\nTRAILING\nTRIGGER\nDESC\nDESCRIBE\nDETERMINISTI LOW_PRIORITY C\nMATCH\nMEDIUMBLOB\nTRUE\nUNDO\nUNION\nDISTINCT\nDISTINCTROW\nDIV MEDIUMINT\nMEDIUMTEXT\nMIDDLEINT\nUNIQUE\nUNLOCK\nUNSIGNED\nDOUBLE\nDROP\nDUAL\nMINUTE_MICROSECO ND\nMINUTE_SECO ND\nMOD\nUPDATE\nUSAGE\nUSE\nEACH\nELSE\nELSEIF MODIFIES\nNATURAL\nNOT\nUSING\nUTC_DATE\nUTC_TIME\nENCLOSED\nESCAPED\nEXISTS\nNO_WRITE_TO_BINL OG\nNULL\nNUMERIC\nUTC_TIMESTAM P\nVALUES\nVARBINARY\nEXIT\nEXPLAIN\nFALSE ON\nOPTIMIZE\nOPTION\nVARCHAR\nVARCHARACTER\nVARYING\nFETCH\nFLOAT\nFLOAT4 OPTIONALLY\nOR\nORDER\nWHEN\nWHERE\nWHILE\nFLOAT8\nFOR\nFORCE OUT\nOUTER\nOUTFILE\nWITH\nWRITE\nX509\nFOREIGN\nFROM\nFULLTEXT PRECISION\nPRIMARY\nPROCEDURE\nXOR\nYEAR_MONTH\nZEROFILL\n\n5.7 约定类军规小结\n隔离线上线下\n禁止未经 DBA 确认的子查询上线\n永远不在程序端显式加锁\n统一字符集为 UTF8\n统一命名规范\n\n六、原文链接\nhttp://weibo.com/wushizhan\n\n","slug":"MySQL/MySQL数据库开发的三十六条军规","date":"2022-02-26T03:37:18.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"1a07a30e4d12a51de2d9119320d5847f","title":"MySQL 主键设计盘点","content":"主键定义唯一标识表中每行的一个列（或一组列）称为主键。主键用来表示一个特定的行。\n主键设计和应用原则除了满足MySQL强制实施的规则（主键不可重复；一行中主键不可为空）之外，主键的设计和应用应当还遵守以下公认的原则：\n\n不更新主键列中的值；\n不重用主键列的值；\n不在主键列中使用可能会更改的值。（例如，如果使用一个 名字作为主键以标识某个供应商，当该供应商合并和更改其 名字时，必须更改这个主键。）\n\n主键生成策略自增ID使用数据库的自动增长（auto_increment），是比较简单和常见的ID生成方案，数据库内部可以确保生成id的唯一性。优点：1、数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利。2、 数字型，占用空间小，易排序，在程序中传递方便。缺点：1、不支持水平分片架构，水平分片的设计当中，这种方法显然不能保证全局唯一。2、对数据库有依赖，每种数据库可能实现不一样，数据库切换时候，涉及到代码的修改，不利于扩展结论：自增id做主键适用于非分布式架构。\nUUID| **UUID:通用唯一识别码（英语：Universally Unique Identifier，缩写：UUID）是用于计算机体系中以识别信息数目的一个128位标识符，还有相关的术语：全局唯一标识符（GUID）。 根据标准方法生成，不依赖中央机构的注册和分配，UUID具有唯一性，这与其他大多数编号方案不同。重复UUID码概率接近零，可以忽略不计。UUID是由一组32位数的16进制数字所构成,标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例：550e8400-e29b-41d4-a716-446655440000\n\n\n\n到目前为止业界一共有5种方式生成UUID，详情可见IETF发布的UUID规范**A Universally Unique IDentifier (UUID) URN Namespace\n\n\n\n优点：性能非常高：本地生成，没有网络消耗。缺点：1、不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。2、信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。3、ID作为主键时在特定的环境会存在一些问题，比如需要排序的时候——UUID是无序的。4、MySQL官方有明确的建议主键要尽量越短越好，36个字符长度的UUID不符合要求。5、对MySQL索引不利：作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。关于MySQL 使用自增ID主键和UUID 作为主键的性能比较可以查看参考【8】。结论：1、uuid做主键适用于小规模分布式架构用。2、在使用uuid作为主键的时候，最好设计createtime（创建时间）列和modifytime（修改时间）列以应付可能的排序等场景。\n自建的id生成器Twitter的snowflake算法Twitter的snowflake算法的核心把时间戳，工作机器id，序列号组合在一起。除了最高位bit标记为不可用以外，其余三组bit占位均可浮动，看具体的业务需求而定。默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。\n具体可以查看：github.com&#x2F;twitter-arc…** （但是最近一次的提交是6年前，显示已经停止了对初始版snowflake的支持）**源码如下：\npackage com.yjd.comm.util;/**\n* Created by pc on 2017/8/16 0016.\n*/\n\n/**\n* Twitter_Snowflake&lt;br>\n* SnowFlake的结构如下(每部分用-分开):&lt;br>\n* 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br>\n* 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br>\n* 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)\n* 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br>\n* 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br>\n* 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br>\n* 加起来刚好64位，为一个Long型。&lt;br>\n* SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。\n*/\npublic class SnowflakeIdWorker &#123;\n    \n    // ==============================Fields===========================================\n    /**\n    * 开始时间截 (2015-01-01)\n    */\n    private final long twepoch = 1420041600000L;\n    \n    /**\n    * 机器id所占的位数\n    */\n    private final long workerIdBits = 5L;\n    \n    /**\n    * 数据标识id所占的位数\n    */\n    private final long datacenterIdBits = 5L;\n    \n    /**\n    * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)\n    */\n    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);\n    \n    /**\n    * 支持的最大数据标识id，结果是31\n    */\n    private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);\n    \n    /**\n    * 序列在id中占的位数\n    */\n    private final long sequenceBits = 12L;\n    \n    /**\n    * 机器ID向左移12位\n    */\n    private final long workerIdShift = sequenceBits;\n    \n    /**\n    * 数据标识id向左移17位(12+5)\n    */\n    private final long datacenterIdShift = sequenceBits + workerIdBits;\n    \n    /**\n    * 时间截向左移22位(5+5+12)\n    */\n    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n    \n    /**\n    * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)\n    */\n    private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);\n    \n    /**\n    * 工作机器ID(0~31)\n    */\n    private long workerId;\n    \n    /**\n    * 数据中心ID(0~31)\n    */\n    private long datacenterId;\n    \n    /**\n    * 毫秒内序列(0~4095)\n    */\n    private long sequence = 0L;\n    \n    /**\n    * 上次生成ID的时间截\n    */\n    private long lastTimestamp = -1L;\n    \n    //==============================Constructors=====================================\n    \n    /**\n    * 构造函数\n    *\n    * @param workerId     工作ID (0~31)\n    * @param datacenterId 数据中心ID (0~31)\n    */\n    public SnowflakeIdWorker(long workerId, long datacenterId) &#123;\n        if (workerId > maxWorkerId || workerId &lt; 0) &#123;\n            throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n        &#125;\n        if (datacenterId > maxDatacenterId || datacenterId &lt; 0) &#123;\n            throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", maxDatacenterId));\n        &#125;\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n    &#125;\n    \n    // ==============================Methods==========================================\n    \n    /**\n    * 获得下一个ID (该方法是线程安全的)\n    *\n    * @return SnowflakeId\n    */\n    public synchronized long nextId() &#123;\n        long timestamp = timeGen();\n        \n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常\n        if (timestamp &lt; lastTimestamp) &#123;\n            throw new RuntimeException(\n                String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n        &#125;\n        \n        //如果是同一时间生成的，则进行毫秒内序列\n        if (lastTimestamp == timestamp) &#123;\n            sequence = (sequence + 1) &amp; sequenceMask;\n            //毫秒内序列溢出\n            if (sequence == 0) &#123;\n                //阻塞到下一个毫秒,获得新的时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            &#125;\n        &#125;\n        //时间戳改变，毫秒内序列重置\n        else &#123;\n            sequence = 0L;\n        &#125;\n        \n        //上次生成ID的时间截\n        lastTimestamp = timestamp;\n        \n        //移位并通过或运算拼到一起组成64位的ID\n        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) //\n            | (datacenterId &lt;&lt; datacenterIdShift) //\n            | (workerId &lt;&lt; workerIdShift) //\n            | sequence;\n    &#125;\n    \n    /**\n    * 阻塞到下一个毫秒，直到获得新的时间戳\n    *\n    * @param lastTimestamp 上次生成ID的时间截\n    * @return 当前时间戳\n    */\n    protected long tilNextMillis(long lastTimestamp) &#123;\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) &#123;\n            timestamp = timeGen();\n        &#125;\n        return timestamp;\n    &#125;\n    \n    /**\n    * 返回以毫秒为单位的当前时间\n    *\n    * @return 当前时间(毫秒)\n    */\n    protected long timeGen() &#123;\n        return System.currentTimeMillis();\n    &#125;\n    \n    //==============================Test=============================================\n    \n    /**\n    * 测试\n    */\n    public static void main(String[] args) &#123;\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(1, 1);\n        long startime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 4000000; i++) &#123;\n            long id = idWorker.nextId();\n            //            System.out.println(Long.toBinaryString(id));\n            //            System.out.println(id);\n        &#125;\n        System.out.println(System.currentTimeMillis() - startime);\n    &#125;\n&#125;\n\n\n优点：1、毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。 2、 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。 3、可以根据自身业务特性分配bit位，非常灵活。缺点：强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。结论：用自建的id生成器做主键适用于大规模分布式架构\n","slug":"MySQL/MySQL主键设计盘点","date":"2022-02-23T05:32:16.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"6dd356025f124f190d32c47865445ac7","title":"MySQL 常用函数&数据类型","content":"MySQL 常用函数汇总字符串函数\n\n\n函数\n功能\n\n\n\nCONCAT(s1,s2,……)\n字符串连接\n\n\nINSERT(str,x,y,instr)\n将指定开始标记到结束的字符串替换为指定字符串\n\n\nLOWER(str)\n将字符串所有字符转为小写\n\n\nUPPER(str)\n将字符串所有字符串转为大写\n\n\nLEFT(str,x)\n返回字符串 str 最左边的 x 个字符\n\n\nRIGHT(str,x)\n返回字符串 str 最右边的 x 个字符\n\n\nLPAD(str,n,pad)\n在 str 最左边填充 n 个 pad\n\n\nRPAD(str,n,pad)\n在 str 最右边填充 n 个 pad\n\n\nLTRIM(str)\n去掉字符串 str 左侧的空格\n\n\nRTRIM(str)\n去掉字符串 str 右侧的空格\n\n\nREPEAT(str,x)\n返回 str 重复 x 次的结果\n\n\nSTRCMP(s1,s2)\n比较字符串 s1 和 s2\n\n\nREPLACE(str,a,b)\n用字符串 b 替换字符串 str 中所有出现的字符串 a\n\n\nTRIM(str)\n去掉字符串行尾和行头的空格\n\n\nSUBSTRING(str,x,y)\n返回从字符串 str x 位置起 y 个字符长度的字串\n\n\n数学函数\n\n\n函数\n功能\n\n\n\nABS(x)\n返回 x 的绝对值\n\n\nCEIL(x)\n返回大于 x 的最小整数值\n\n\nFLOOR(x)\n返回小于 x 的最大整数值\n\n\nMOD(x,y)\n返回 x&#x2F;y 的模\n\n\nRAND()\n返回 0～1 内的随机值\n\n\nROUND(x,y)\n返回参数 x 的四舍五入的有 y 位小数的值\n\n\nTRUNCATE(x,y)\n返回数字 x 截断位 y 位小数的结果\n\n\n日期和时间函数\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前的日期和时间\n\n\nUNIX_TIMESTAMP(date)\n返回日期 date 的 UNIX 时间戳\n\n\nFROM_UNIXTIME\n返回 UNIX 时间戳的日期值\n\n\nWEEK(date)\n返回日期 date 为一年中的第几周\n\n\nYEAR(date)\n返回日期 date 的年份\n\n\nHOUR(time)\n返回 time 的小时值\n\n\nMINUTE(time)\n返回 time 的分钟值\n\n\nMONTHNAME(date)\n返回 date 的月份名\n\n\nDATE_FORMAT(date,fmt)\n返回按字符串 fmt 格式日期 date 值\n\n\nDATE_ADD(date,interval expr type)\n返回一个日期或时间值加上一个时间间隔的时间值\n\n\nDATEDIFF(expr,expr2)\n返回起始时间 expr 和结束时间 expr2 之间的天数\n\n\n流程函数\n\n\n函数\n功能\n\n\n\nIF(value,t f)\n如果 value 是真，返回 t；否则返回 f\n\n\nIFNULL(value1,value2)\n如果 value1 不为空，返回 value1，否则返回 value2\n\n\nCASE WHEN [value1] THEN[result1]…ELSE[default]END\n如果 value1 是真，返回 result1，否则返回 result\n\n\nCASE[expr] WHEN [value1]THEN[result1]…ELSE[default]END\n如果 expr 等于 value1，返回 result1，否则返回 default\n\n\n其他常用函数\n\n\n函数\n功能\n\n\n\nDATEBASE()\n返回当前数据库名\n\n\nVERSION()\n返回当前数据库版本\n\n\nUSER()\n返回当前登录用户名\n\n\nINET_ATON(ip)\n返回 ip 地址的数字表示\n\n\nINET_NTOA(num)\n返回数字代表的 ip 地址\n\n\nPASSWORD(str)\n返回字符串 str 的加密版本\n\n\nMD5()\n返回字符串 str 的 md5 值\n\n\nMySQL 数据类型串数据类型\n\n\n数据类型\n说明\n\n\n\nCHAR\n1～255 个字符的定长串。它的长度必须在创建时指定，否则 MySQL 假定为 CHAR(1)\n\n\nENUM\n接受最多 64 K 个串组成的一个预定义集合的某个串\n\n\nLONGTEXT\n与 TEXT 相同，但最大长度为 4GB\n\n\nMEDIUMTEXT\n与 TEXT 相同，但最大长度为 16K\n\n\nSET\n接受最多 64 个串组成的一个预定义集合的零个或多个串\n\n\nTEXT\n最大长度为 64K 的变长文本\n\n\nTINYTEXT\n与 TEXT 相同，但最大长度为 255 字节\n\n\nVARCHAR\n长度可变，最多不超过 255 字节。如果在创建时指定为 VARCHAR(n)，则可存储 0 到 n 个字符的变长串（其中 n≤255）\n\n\n数值数据类型\n\n\n数据类型\n说明\n\n\n\nBIT\n位字段，1～64 位。（在 MySQL 5 之前，BIT 在功能上等价于 TINYINT\n\n\nBIGINT\n整数值，支持9223372036854775808～9223372036854775807（如果是 UNSIGNED，为 0～18446744073709551615）的数\n\n\nBOOLEAN（或 BOOL）\n布尔标志，或者为 0 或者为 1，主要用于开&#x2F;关（on&#x2F;off）标志\n\n\nDECIMAL（或 DEC）\n精度可变的浮点值\n\n\nDOUBLE\n双精度浮点值\n\n\nFLOAT\n单精度浮点值\n\n\nINT（或 INTEGER）\n整数值，支持2147483648～2147483647（如果是 UNSIGNED，为 0～4294967295）的数\n\n\nMEDIUMINT\n整数值，支持8388608～8388607（如果是 UNSIGNED，为 0～16777215）的数\n\n\nREAL\n4 字节的浮点值\n\n\nSMALLINT\n整数值，支持32768～32767（如果是 UNSIGNED，为 0～65535）的数\n\n\nTINYINT\n整数值，支持128～127（如果为 UNSIGNED，为 0～255）的数\n\n\n日期和时间数据类型\n\n\n数据类型\n说明\n\n\n\nDATE\n表示 1000-01-01～9999-12-31 的日期，格式为 YYYY-MM-DD\n\n\nDATETIME\nDATE 和 TIME 的组合\n\n\nTIMESTAMP\n功能和 DATETIME 相同（但范围较小）\n\n\nTIME\n格式为 HH:MM:SS\n\n\nYEAR\n用 2 位数字表示，范围是 70（1970 年）～69（2069 年），用 4 位数字表示，范围是 1901 年～2155 年\n\n\n二进制数据类型\n\n\n数据类型\n说明\n\n\n\nBLOB\nBlob 最大长度为 64KB\n\n\nMEDIUMBLOB\nBlob 最大长度为 16MB\n\n\nLONGBLOB\nBlob 最大长度为 4GB\n\n\nTINYBLOB\nBlob 最大长度为 255 字节\n\n\n","slug":"MySQL/MySQL常用函数汇总","date":"2022-02-23T05:32:16.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"87cebc6d905dece24636202906841487","title":"MySQL 数据库设计规范","content":"MySQL 数据库设计规范1. 规范背景与目的MySQL 数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用 MySQL 数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导 RD、QA、OP 等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL 编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。\n2. 设计规范2.1 数据库设计以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。\n对于不满足【高危】和【强制】两个级别的设计，DBA 会强制打回要求修改。\n2.1.1 一般命名规则\n【强制】使用小写，有助于提高打字速度，避免因大小写敏感而导致的错误。\n【强制】没有空格，使用下划线代替。\n【强制】名称中没有数字，只有英文字母。\n【强制】有效的可理解的名称。\n【强制】名称应该是自我解释的。\n【强制】名称不应超过 32 个字符。\n【强制】避免使用前缀。\n\n2.1.2 库\n【强制】遵守以上全部一般命名规则。 \n【强制】使用单数。 \n【强制】库的名称格式：业务系统名称_子系统名。 \n【强制】一般分库名称命名格式是库通配名_编号，编号从 0 开始递增，比如 northwind_001，以时间进行分库的名称格式是库通配名_时间。 \n【强制】创建数据库时必须显式指定字符集，并且字符集只能是 utf8 或者 utf8mb4。创建数据库 SQL 举例：  create database db_name default character set utf8;\n\n2.1.3 表\n【强制】遵守以上全部一般命名规则。\n【强制】使用单数。\n【强制】相关模块的表名与表名之间尽量体现 join 的关系，如 user 表和 user_login 表。\n【强制】创建表时必须显式指定字符集为 utf8 或 utf8mb4。\n【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为 InnoDB。当需要使用除 InnoDB&#x2F;MyISAM&#x2F;Memory 以外的存储引擎时，必须通过 DBA 审核才能在生产环境中使用。因为 InnoDB 表支持事务、行锁、宕机恢复、MVCC 等关系型数据库重要特性，为业界使用最多的 MySQL 存储引擎。而这是其它大多数存储引擎不具备的，因此首推 InnoDB。\n【强制】建表必须有 comment。\n【强制】关于主键：(1) 命名为 id，类型为 int 或 bigint，且为 auto_increment；(2) 标识表里每一行主体的字段不要设为主键，建议设为其它字段如 user_id，order_id等，并建立 unique key 索引。因为如果设为主键且主键值为随机插入，则会导致 InnoDB 内部 page 分裂和大量随机 I&#x2F;O，性能下降。\n【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段 create_time 和最后更新时间字段 update_time，便于排查问题。\n【建议】表中所有字段必须都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT 值。因为使用 NULL 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。\n【建议】建议对表里的 blob、text 等大字段，垂直拆分到其它表里，仅在需要读这些对象的时候才去 select。\n【建议】反范式设计：把经常需要 join 查询的字段，在其它表里冗余一份。如 username 属性在 user_account，user_login_log 等表里冗余一份，减少 join 查询。\n【强制】中间表用于保留中间结果集，名称必须以 tmp_ 开头。备份表用于备份或抓取源表快照，名称必须以 bak_ 开头。中间表和备份表定期清理。\n【强制】对于超过 100W 行的大表进行 alter table，必须经过 DBA 审核，并在业务低峰期执行。因为 alter table 会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。\n\n2.1.4 字段\n【强制】遵守以上全部一般命名规则。\n【建议】尽可能选择短的或一两个单词。\n【强制】避免使用保留字作为字段名称：order，date，name 是数据库的保留字，避免使用它。可以为这些名称添加前缀使其易于理解，如 user_name，signup_date 等。\n【强制】避免使用与表名相同的字段名，这会在编写查询时造成混淆。\n【强制】在数据库模式上定义外键。\n【强制】避免使用缩写或基于首字母缩写词的名称。\n【强制】外键列必须具有表名及其主键，例如：blog_id 表示来自表博客的外键 id。\n\n2.1.5 字段数据类型优化\n【建议】表中的自增列（auto_increment 属性），推荐使用 bigint 类型。因为无符号 int 存储范围为 0~4,294,967,295（不到 43 亿），溢出后会导致报错。 \n【建议】业务中选择性很少的状态 status、类型 type 等字段推荐使用 tinytint 或者 smallint 类型节省存储空间。 \n【建议】业务中 IP 地址字段推荐使用 int 类型，不推荐用 char(15)。因为 int 只占 4 字节，可以用如下函数相互转换，而 char(15) 占用至少 15 字节。\n\nSQL: \nselect inet_aton('192.168.2.12');\nselect inet_ntoa(3232236044);\nPHP: \nip2long('192.168.2.12'); \nlong2ip(3530427185);\n\nJava:  \npublic static long ipToLong(String addr)&#123;\n    String[] addrArray = addr.split(\"\\\\.\");\n    long num = 0;\n    for (int i = 0; i &lt; addrArray.length; i++)&#123;\n        int power = 3 - i;\n        num += ((Integer.parseInt(addrArray[i]) % 256 * Math.pow(256, power)));\n    &#125;\n    return num;\n&#125;\n\npublic static String longToIp(long i)&#123;\n    return ((i >> 24) &amp; 0xFF) + \".\" +\n           ((i >> 16) &amp; 0xFF) + \".\" +\n           ((i >> 8) &amp; 0xFF) + \".\" +\n           (i &amp; 0xFF);\n&#125;\n\n\n【建议】不推荐使用 enum，set。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用 tinyint 或 smallint。 \n【建议】不推荐使用 blob，text 等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和 PM、RD 沟通，是否真的需要这么大字段。InnoDB 中当一行记录超过 8098 字节时，会将该记录中选取最长的一个字段将其 768 字节放在原始 page 里，该字段余下内容放在 overflow-page 里。不幸的是在 compact 行格式下，原始 page 和 overflow-page 都会加载。 \n【建议】存储金钱的字段，建议用 int 以分为单位存储，最大数值约 4290 万，程序端乘以 100 和除以 100 进行存取。因为 int 占用 4 字节，而 double 占用 8 字节，空间浪费。 \n【建议】文本数据尽量用 varchar 存储。因为 varchar 是变长存储，比 char 更省空间。MySQL server 层规定一行所有文本最多存 65535 字节，因此在 utf8 字符集下最多存 21844 个字符，超过会自动转换为 mediumtext 字段。而 text 在 utf8 字符集下最多存 21844 个字符，mediumtext 最多存 2^24&#x2F;3 个字符，longtext 最多存 2^32 个字符。一般建议用 varchar 类型，字符数不要超过 2700。 \n【建议】时间类型尽量选取 timestamp。因为 datetime 占用 8 字节，timestamp 仅占用 4 字节，但是范围为 1970-01-01 00:00:01 到 2038-01-01 00:00:00。更为高阶的方法，选用 int 来存储时间，使用 SQL 函数 unix_timestamp() 和 from_unixtime() 来进行转换。\n\n\n详细存储大小参考下图：  \n\n\n类型（同义词）\n存储长度(BYTES)\n最小值(SIGNED&#x2F;UNSIGNED)\n最大值(SIGNED&#x2F;UNSIGNED)\n\n\n\n整形数字\n\n\n\n\n\nTINYINT\n1\n-128&#x2F;0\n127&#x2F;255\n\n\nSMALLINT\n2\n-32,768&#x2F;0\n32767&#x2F;65,535\n\n\nMEDIUMINT\n3\n-8,388,608&#x2F;0\n8388607&#x2F;16,777,215&#x2F;\n\n\nINT(INTEGER)\n4\n-2,14,7483,648&#x2F;0\n2147483647&#x2F;4,294,967,295&#x2F;\n\n\nBIGINT\n8\n-2^63&#x2F;0\n263-1&#x2F;264-1\n\n\n小数支持\n\n\n\n\n\nFLOAT[(M[,D])]\n4 or 8\n-\n\n\n\nDOUBLE[(M[,D])]\n\n\n\n\n\n(REAL, DOUBLE PRECISION)\n8\n-\n\n\n\n时间类型\n\n\n\n\n\nDATETIME\n8\n1001-01-01 00:00:00\n9999-12-31 23:59:59\n\n\nDATE\n3\n1001-01-01\n9999-12-31\n\n\nTIME\n3\n00:00:00\n23:59:59\n\n\nYEAR\n1\n1001\n9999\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:00\n\n\n\n\n\n2.1.6 索引设计\n【强制】InnoDB 表必须主键为 id int/bigint auto_increment，且主键值禁止被更新。\n【建议】主键的名称以 pk_ 开头，唯一键以 uk_ 开头，普通索引以 ix_ 开头，一律使用小写格式，以表名&#x2F;字段的名称或缩写作为后缀。\n【强制】InnoDB 和 MyISAM 存储引擎表，索引类型必须为 BTREE；MEMORY 表可以根据需要选择 HASH 或者 BTREE 类型索引。\n【强制】单个索引中每个索引记录的长度不能超过 64KB。\n【建议】单个表上的索引个数不能超过 7 个。\n【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列 user_id 的区分度可由 select count(distinct user_id) 计算出来。\n【建议】在多表 join 的 SQL 里，保证被驱动表的连接列上有索引，这样 join 执行效率最高。\n【建议】建表或加索引时，保证表里互相不存在冗余索引。对于 MySQL 来说，如果表里已经存在 key(a, b)，则 key(a) 为冗余索引，需要删除。\n【建议】如果选择性超过 20%，那么全表扫描比使用索引性能更优，即没有设置索引的必要。\n\n2.1.7 分库分表、分区表\n【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列。\n【强制】单个分区表中的分区（包括子分区）个数不能超过 1024。\n【强制】上线前 RD 或者 DBA 必须指定分区表的创建、清理策略。\n【强制】访问分区表的 SQL 必须包含分区键。\n【建议】单个分区文件不超过 2G，总大小不超过 50G。建议总分区数不超过 20 个。\n【强制】对于分区表执行 alter table 操作，必须在业务低峰期执行。\n【强制】采用分库策略的，库的数量不能超过 1024。\n【强制】采用分表策略的，表的数量不能超过 4096。\n【建议】单个分表不超过 500W 行，ibd 文件大小不超过 2G，这样才能让数据分布式变得性能更佳。\n【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。\n\n2.1.8 字符集\n【强制】数据库本身库、表、列所有字符集必须保持一致，为 utf8 或 utf8mb4。\n【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为 utf8。\n\n2.1.9 程序层 DAO 设计建议\n【建议】新的代码不要用 model，推荐使用手动拼 SQL + 绑定变量传入参数的方式。因为 model 虽然可以使用面向对象的方式操作 db，但是其使用不当很容易造成生成的 SQL 非常复杂，且 model 层自己做的强制类型转换性能较差，最终导致数据库性能下降。\n【建议】前端程序连接 MySQL 或者 Redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。\n【建议】前端程序报错里尽量能够提示 MySQL 或 Redis 原生态的报错信息，便于排查错误。\n【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。\n【建议】对于 log 或 history 类型的表，随时间增长容易越来越大，因此上线前 RD 或者 DBA 必须建立表数据清理或归档方案。\n【建议】在应用程序设计阶段，RD 必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20 秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。\n【建议】多个并发业务逻辑访问同一块数据（InnoDB 表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类 SQL 尽量基于主键去更新。\n【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。\n【建议】对于单表读写比大于 10:1 的数据行或单个列，可以将热点数据放在缓存里（如 Memcached 或 Redis），加快访问速度，降低 MySQL 压力。\n\n2.1.10 一个规范的建表语句示例\n一个较为规范的建表语句为： create table user \n( \n    `id`            bigint(11) not null auto_increment, \n    `user_id`       bigint(11) not null comment '用户 ID', \n    `username`      varchar(45) not null comment '登录名', \n    `email`         varchar(30) not null comment '邮箱', \n    `nickname`      varchar(45) not null comment '昵称', \n    `avatar`        int(11) not null comment '头像', \n    `birthday`      date not null comment '生日', \n    `gender`        tinyint(4) default '0' comment '性别', \n    `intro`         varchar(150) default null comment '简介', \n    `resume_url`    varchar(300) not null comment '简历存放地址', \n    `register_ip`   int not null comment '用户注册时的源 IP', \n    `review_status` tinyint not null comment '审核状态，1-通过，2-审核中，3-未通过，4-尚未提交审核', \n    `create_time`   timestamp not null comment '记录创建的时间', \n    `update_time`   timestamp not null comment '资料修改的时间', \n    \n    primary key (`id`), \n    unique key `idx_user_id` (`user_id`), \n    key `idx_username`(`username`), \n    key `idx_create_time`(`create_time`, `review_status`) \n) \nengine = InnoDB\ndefault charset = utf8 \ncomment = '用户基本信息';\n\n2.2 SQL 编写2.2.1 DML 语句\n【强制】select 语句必须指定具体字段名称，禁止写成 *。因为 select * 会将不该读的数据也从 MySQL 里读出来，造成网卡压力。\n【强制】insert 语句指定具体字段名称，不要写成 insert into t1 values(…)，道理同上。\n【建议】insert into … values(xx),(xx),(xx)…，这里 xx 的值不要超过 5000 个。值过多虽然上线很快，但会引起主从同步延迟。\n【建议】select 语句不要使用 union，推荐使用 union all，并且 union 子句个数限制在 5 个以内。因为 union all 不需要去重，节省数据库资源，提高性能。\n【建议】in 值列表限制在 500 以内。例如 select … where user_id in(…500 个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。\n【建议】事务里批量更新数据需要控制数量，进行必要的 sleep，做到少量多次。\n【强制】事务涉及的表必须全部是 InnoDB 表。否则一旦失败不会全部回滚，且易造成主从库同步终端。\n【强制】写入和事务发往主库，只读 SQL 发往从库。\n【强制】除静态表或小表（100 行以内），dml 语句必须有 where 条件，且使用索引查找。\n【强制】生产环境禁止使用 hint，如 sql_no_cache，force index，ignore key，straight join 等。因为 hint 是用来强制 sql 按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信 MySQL 优化器。\n【强制】where 条件里等号左右字段类型必须一致，否则无法利用索引。\n【建议】select|update|delete|replace 要有 where 子句，且 where 子句的条件必需使用索引查找。\n【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于 100 行以下的静态表可以全表扫描。查询数据量不要超过表行数的 25%，否则不会利用索引。\n【强制】where 子句中禁止只使用全模糊的 like 条件进行查找，必须有其它等值或范围查询条件，否则无法利用索引。\n【建议】索引列不要使用函数或表达式，否则无法利用索引。如 where length(name) = &#39;admin&#39; 或 where user_id + 2 = 10023。\n【建议】减少使用 or 语句，可将 or 语句优化为 union，然后在各个 where 条件上建立索引。如 where a = 1 or b = 2 优化为 where a = 1 … union … where b = 2, key(a), key(b)。\n【建议】分页查询，当 limit 起点较高时，可先用过滤条件进行过滤。如 select a, b, c from t1 limit 10000, 20; 优化为: select a, b, c from t1 where id &gt; 10000 limit 20;。\n\n2.2.2 多表连接\n【强制】禁止跨 DB 的 join 语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。\n【强制】禁止在业务的更新类 SQL 语句中使用 join，比如 update t1 join t2 …。\n【建议】不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 join 来代替子查询。\n【建议】线上环境，多表 join 不要超过 3 个表。\n【建议】多表连接查询推荐使用别名，且 select 列表中要用别名引用字段，数据库.表格式，如 select a from db1.table1 alias1 where …。\n【建议】在多表 join 中，尽量选取结果集较小的表作为驱动表，来 join 其它表。\n\n2.2.3 事务\n【建议】事务中 insert|update|delete|replace 语句操作的行数控制在 2000 以内，以及 where 子句中 in 列表的传参个数控制在 500 以内。\n【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的 sleep，一般建议值 5-10 秒。\n【建议】对于有 auto_increment 属性字段的表的插入操作，并发需要控制在 200 以内。\n【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为 repeatable-read。\n【建议】事务里包含 SQL 不超过 5 个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL 内部缓存、连接消耗过多等雪崩问题。\n【建议】事务里更新语句尽量基于主键或 unique key，如 update … where id = XX;，否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。\n【建议】尽量把一些典型外部调用移出事务，如调用 Web Service，访问文件存储等，从而避免事务过长。\n【建议】对于 MySQL 主从延迟严格敏感的 select 语句，请开启事务强制访问主库。\n\n2.2.4 排序和分组\n【建议】减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。\n【建议】order by、group by、distinct 这些 SQL 尽量利用索引直接检索出排序好的数据。如 where a = 1 order by 可以利用 key(a, b)。\n【建议】包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。\n\n2.2.5 线上禁止使用的 SQL 语句\n【高危】禁用 update|delete t1 … where a = XX limit XX; 这种带 limit 的更新语句。因为会导致主从不一致，导致数据错乱。建议加上 order by PK。\n【高危】禁止使用关联子查询，如 update t1 set … where name in(select name from user where …);，效率极其低下。\n【强制】禁用 procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。\n【强制】禁用 insert into … on duplicate key update … 在高并发环境下，会造成主从不一致。\n【强制】禁止联表更新语句，如 update t1, t2 where t1.id = t2.id …。\n\n","slug":"MySQL/MySQL数据库设计规范","date":"2022-02-23T03:37:18.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"b4b30b3366bb496de67ea3da9b9ffa6f","title":"Java 基础","content":"一、数据类型基本类型\nbyte&#x2F;8\nchar&#x2F;16\nshort&#x2F;16\nint&#x2F;32\nfloat&#x2F;32\nlong&#x2F;64\ndouble&#x2F;64\nboolean&#x2F;~\n\nboolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。\n\nPrimitive Data Types\nThe Java® Virtual Machine Specification\n\n包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\nInteger x = 2;     // 装箱 调用了 Integer.valueOf(2)\nint y = x;         // 拆箱 调用了 X.intValue()\n\n\nAutoboxing and Unboxing\n\n缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于：\n\nnew Integer(123) 每次都会新建一个对象；\nInteger.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y);    // false\nInteger z = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(z == k);   // true\n\nvalueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\npublic static Integer valueOf(int i) &#123;\n    if (i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;\n\n在 Java 8 中，Integer 缓存池的大小默认为 -128~127。\nstatic final int low = -128;\nstatic final int high;\nstatic final Integer cache[];\n\nstatic &#123;\n    // high value may be configured by property\n    int h = 127;\n    String integerCacheHighPropValue =\n        sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n    if (integerCacheHighPropValue != null) &#123;\n        try &#123;\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        &#125; catch( NumberFormatException nfe) &#123;\n            // If the property cannot be parsed into an int, ignore it.\n        &#125;\n    &#125;\n    high = h;\n\n    cache = new Integer[(high - low) + 1];\n    int j = low;\n    for(int k = 0; k &lt; cache.length; k++)\n        cache[k] = new Integer(j++);\n\n    // range [-128, 127] must be interned (JLS7 5.1.7)\n    assert IntegerCache.high >= 127;\n&#125;\n\n编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。\nInteger m = 123;\nInteger n = 123;\nSystem.out.println(m == n); // true\n\n基本类型对应的缓冲池如下：\n\nboolean values true and false\nall byte values\nshort values between -128 and 127\nint values between -128 and 127\nchar in the range \\u0000 to \\u007F\n\n在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。\n在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax&#x3D; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。\n[StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123\n](https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123)\n二、String概览String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）在 Java 8 中，String 内部使用 char 数组存储数据。\npublic final class String\n    implements java.io.Serializable, Comparable&lt;String>, CharSequence &#123;\n    /** The value is used for character storage. */\n    private final char value[];\n&#125;\n\n在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。\npublic final class String\n    implements java.io.Serializable, Comparable&lt;String>, CharSequence &#123;\n    /** The value is used for character storage. */\n    private final byte[] value;\n\n    /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */\n    private final byte coder;\n&#125;\n\nvalue 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。\n不可变的好处1. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\n2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\n\n3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。\n4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。\nProgram Creek : Why String is immutable in Java?\nString, StringBuffer and StringBuilder1. 可变性\nString 不可变\nStringBuffer 和 StringBuilder 可变\n\n2. 线程安全\nString 不可变，因此是线程安全的\nStringBuilder 不是线程安全的\nStringBuffer 是线程安全的，内部使用 synchronized 进行同步\n\nStackOverflow : String, StringBuffer, and StringBuilder\nString Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。\n当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。\n下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 “aaa” 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。\nString s1 = new String(\"aaa\");\nString s2 = new String(\"aaa\");\nSystem.out.println(s1 == s2);           // false\nString s3 = s1.intern();\nString s4 = s2.intern();\nSystem.out.println(s3 == s4);           // true\n\n如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。\nString s5 = \"bbb\";\nString s6 = \"bbb\";\nSystem.out.println(s5 == s6);  // true\n\n在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。\n\nStackOverflow : What is String interning?\n深入解析 String#intern\n\nnew String(“abc”)使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。\n\n“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；\n而使用 new 的方式会在堆中创建一个字符串对象。\n\n创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。\npublic class NewStringTest &#123;\n    public static void main(String[] args) &#123;\n        String s = new String(\"abc\");\n    &#125;\n&#125;\n\n使用 javap -verbose 进行反编译，得到以下内容：\n// ...\nConstant pool:\n// ...\n   #2 = Class              #18            // java/lang/String\n   #3 = String             #19            // abc\n// ...\n  #18 = Utf8               java/lang/String\n  #19 = Utf8               abc\n// ...\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=3, locals=2, args_size=1\n         0: new           #2                  // class java/lang/String\n         3: dup\n         4: ldc           #3                  // String abc\n         6: invokespecial #4                  // Method java/lang/String.\"&lt;init>\":(Ljava/lang/String;)V\n         9: astore_1\n// ...\n\n在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。\n以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。\npublic String(String original) &#123;\n    this.value = original.value;\n    this.hash = original.hash;\n&#125;\n\n三、运算参数传递Java 的参数是以值传递的形式传入方法中，而不是引用传递。以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。\npublic class Dog &#123;\n\n    String name;\n\n    Dog(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getName() &#123;\n        return this.name;\n    &#125;\n\n    void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getObjectAddress() &#123;\n        return super.toString();\n    &#125;\n&#125;\n\n在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。\nclass PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(\"A\");\n        func(dog);\n        System.out.println(dog.getName());          // B\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        dog.setName(\"B\");\n    &#125;\n&#125;\n\n但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。\npublic class PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(\"A\");\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        func(dog);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        System.out.println(dog.getName());          // A\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        dog = new Dog(\"B\");\n        System.out.println(dog.getObjectAddress()); // Dog@74a14482\n        System.out.println(dog.getName());          // B\n    &#125;\n&#125;\n\nStackOverflow: Is Java “pass-by-reference” or “pass-by-value”?\nfloat 与 doubleJava 不能隐式执行向下转型，因为这会使得精度降低。1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。\n// float f = 1.1;\n\n1.1f 字面量才是 float 类型。\nfloat f = 1.1f;\n\n隐式类型转换因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。\nshort s1 = 1;\n// s1 = s1 + 1;\n\n但是使用 +&#x3D; 或者 ++ 运算符会执行隐式类型转换。\ns1 += 1;\ns1++;\n\n上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：\ns1 = (short) (s1 + 1);\n\nStackOverflow : Why don’t Java’s +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; compound assignment operators require casting?\nswitch从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。\nString s = \"a\";\nswitch (s) &#123;\n    case \"a\":\n        System.out.println(\"aaa\");\n        break;\n    case \"b\":\n        System.out.println(\"bbb\");\n        break;\n&#125;\n\nswitch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n// long x = 111;\n// switch (x) &#123; // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'\n//     case 111:\n//         System.out.println(111);\n//         break;\n//     case 222:\n//         System.out.println(222);\n//         break;\n// &#125;\n\nStackOverflow : Why can’t your switch statement data type be long, Java?\n四、关键字final1. 数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n\n对于基本类型，final 使数值不变；\n对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。\n\nfinal int x = 1;\n// x = 2;  // cannot assign value to final variable 'x'\nfinal A y = new A();\ny.a = 1;\n\n2. 方法声明方法不能被子类重写。\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n3. 类声明类不允许被继承。\nstatic1. 静态变量\n静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。\n实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n\npublic class A &#123;\n\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(String[] args) &#123;\n        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context\n        A a = new A();\n        int x = a.x;\n        int y = A.y;\n    &#125;\n&#125;\n\n2. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\npublic abstract class A &#123;\n    public static void func1()&#123;\n    &#125;\n    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'\n&#125;\n\n只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。\npublic class A &#123;\n\n    private static int x;\n    private int y;\n\n    public static void func1()&#123;\n        int a = x;\n        // int b = y;  // Non-static field 'y' cannot be referenced from a static context\n        // int b = this.y;     // 'A.this' cannot be referenced from a static context\n    &#125;\n&#125;\n\n3. 静态语句块静态语句块在类初始化时运行一次。\npublic class A &#123;\n    static &#123;\n        System.out.println(\"123\");\n    &#125;\n\n    public static void main(String[] args) &#123;\n        A a1 = new A();\n        A a2 = new A();\n    &#125;\n&#125;\n\n// 只会打印一次\n123\n\n4. 静态内部类非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。\npublic class OuterClass &#123;\n\n    class InnerClass &#123;\n    &#125;\n\n    static class StaticInnerClass &#123;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context\n        OuterClass outerClass = new OuterClass();\n        InnerClass innerClass = outerClass.new InnerClass();\n        StaticInnerClass staticInnerClass = new StaticInnerClass();\n    &#125;\n&#125;\n\n静态内部类不能访问外部类的非静态的变量和方法。\n5. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。\nimport static com.xxx.ClassName.*\n\n6. 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\npublic static String staticField = \"静态变量\";\n\nstatic &#123;\n    System.out.println(\"静态语句块\");\n&#125;\n\npublic String field = \"实例变量\";\n\n&#123;\n    System.out.println(\"普通语句块\");\n&#125;\n\n最后才是构造函数的初始化。\npublic InitialOrderTest() &#123;\n    System.out.println(\"构造函数\");\n&#125;\n\n存在继承的情况下，初始化顺序为：\n\n父类（静态变量、静态语句块）\n子类（静态变量、静态语句块）\n父类（实例变量、普通语句块）\n父类（构造函数）\n子类（实例变量、普通语句块）\n子类（构造函数）\n\n五、Object 通用方法概览public native int hashCode()\n\npublic boolean equals(Object obj)\n\nprotected native Object clone() throws CloneNotSupportedException\n\npublic String toString()\n\npublic final native Class&lt;?> getClass()\n\nprotected void finalize() throws Throwable &#123;&#125;\n\npublic final native void notify()\n\npublic final native void notifyAll()\n\npublic final native void wait(long timeout) throws InterruptedException\n\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\npublic final void wait() throws InterruptedException\n\nequals()1. 等价关系两个对象具有等价关系，需要满足以下五个条件：\nⅠ 自反性x.equals(x); // true\n\nⅡ 对称性x.equals(y) == y.equals(x); // true\n\nⅢ 传递性if (x.equals(y) &amp;&amp; y.equals(z))\n    x.equals(z); // true;\n\nⅣ 一致性多次调用 equals() 方法结果不变\nx.equals(y) == x.equals(y); // true\n\nⅤ 与 null 的比较对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\nx.equals(null); // false;\n\n2. 等价与相等\n对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。\n对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。\n\nInteger x = new Integer(1);\nInteger y = new Integer(1);\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x == y);      // false\n\n3. 实现\n检查是否为同一个对象的引用，如果是直接返回 true；\n检查是否是同一个类型，如果不是，直接返回 false；\n将 Object 对象进行转型；\n判断每个关键域是否相等。\n\npublic class EqualExample &#123;\n\n    private int x;\n    private int y;\n    private int z;\n\n    public EqualExample(int x, int y, int z) &#123;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        EqualExample that = (EqualExample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    &#125;\n&#125;\n\nhashCode()hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。\n在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。\nHashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。\n下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。\nEqualExample e1 = new EqualExample(1, 1, 1);\nEqualExample e2 = new EqualExample(1, 1, 1);\nSystem.out.println(e1.equals(e2)); // true\nHashSet&lt;EqualExample> set = new HashSet&lt;>();\nset.add(e1);\nset.add(e2);\nSystem.out.println(set.size());   // 2\n\n理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。\nR 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。\n@Override\npublic int hashCode() &#123;\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n&#125;\n\ntoString()默认返回 ToStringExample@4554617c  这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 \npublic class ToStringExample &#123;\n\n    private int number;\n\n    public ToStringExample(int number) &#123;\n        this.number = number;\n    &#125;\n&#125;\n\nToStringExample example = new ToStringExample(123);\nSystem.out.println(example.toString());\n\nToStringExample@4554617c\n\nclone()1. cloneableclone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\npublic class CloneExample &#123;\n    private int a;\n    private int b;\n&#125;\n\nCloneExample e1 = new CloneExample();\n// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'\n\n重写 clone() 得到以下实现：\npublic class CloneExample &#123;\n    private int a;\n    private int b;\n\n    @Override\n    public CloneExample clone() throws CloneNotSupportedException &#123;\n        return (CloneExample)super.clone();\n    &#125;\n&#125;\n\nCloneExample e1 = new CloneExample();\ntry &#123;\n    CloneExample e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\n\njava.lang.CloneNotSupportedException: CloneExample\n\n以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。\n应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。\npublic class CloneExample implements Cloneable &#123;\n    private int a;\n    private int b;\n\n    @Override\n    public Object clone() throws CloneNotSupportedException &#123;\n        return super.clone();\n    &#125;\n&#125;\n\n2. 浅拷贝拷贝对象和原始对象的引用类型引用同一个对象。\npublic class ShallowCloneExample implements Cloneable &#123;\n\n    private int[] arr;\n\n    public ShallowCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected ShallowCloneExample clone() throws CloneNotSupportedException &#123;\n        return (ShallowCloneExample) super.clone();\n    &#125;\n&#125;\n\nShallowCloneExample e1 = new ShallowCloneExample();\nShallowCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 222\n\n3. 深拷贝拷贝对象和原始对象的引用类型引用不同对象。\npublic class DeepCloneExample implements Cloneable &#123;\n\n    private int[] arr;\n\n    public DeepCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected DeepCloneExample clone() throws CloneNotSupportedException &#123;\n        DeepCloneExample result = (DeepCloneExample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            result.arr[i] = arr[i];\n        &#125;\n        return result;\n    &#125;\n&#125;\n\nDeepCloneExample e1 = new DeepCloneExample();\nDeepCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n4. clone() 的替代方案使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\npublic class CloneConstructorExample &#123;\n\n    private int[] arr;\n\n    public CloneConstructorExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public CloneConstructorExample(CloneConstructorExample original) &#123;\n        arr = new int[original.arr.length];\n        for (int i = 0; i &lt; original.arr.length; i++) &#123;\n            arr[i] = original.arr[i];\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n&#125;\n\nCloneConstructorExample e1 = new CloneConstructorExample();\nCloneConstructorExample e2 = new CloneConstructorExample(e1);\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n六、继承访问权限Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n可以对类或类中的成员（字段和方法）加上访问修饰符。\n\n类可见表示其它类可以用这个类创建实例对象。\n成员可见表示其它类可以用这个类的实例对象访问到该成员；\n\nprotected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\n设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\n如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。\n字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。\npublic class AccessExample &#123;\n    public String id;\n&#125;\n\n可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\npublic class AccessExample &#123;\n\n    private int id;\n\n    public String getId() &#123;\n        return id + \"\";\n    &#125;\n\n    public void setId(String id) &#123;\n        this.id = Integer.valueOf(id);\n    &#125;\n&#125;\n\n但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\npublic class AccessWithInnerClassExample &#123;\n\n    private class InnerClass &#123;\n        int x;\n    &#125;\n\n    private InnerClass innerClass;\n\n    public AccessWithInnerClassExample() &#123;\n        innerClass = new InnerClass();\n    &#125;\n\n    public int getValue() &#123;\n        return innerClass.x;  // 直接访问\n    &#125;\n&#125;\n\n抽象类与接口1. 抽象类抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。\n抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。\npublic abstract class AbstractClassExample &#123;\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() &#123;\n        System.out.println(\"func2\");\n    &#125;\n&#125;\n\npublic class AbstractExtendClassExample extends AbstractClassExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(\"func1\");\n    &#125;\n&#125;\n\n// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated\nAbstractClassExample ac2 = new AbstractExtendClassExample();\nac2.func1();\n\n2. 接口接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。\n接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。\n接口的字段默认都是 static 和 final 的。\npublic interface InterfaceExample &#123;\n\n    void func1();\n\n    default void func2()&#123;\n        System.out.println(\"func2\");\n    &#125;\n\n    int x = 123;\n    // int y;               // Variable 'y' might not have been initialized\n    public int z = 0;       // Modifier 'public' is redundant for interface fields\n    // private int k = 0;   // Modifier 'private' not allowed here\n    // protected int l = 0; // Modifier 'protected' not allowed here\n    // private void fun3(); // Modifier 'private' not allowed here\n&#125;\n\npublic class InterfaceImplementExample implements InterfaceExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(\"func1\");\n    &#125;\n&#125;\n\n// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated\nInterfaceExample ie2 = new InterfaceImplementExample();\nie2.func1();\nSystem.out.println(InterfaceExample.x);\n\n3. 比较\n从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。\n从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。\n接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。\n接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。\n\n4. 使用选择使用接口：\n\n需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；\n需要使用多重继承。\n\n使用抽象类：\n\n需要在几个相关的类中共享代码。\n需要能控制继承来的成员的访问权限，而不是都为 public。\n需要继承非静态和非常量字段。\n\n在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\n\nAbstract Methods and Classes\n深入理解 abstract class 和 interface\nWhen to Use Abstract Class and Interface\nJava 9 Private Methods in Interfaces\n\nsuper\n访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。\n访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。\n\npublic class SuperExample &#123;\n\n    protected int x;\n    protected int y;\n\n    public SuperExample(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n\n    public void func() &#123;\n        System.out.println(\"SuperExample.func()\");\n    &#125;\n&#125;\n\npublic class SuperExtendExample extends SuperExample &#123;\n\n    private int z;\n\n    public SuperExtendExample(int x, int y, int z) &#123;\n        super(x, y);\n        this.z = z;\n    &#125;\n\n    @Override\n    public void func() &#123;\n        super.func();\n        System.out.println(\"SuperExtendExample.func()\");\n    &#125;\n&#125;\n\nSuperExample e = new SuperExtendExample(1, 2, 3);\ne.func();\n\nSuperExample.func()\nSuperExtendExample.func()\n\nUsing the Keyword super\n重写与重载1. 重写（Override）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n为了满足里式替换原则，重写有以下三个限制：\n\n子类方法的访问权限必须大于等于父类方法；\n子类方法的返回类型必须是父类方法返回类型或为其子类型。\n子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。\n\n使用 @Override  注解，可以让编译器帮忙检查是否满足上面的三个限制条件。 \n下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：\n\n子类方法访问权限为 public，大于父类的 protected。\n子类的返回类型为 ArrayList，是父类返回类型 List 的子类。\n子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。\n子类重写方法使用 @Override  注解，从而让编译器自动检查是否满足限制条件。\n\nclass SuperClass &#123;\n    protected List&lt;Integer> func() throws Throwable &#123;\n        return new ArrayList&lt;>();\n    &#125;\n&#125;\n\nclass SubClass extends SuperClass &#123;\n    @Override\n    public ArrayList&lt;Integer> func() throws Exception &#123;\n        return new ArrayList&lt;>();\n    &#125;\n&#125;\n\n在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：\n\nthis.func(this)\nsuper.func(this)\nthis.func(super)\nsuper.func(super)\n\n/*\n    A\n    |\n    B\n    |\n    C\n    |\n    D\n */\n\n\nclass A &#123;\n\n    public void show(A obj) &#123;\n        System.out.println(\"A.show(A)\");\n    &#125;\n\n    public void show(C obj) &#123;\n        System.out.println(\"A.show(C)\");\n    &#125;\n&#125;\n\nclass B extends A &#123;\n\n    @Override\n    public void show(A obj) &#123;\n        System.out.println(\"B.show(A)\");\n    &#125;\n&#125;\n\nclass C extends B &#123;\n&#125;\n\nclass D extends C &#123;\n&#125;\n\npublic static void main(String[] args) &#123;\n\n    A a = new A();\n    B b = new B();\n    C c = new C();\n    D d = new D();\n\n    // 在 A 中存在 show(A obj)，直接调用\n    a.show(a); // A.show(A)\n    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A\n    a.show(b); // A.show(A)\n    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用\n    b.show(c); // A.show(C)\n    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C\n    b.show(d); // A.show(C)\n\n    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样\n    A ba = new B();\n    ba.show(c); // A.show(C)\n    ba.show(d); // A.show(C)\n&#125;\n\n2. 重载（Overload）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n应该注意的是，返回值不同，其它都相同不算是重载。\nclass OverloadingExample &#123;\n    public void show(int x) &#123;\n        System.out.println(x);\n    &#125;\n\n    public void show(int x, String y) &#123;\n        System.out.println(x + \" \" + y);\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    OverloadingExample example = new OverloadingExample();\n    example.show(1);\n    example.show(1, \"2\");\n&#125;\n\n七、反射每个类都有一个   Class   对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。\n类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\nClass 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：\n\nField  ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；\nMethod  ：可以使用 invoke() 方法调用与 Method 对象关联的方法；\nConstructor  ：可以用 Constructor 的 newInstance() 创建新的对象。\n\n反射的优点：\n可扩展性   ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。\n类浏览器和可视化开发环境   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。\n调试器和测试工具   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。\n\n反射的缺点：尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。\n\n性能开销   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 \n安全限制   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 \n内部暴露   ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 \nTrail: The Reflection API \n深入解析 Java 反射（1）- 基础\n\n八、异常Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：  Error   和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：\n\n受检异常  ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；\n非受检异常  ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。\n\n\n\nJava Exception Interview Questions and Answers \nJava提高篇——Java 异常处理\n\n九、泛型public class Box&lt;T> &#123;\n    // T stands for \"Type\"\n    private T t;\n    public void set(T t) &#123; this.t = t; &#125;\n    public T get() &#123; return t; &#125;\n&#125;\n\n\nJava 泛型详解\n10 道 Java 泛型面试题\n\n十、注解Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\n注解 Annotation 实现原理与自定义注解例子\n十一、特性Java 各版本的新特性New highlights in Java SE 8\nLambda Expressions\nPipelines and Streams\nDate and Time API\nDefault Methods\nType Annotations\nNashhorn JavaScript Engine\nConcurrent Accumulators\nParallel operations\nPermGen Error Removed\n\nNew highlights in Java SE 7\nStrings in Switch Statement\nType Inference for Generic Instance Creation\nMultiple Exception Handling\nSupport for Dynamic Languages\nTry with Resources\nJava nio Package\nBinary Literals, Underscore in literals\nDiamond Syntax\n\n\nDifference between Java 1.8 and Java 1.7?\nJava 8 特性\n\nJava 与 C++ 的区别\nJava 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。\nJava 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。\nJava 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。\nJava 支持自动垃圾回收，而 C++ 需要手动回收。\nJava 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。\nJava 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。\nJava 的 goto 是保留字，但是不可用，C++ 可以使用 goto。\n\nWhat are the main differences between Java and C++?\nJRE or JDK\nJRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。\nJDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。\n\n","slug":"Java/JAVA基础","date":"2022-02-22T05:32:16.000Z","categories_index":"JAVA","tags_index":"JAVA,Java基础,Spring","author_index":"Anchor"},{"id":"66e250ca52164c88abd86f24f70b74f9","title":"工作流引擎Activiti快速入门","content":"\n\n\n\n\n\n\n\n\nActiviti是一个用Java编写的开源工作流引擎，可以执行BPMN 2.0中描述的业务流程。Activiti流程引擎优势在系统开发的易用性和轻量性上。每一项 BPM 业务功能 Activiti 流程引擎都以服务的形式提供给开发人员。通过使用这些服务，开发人员能够构建出功能丰富、轻便且高效的 BPM 应用程序。\n一、为什么要是用工作流引擎假定我们有一个支付订单状态需要维护，它的状态图如下：它的状态跃迁自左向右，清晰名了，而且没有处理角色的概念，此时我们使用代码控制好状态流转即可，无需使用框架。再来看另外一个场景，假定我们有一个企业内部采购订单，它的状态图如下：\n这个采购订单的状态复杂多变，状态的转换不稳定性很强，随时有可能增加新的状态；而且不同状态的处理人也是不同的，存在权限管理功能，若此时我们仍然使用一个状态字段来维持状态变更，无疑会困难重重。工作流引擎就是为了解决这类问题而生的，我们可以观察当前实体(如支付订单、采购订单)是否具有如下特性，由此来确定是否需要引入工作流引擎。\n\n状态的个数及其稳定性，个数多且不稳定，适合使用工作流引擎。\n每个状态的处理人，处理人角色多且不稳定，适合使用工作流引擎。\n\n工作流引擎实际上是放大了状态管理的功能，它根据既有流程图（基于BPMN2规范）的指示，指定每一次状态跃迁的处理角色，在状态变更时持久化评论、表单、附件等数据，保存了完整处理轨迹。\n\n\n\n\n\n\n\n\n\n工作流引擎 vs 规则引擎\n\n工作流更像是管理状态跃迁的，规则引擎不关心状态跃迁，它关注的是处理过程中复杂条件的组合。\n工作流引擎中包含“人”的任务，天生包含处理人角色控制；规则引擎不关心“人”的任务，不做特殊区分。\n工作流引擎是宏观控制、规则引擎是微观控制。\n\n二、BPMN2.0规范简介业务流程模型和标记法（BPMN, Business Process Model and Notation）是一套图形化表示法，用于以图形的方式详细说明各种业务流程。它最初由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，名称为”Business Process Modeling Notation”，即“业务流程建模标记法”。BPMI于2005年与对象管理组织（OMG, Object Management Group）合并。2011年1月OMG发布2.0版本（时至今日，没人会用1.0版本了），同时改为现在的名称。BPMN2.0规范的实现，实质上是一个按照特定规范编写的XML文件，使用特定的BPMN设计器，即可以图形化的形式查看和编辑该文件。Activiti以代码的形式实现了这套图形化表示法，使任务的流转依赖图形，而非具体的实现代码。如上图所示，BPMN2.0规范包含了三个部分Gateway(网关)、Event(事件)、Activities(活动)。\n\n\n\n\n\n\n\n\n\n\n**Gateway(网关)**：exclusiveGateway-排他网关，在做判断时使用，除了排他网关还有几个其它类型的网关。\n**Event(事件)**：startEvent-开始事件、endEvent-结束事件，规范要求一个完整流程图必须包含这两个部分。\n**Activities(活动)**：task-任务、sequenceFlow-连接线，活动是流程的主体部分，内部包含的类型相对较多。\n\n三、Activiti核心API\n\n\n名称\n说明\n\n\n\nProcessEngine\n流程引擎，可以获得其他所有的Service。\n\n\nRepositoryService\nRepository中存储了流程定义文件、部署和支持数据等信息；RepositoryService提供了对repository的存取服务。\n\n\nRuntimeService\n提供启动流程、查询流程实例、设置获取流程实例变量等功能。\n\n\nTaskService\n提供运行时任务查询、领取、完成、删除以及变量设置等功能。\n\n\nHistoryService\n用于获取正在运行或已经完成的流程实例的信息。\n\n\nFormService\n提供定制任务表单和存储表单数据的功能，注意存储表单数据可选的功能，也可以向自建数据表中提交数据。\n\n\nIdentityService\n提供对内建账户体系的管理功能，注意它是可选的服务，可以是用外部账户体系。\n\n\nManagementService\n较少使用，与流程管理无关，主要用于Activiti系统的日常维护。\n\n\n完成一次流程的处理，常见步骤以及他们使用的Service如下图所示：\n1、流程&amp;流程实例流程由遵守BPMN2.0规范的xml文件指定，定义流程即完成流程文件的设计。流程发布后，使用RuntimeService可以开启一个流程实例，每个流程可以开启N次流程实例，且实例之间的数据相互隔离。\n2、用户任务用户任务是BPMN2.0规范中Activities(活动)组件下的重要组成部分，在Activiti中对应Task类；区别于其他类型的任务，用户任务需要进行领取操作，不会自动执行，且领取从待处理任务列表中移除，其他候选人不可见。\n3、用户&amp;角色Activiti中内建了一个简单的账户体系，用户和角色是多对多的关系；IdentityService中提供了对用户、角色操作的API。另外，用户、角色与任务的联系，仅仅通过userId或groupId，不要求必须使用内建账户体系；由于内建的过于简单，开发者完全可以使用自有的账户体系。\n4、受让人、候选人、候选组对用户任务做领取操作(claim)，即指定了该任务的受让人，每个任务只能有一个受让人，不能多次领取（但可以再次转让）。任务的候选人和候选组支持配置多个，目的是指定处理该任务的人，不在候选列表中的人不允许处理该任务。另外，候选人、候选组可以流程文件中指定，也可以在监听事件中动态指定。\n5、变量Activiti支持以key&#x2F;value的形式，对变量做持久化处理。变量通常有两个重要作用：\n\n存储一些跟流程相关的业务数据，例如处理任务时提交的表单数据。\n流程定义文件中，可以通过UEL表达式获取存储的变量，例如，在互斥网关中选择正确的传出顺序流。\n\n6、表单用户处理任务时，通常需要填写备注说明等表单数据，Activiti的FormService对此提供了支持，表单实现如下三种可选的方式：\n\n\n\n名称\n开启方式\n数据存储位置\n\n\n\n动态表单\n流程定义文件中的activiti:formProperty属性\n与变量一样，以key&#x2F;value的形式存储在变量表\n\n\n外置表单\n流程定义文件中的activiti:formkey属性\n与变量一样，以key&#x2F;value的形式存储在变量表\n\n\n普通表单\n脱离Activiti掌控，开发人员自行创建表单和数据表，并使表单和任务关联即可\n任意位置\n\n\n三种方式中，动态表单由于无法指定样式，使用场景不多；外置表单的赋值和提交都依托Activiti引擎。实际使用中主要使用第三种方式普通表单，它的页面渲染赋值都由个人掌控，Activiti仅负责流程流转相关工作，页面渲染部分保持独立会使结构更清晰。\n7、监听器任务执行时，开发者常常需要触发一些自定义的动作，如动态分配候选人、任务结束时发送通知等；Activiti为开发者提供了两种方式来满足此类需求。\n\n执行监听器：监听一组有限的流程执行操作，如start、end和take；\n事件监听器：每当流程实例产生变化时，监听器都能得到通知消息（官方文档）；\n\n四、请假流程实例先上代码，项目Demo：activiti-demo，配置本地正确的数据库链接，然后启动项目，Activiti会自动初始化数据库建表。\n\n\n\n\n\n\n\n\n\nActiviti的表都以act_开头，第二部分是表示表的用途的两个字母缩写标识，用途也和服务的API对应。\n\nact_hi_*：’hi’表示 history，此前缀的表包含历史数据，如历史(结束)流程实例，变量，任务等等。\nact_ge_*：’ge’表示 general，此前缀的表为通用数据，用于不同场景中。\nact_evt_*：’evt’表示 event，此前缀的表为事件日志。\nact_procdef_*：’procdef’表示 processdefine，此前缀的表为记录流程定义信息。\nact_re_*：’re’表示 repository，此前缀的表包含了流程定义和流程静态资源(图片，规则等等)。\nact_ru_*：’ru’表示 runtime，此前缀的表是记录运行时的数据，包含流程实例，任务，变量，异步任务等运行中的数据。Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。\n\n1、画流程图流程图本质是一个符合BPMN2.0规范的xml文件，由拖拽式的设计软件完成，方式有很多，我在Git上准备的项目中内置了一个Vue版本的流程图设计工具，可以直接使用该模块来制作流程图。\n2、部署流程/**\n     * 流程部署\n     */\n    @Test\n    public void deploy() &#123;\n        RepositoryService repositoryService = processEngine.getRepositoryService();//资源对象\n        Deployment deployment = repositoryService.createDeployment()//创建一个部署对象\n                .name(\"请假流程\")\n                .addClasspathResource(BPMN)\n                .deploy();\n        System.out.println(\"部署ID：\"+deployment.getId());\n        System.out.println(\"部署名称：\"+deployment.getName());\n    &#125;\n3、启动流程/**\n     * 启动流程实例分配任务给个人\n     */\n    @Test\n    public void start() &#123;\n        //脑补一下这个是从前台传过来的数据\n        String userKey=\"李克俭\";\n        //每一个流程有对应的一个key这个是某一个流程内固定的写在bpmn内的\n        String processDefinitionKey =\"myProcess\";\n        HashMap&lt;String, Object> variables=new HashMap&lt;>();\n        //userKey在上文的流程变量中指定了\n        variables.put(\"userKey\", userKey);\n        variables.put(\"day\", 2);\n        variables.put(\"users\", \"陈际栋\");\n\n        ProcessInstance instance = runtimeService\n                .startProcessInstanceByKey(processDefinitionKey,variables);\n\n        System.out.println(\"流程实例ID:\"+instance.getId());\n        System.out.println(\"流程定义ID:\"+instance.getProcessDefinitionId());\n    &#125;\n4、查询待办/**\n     * 查询当前人的个人任务\n     */\n    @Test\n    public void findTask()&#123;\n        String assignee = \"李克俭\";\n        List&lt;Task> list = taskService.createTaskQuery().taskAssignee(assignee).orderByTaskCreateTime().desc().list();\n        if(list!=null &amp;&amp; list.size()>0)&#123;\n            for(Task task:list)&#123;\n                System.out.println(\"任务ID:\"+task.getId());\n                System.out.println(\"任务名称:\"+task.getName());\n                System.out.println(\"任务的创建时间:\"+task.getCreateTime());\n                System.out.println(\"任务的办理人:\"+task.getAssignee());\n                System.out.println(\"流程实例ID：\"+task.getProcessInstanceId());\n                System.out.println(\"执行对象ID:\"+task.getExecutionId());\n                System.out.println(\"流程定义ID:\"+task.getProcessDefinitionId());\n                System.out.println(\"getOwner:\"+task.getOwner());\n                System.out.println(\"getCategory:\"+task.getCategory());\n                System.out.println(\"getDescription:\"+task.getDescription());\n                System.out.println(\"getFormKey:\"+task.getFormKey());\n                Map&lt;String, Object> map = task.getProcessVariables();\n                for (Map.Entry&lt;String, Object> m : map.entrySet()) &#123;\n                    System.out.println(\"key:\" + m.getKey() + \" value:\" + m.getValue());\n                &#125;\n                for (Map.Entry&lt;String, Object> m : task.getTaskLocalVariables().entrySet()) &#123;\n                    System.out.println(\"key:\" + m.getKey() + \" value:\" + m.getValue());\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n5、处理待办/**\n     * 完成任务\n     */\n    @Test\n    public void completeTask()&#123;\n        //任务ID\n        String taskId = \"9ac93504-0ef0-11ec-99d7-acde48001122\";\n        HashMap&lt;String, Object> variables=new HashMap&lt;>();\n        variables.put(\"days\", 1);//userKey在上文的流程变量中指定了\n        taskService.complete(taskId,variables);\n        System.out.println(\"完成任务：任务ID：\"+taskId);\n    &#125;\n……….时间有限，更多接口可自行尝试实现\n","slug":"Activiti/工作流引擎Activiti快速入门","date":"2020-06-23T05:32:16.000Z","categories_index":"JAVA","tags_index":"Activiti","author_index":"Anchor"},{"id":"49c4631107889bc801e70cd25dbb2b0a","title":"SpringMVC项目实现Session共享","content":"\n\n\n\n\n\n\n\n\n近期接到一个老项目的改造工作，需要将其由单商户单节点应用 SAAS 化，由于老项目基于 SpringMVC 构建，未做前后端分离，无法直接接入现有平台 JWT，综合考虑继续沿用 Session 机制，使用 Spring Session 实现集群 Session 共享。事情不复杂，主要难点在于处理各种老 jar 包间的冲突问题，经过一下午尝试发现以下版本 jar 包不会触发彩蛋，特记录以下。\n1、pom.xml 添加项目依赖&lt;dependency>\n    &lt;groupId>redis.clients&lt;/groupId>\n    &lt;artifactId>jedis&lt;/artifactId>\n    &lt;version>2.6.2&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>org.springframework.session&lt;/groupId>\n    &lt;artifactId>spring-session-data-redis&lt;/artifactId>\n    &lt;version>1.3.5.RELEASE&lt;/version>\n&lt;/dependency>\n\n2、web.xml 添加拦截器&lt;filter>\n    &lt;filter-name>springSessionRepositoryFilter&lt;/filter-name>\n    &lt;filter-class>org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class>\n&lt;/filter>\n&lt;filter-mapping>\n    &lt;filter-name>springSessionRepositoryFilter&lt;/filter-name>\n    &lt;url-pattern>/*&lt;/url-pattern>\n&lt;/filter-mapping>\n&lt;context-param>\n    &lt;param-name>contextConfigLocation&lt;/param-name>\n    &lt;param-value>classpath:spring-session-redis.xml&lt;/param-value>\n&lt;/context-param>\n\n\n\n\n\n\n\n\n\n\n补充一句，注意此处，springsession 拦截器位置要尽量靠上，实际操作中发现如果放在拦截器第一位可能导致中文乱码，建议放在SetCharacterEncoding之后~\n3、applicationContext.xml 添加配置 &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n        &lt;property name=\"hostName\" value=\"$&#123;config.redis.host&#125;\"/>\n        &lt;property name=\"port\" value=\"$&#123;config.redis.port&#125;\"/>\n        &lt;property name=\"password\" value=\"$&#123;config.redis.auth&#125;\"/>\n        &lt;property name=\"database\" value=\"$&#123;config.redis.index&#125;\" />\n    &lt;/bean>\n&lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\">\n        &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n    &lt;/bean>\n\n&lt;bean id=\"redisHttpSessionConfiguration\" class=\"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration\">\n        &lt;property name=\"maxInactiveIntervalInSeconds\" value=\"7200\" />\n    &lt;/bean>\n\n4、验证这就不再啰嗦了，可根据自己习惯，配置 Nginx+Docker 等方式快速验证。\n","slug":"Java/SpringMVC项目实现Session共享","date":"2019-12-11T12:22:12.000Z","categories_index":"JAVA","tags_index":"Session,SpringMVC","author_index":"Anchor"},{"id":"ad849fabb64e7ddec346e0f489d0c75c","title":"Kafka同组下多消费者仅一个消费者消费的情况处理","content":"1、问题描述线上某个服务有多个节点，每个节点都有一个消费者消费 Kafka 消息，查看日志发现仅有一个服务的消费者在正常运行，其他全部罢工中\n2、问题定位同组下监听同一 topic 中有多个消费者，但是只有一个消费者消费，一般情况是因为 Kafka 设置的partition的数量为 1,本地验证修改partition数量，问题消失。\n3、解决办法在 kafka 服务器下运行如下命令修改 kafka 的partition\n./kafka-topics.sh --zookeeper localhost:2181 --alter --topic topic名称 --partitions 10\n\n备注：topic 名称为正在使用的 topic 名称，后面那个数量为需要设置的 partition 的数量，这里设置为 10\n4、总结与扩展又查阅了相关资料，总结了一下 kafka 中 partition 和消费者的对应关系如下：\n\n消费者多于 partition同一个 partition 内的消息只能被同一个组中的一个 consumer 消费。当消费者数量多于 partition 的数量时，多余的消费者空闲。\n例子：\n有消息 1，2，3，4，5，6，7，8，9 ，partition 数量为 1，消费者数量为 2\nc1 消费：1，2，3，4，5，6，7，8，9\nc2 消费：\n\n消费者小于 partition\n（1）.partition 不是消费者倍数\n  会有多个partition对应一个消费者\n\n  例子：\n\n  有消息1，2，3，4，5，6，7，8，9      partition数量为3，消费者数量为2\n\n  c1消费：1，3，4，6，7，9\n\n  c2消费：2，5，8\n\n（2）.partition 是消费者倍数\n  消息在同一个组之间的消费者之间均分\n\n  例子：\n\n  有消息1，2，3，4，5，6，7，8，9      partition数量为3，消费者数量为3\n\n  c1消费：2，5，8\n\n  c2消费：3，6，9\n\n  c3消费：1，4，7\n\n\n多组同 topic 情况\n每个组都会消费同样的消息，同一消息会被多组消息\n  例子：\n\n  消息 1，2，3，4，5，6，7，8，9 `partition` 数量为 3，g1 组消费者数量为 3，g2 组消费者数量为 1\n\n  g1 组：\n\n  c1 消费：2，5，8\n\n  c2 消费：3，6，9\n\n  c3 消费：1，4，7\n\n  g2 组：\n\n  c1 消费：1，2，3，4，5，6，7，8，9\n\n\n\n","slug":"Kafka/Kafka同组下多消费者仅一个消费者消费的情况处理","date":"2019-04-10T12:42:52.000Z","categories_index":"JAVA","tags_index":"Kafka","author_index":"Anchor"}]