[{"id":"00e30bbeb7ce30522f4b80e6bd22ac09","title":"MySQL 数据库开发的三十六条军规","content":"MySQL 数据库开发的三十六条军规一、核心军规(5)1.1 尽量不在数据库做运算\n别让脚趾头想事情，那是脑瓜子的职责\n\n让数据库多做她擅长的事:\n\n尽量不在数据库做运算\n复杂运算秱到程序端 CPU\n尽可能简单应用 MySQL\n\n\n举例: md5() &#x2F; Order by Rand()\n\n\n1.2 控制单表数据量\n一年内的单表数据量预估\n\n纯 INT 不超 1000W\n含 CHAR 不超 500W\n\n\n合理分表不超载\n\nUSERID\nDATE\nAREA\n……\n\n\n建议单库不超过 300-400 个表\n\n\n1.3 保持表身段苗条\n表字段数少而精\n\nIO 高效\n全表遍历\n表修复快\n提高幵发\nalter table 快\n\n\n单表多少字段合适?\n\n单表 1G 体积 500W 行评估\n\n顺序读 1G 文件需 N 秒\n单行不超过 200Byte\n单表不超过 50 个纯 INT 字段\n单表不超过 20 个 CHAR(10)字段\n\n\n单表字段数上限控制在 20~50 个\n\n\n1.4 平衡范式不冗余\n严格遵循三大范式?\n效率优先、提升性能\n没有绝对的对不错\n适当时牺牲范式、加入冗余\n但会增加代码复杂度\n\n1.5 拒绝 3B\n数据库幵发像城市交通\n\n非线性增长\n\n\n拒绝 3B\n\n大 SQL (BIG SQL)\n大事务 (BIG Transaction)\n大批量 (BIG Batch)\n\n\n详细解析见后\n\n\n1.6 核心军规小结\n尽量不在数据库做运算\n控制单表数据量\n保持表身段苗条\n平衡范式不冗余\n拒绝 3B\n\n二、字段类军规(6)2.1 用好数值字段类型\n三类数值类型:\n\nTINYINT(1Byte)\nSMALLINT(2B)\nMEDIUMINT(3B)\nINT(4B)、BIGINT(8B)\nFLOAT(4B)、DOUBLE(8B)\nDECIMAL(M,D)\n\n\nBAD CASE:\n\nINT(1) VS INT(11)\nBIGINT AUTO_INCREMENT\nDECIMAL(18,0)\n\n\n\n2.2 将字符转化为数字\n数字型 VS 字符串型索引\n\n更高效\n查询更快\n占用空间更小\n\n\n举例:用无符号 INT 存储 IP，而非 CHAR(15)\n\nINT UNSIGNED\nINET_ATON()\nINET_NTOA()\n\n\n\n2.3 优先使用 ENUM 或 SET\n优先使用 ENUM 或 SET\n\n字符串\n可能值已知且有限\n\n\n存储\n\nENUM 占用 1 字节，转为数值运算\nSET 视节点定，最多占用 8 字节\n比较时需要加’ 单引号(即使是数值)\n\n\n举例\n\nsex enum(‘F’,’M’) COMMENT ‘性别’\nc1 enum(‘0’,’1’,’2’,’3’) COMMENT ‘职介审核’\n\n\n\n2.4 避免使用 NULL 字段\n避免使用 NULL 字段\n\n很难进行查询优化\nNULL 列加索引，需要额外空间\n含 NULL 复合索引无效\n\n\n举例\n\na char(32) DEFAULT NULL\nb int(10) NOT NULL\nc int(10) NOT NULL DEFAULT 0\n\n\n\n2.5 少用并拆分 TEXT&#x2F;BLOB\nTEXT 类型处理性能远低亍 VARCHAR\n\n强制生成硬盘临时表\n浪费更多空间\nVARCHAR(65535)&#x3D;&#x3D;&gt;64K (注意 UTF-8)\n\n\n尽量不用 TEXT&#x2F;BLOB 数据类型\n\n若必须使用则拆分到单独的表\n\n举例:\n\n\nCREATE TABLE t1 (\nid INT NOT NULL AUTO_INCREMENT, data text NOT NULL,\n‏PRIMARY KEY id\n) ENGINE=InnoDB;\n\n2.6 不在数据库里存图片2.7 字段类军规小结\n用好数值字段类型\n将字符转化为数字\n优先使用枚举 ENUM&#x2F;SET\n避免使用 NULL 字段\n少用幵拆分 TEXT&#x2F;BLOB\n不在数据库里存图片\n\n三、索引类军规(5)3.1 谨慎合理添加索引\n谨慎合理添加索引\n\n改善查询\n减慢更新\n索引不是赹多赹好\n\n\n能不加的索引尽量不加\n\n综合评估数据密度和数据分布\n最好不赸过字段数 20%\n\n\n结合核心 SQL 优先考虑覆盖索引\n\n举例\n\n不要给“性别”列创建索引\n\n\n\n3.2 字符字段必须建前缀索引\n区分度\n\n单字母区分度:26\n4 字母区分度:26_26_26*26&#x3D;456,976\n5 字母区分度:26_26_26_26_26&#x3D;11,881,376\n6 字母区分度:26_26_26_26_26*26&#x3D;308,915,776\n\n\n字符字段必须建前缀索引:\n\n\n(\n`pinyin` varchar(100) DEFAULT NULL COMMENT '小区拼音', KEY `idx_pinyin` (`pinyin`(8)),\n) ENGINE=InnoDB\n\n3.3 不在索引列做运算\n不在索引列进行数学运算或凼数运算\n\n无法使用索引\n导致全表扫描\n\n\n举例:\n\n\nBAD: SELECT * from table WHERE to_days(current_date) – to_days(date_col) &lt;= 10\nGOOD: SELECT * from table WHERE date_col >= DATE_SUB('2011-10- 22',INTERVAL 10 DAY);\n\n3.4 自增列或全局 ID 做 INNODB 主键\n对主键建立聚簇索引\n二级索引存储主键值\n主键不应更新修改\n按自增顺序揑入值\n忌用字符串做主键\n聚簇索引分裂\n推荐用独立亍业务的 AUTO_INCREMENT 列或全局 ID 生成 器做代理主键\n若不指定主键，InnoDB 会用唯一且非空值索引代替\n\n3.5 尽量不用外键\n线上 OLTP 系统(线下系统另论)\n\n外键可节省开发量\n有额外开销\n逐行操作\n可’到达’其它表，意味着锁\n高并发时容易死锁\n\n\n由程序保证约束\n\n\n3.6 索引类军规小结\n谨慎合理添加索引\n字符字段必须建前缀索引\n不在索引列做运算\n自增列或全局 ID 做 INNODB 主键\n尽量不用外键\n\n四、SQL 类军规(15)4.1 SQL 语句尽可能简单\n大 SQL VS 多个简单 SQL\n\n传统设计思想\nBUT MySQL NOT\n一条 SQL 叧能在一个 CPU 运算\n5000+ QPS 的高幵发中，1 秒大 SQL 意味着?\n可能一条大 SQL 就把整个数据库堵死\n\n\n拒绝大 SQL，拆解成多条简单 SQL\n\n简单 SQL 缓存命中率更高\n减少锁表时间，特别是 MyISAM\n用上多 CPU\n\n\n\n4.2 保持事务(连接)短小\n保持事务&#x2F;DB 连接短小精悍\n\n事务&#x2F;连接使用原则:即开即用，用完即关\n与事务无关操作放到事务外面, 减少锁资源的占用\n不破坏一致性前提下，使用多个短事务代替长事务\n\n\n举例\n\n发贴时的图片上传等待\n大量的 sleep 连接\n\n\n\n4.3 尽可能避免使用 SP&#x2F;TRIG&#x2F;FUNC\n线上 OLTP 系统(线下库另论)\n\n尽可能少用存储过程\n尽可能少用触发器\n减用使用 MySQL 凼数对结果进行处理\n\n\n由客户端程序负责\n\n\n4.4 尽量不用 SELECT\n用 SELECT * 时\n更多消耗 CPU、内存、IO、网络带宽\n先向数据库请求所有列，然后丢掉不需要列?\n尽量不用 SELECT * ，叧取需要数据列 • 更安全的设计:减少表变化带来的影响\n为使用 covering index 提供可能性\nSELECT&#x2F;JOIN 减少硬盘临时表生成，特别是有 TEXT&#x2F;BLOB 时\n举例:\n\nSELECT * FROM tag WHERE id = 999184;\nSELECT keyword FROM tag WHERE id = 999184;\n\n4.5 改写 OR 为 IN()\n同一字段，将 or 改写为 in()\nOR 效率:O(n)\nIN 效率:O(Log n)\n当 n 很大时，OR 会慢很多\n注意控制 IN 的个数，建议 n 小亍 200\n举例:\n\nSELECT * from opp WHERE phone='12347856' or phone='42242233' \\G;\nSELECT * from opp WHERE phone in ('12347856' , '42242233');\n\n4.6 改写 OR 为 UNION\n不同字段，将 or 改为 union\n减少对不同字段进行 “or” 查询\nMerge index 往往很弱智\n如果有足够信心:set global optimizer_switch&#x3D;’index_merge&#x3D;off’;\n举例:\n\nSELECT * from opp WHERE phone='010-88886666' or cellPhone='13800138000';\nSELECT * from opp WHERE phone='010-88886666' union SELECT * from opp WHERE cellPhone='13800138000';\n\n4.7 避免负向查询和% 前缀模糊查询\n避免负向查询\n\nNOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、 NOT LIKE 等\n\n\n避免 % 前缀模糊查询\n\nB+ Tree\n使用不了索引\n导致全表扫描\n\n\n举例:\n\n\nSELECT * from post WHERE title like '北京%'; -- 298 rows in set (0.01 sec)\nSELECT * from post WHERE title like '%北京%'; -- 572 rows in set (3.27 sec)\n\n4.8 COUNT(*)的几个例子\n几个有趣的例子:\n\nCOUNT(COL) VS COUNT(*)\nCOUNT(*) VS COUNT(1)\nCOUNT(1) VS COUNT(0) VS COUNT(100)\n\n\n示例:\n\n\n`id` int(10) NOT NULL AUTO_INCREMENT COMMENT '公司的id', `sale_id` int(10) unsigned DEFAULT NULL,\n\n\n结论\n\nCOUNT(*)&#x3D;count(1)\n\n\n\n*COUNT(0)&#x3D;count(1)\n\nCOUNT(1)&#x3D;count(100)\nCOUNT(*)!&#x3D;count(col)\nWHY?\n\n4.9 减少 COUNT(*)\nMyISAM VS INNODB\n\n不带 WHERE COUNT()\n带 WHERE COUNT()\n\n\nCOUNT(*)的资源开销大，尽量不用少用\n\n计数统计\n\n实时统计:用 memcache，双向更新，凌晨 跑基准\n非实时统计:尽量用单独统计表，定期重算\n\n\n\n4.10 LIMIT 高效分页\n传统分页:\n\nSELECT * from table limit 10000,10;\n\n\nLIMIT 原理:\n\nLimit 10000,10  偏秱量赹大则赹慢\n\n\n推荐分页:\n\nSELECT * from table WHERE id&gt;&#x3D;23423 limit 11;\n\n\n\n_SELECT _ from table WHERE id&gt;&#x3D;23434 limit 11;\n\n分页方式二:\n\nSELECT * from table WHERE id &gt;&#x3D; ( SELECT id from table limit 10000,1 ) limit 10;\n\n\n分页方式三:\n\nSELECT * FROM table INNER JOIN (SELECT id FROM table LIMIT 10000,10) USING (id);\n\n\n分页方式四:\n\n程序取 ID:SELECT id from table limit 10000,10;\nSELECT * from table WHERE id in (123,456…);\n\n\n可能需按场景分析幵重组索引\n\n示例:\n\n\nMySQL> SELECT sql_no_cache * from post limit 10,10; 10 row in set (0.01 sec)\nMySQL> SELECT sql_no_cache * from post limit 20000,10; 10 row in set (0.13 sec)\nMySQL> SELECT sql_no_cache * from post limit 80000,10; 10 rows in set (0.58 sec)\nMySQL> SELECT sql_no_cache id from post limit 80000,10; 10 rows in set (0.02 sec)\nMySQL> SELECT sql_no_cache * from post WHERE id>=323423 limit 10; 10 rows in set (0.01 sec)\nMySQL> SELECT * from post WHERE id >= ( SELECT sql_no_cache id from post limit 80000,1 ) limit 10; 10 rows in set (0.02 sec)\n\n4.11 用 UNION ALL 而非 UNION\n若无需对结果进行去重，则用 UNION ALL\n\nUNION 有去重开销\n\n\n举例:\n\n\nSELECT * FROM detail20091128 UNION ALL SELECT * FROM detail20110427 UNION ALL SELECT * FROM detail20110426 UNION ALL SELECT * FROM detail20110425 UNION ALL SELECT * FROM detail20110424 UNION ALL SELECT * FROM detail20110423;\n\n4.12 分解联接保证高并发\n高幵发 DB 不建议进行两个表以上的 JOIN\n\n适当分解联接保证高幵发\n\n可缓存大量早期数据\n使用了多个 MyISAM 表\n对大表的小 ID IN()\n联接引用同一个表多次\n举例:\n\n\n\nMySQL> SELECT * from tag JOIN post on tag_post.post_id=post.id WHERE tag.tag='二手玩具';\n\nMySQL> SELECT * from tag WHERE tag='二手玩具';\nMySQL> SELECT * from tag_post WHERE tag_id=1321;\nMySQL> SELECT * from post WHERE post.id in (123,456,314,141);\n\n4.13 GROUP BY 去除排序\nGROUP BY 实现\n\n分组\n自劢排序\n\n\n无需排序:Order by NULL\n\n特定排序:Group by DESC&#x2F;ASC\n\n举例:\n\n\nMySQL> SELECT phone,count(*) from post group by phone limit 1 ; 1 row in set (2.19 sec)\nMySQL> SELECT phone,count(*) from post group by phone order by null limit 1; 1 row in set (2.02 sec)\n\n4.14 同数据类型的列值比较\n原则:数字对数字，字符对字符\n\n数值列不字符类型比较\n\n同时转换为双精度\n进行比对\n\n\n字符列不数值类型比较\n\n字符列整列转数值\n不会使用索引查询\n\n\n举例:字符列不数值类型比较\n\n\n字段:`remark` varchar(50) NOT NULL COMMENT '备注, 默认为空',\n\nMySQL>SELECT `id`, `gift_code` FROM gift WHERE `deal_id` = 640 AND remark=115127; 1 row in set (0.14 sec)\nMySQL>SELECT `id`, `gift_code` FROM pool_gift WHERE `deal_id` = 640 AND remark='115127'; 1 row in set (0.005 sec)\n\n4.15 Load data 导数据\n批量数据快导入:\n\n成批装载比单行装载更快，不需要每次刷新缓存\n无索引时装载比索引装载更快\nInsert values ,values，values 减少索引刷新\nLoad data 比 insert 快约 20 倍\n\n\n尽量不用 INSERT … SELECT\n\n延迟\n同步出错\n\n\n\n4.16 打散大批量更新\n大批量更新凌晨操作，避开高峰\n凌晨不限制\n白天上限默认为 100 条&#x2F;秒(特殊再议)\n举例:\n\nupdate post set tag=1 WHERE id in (1,2,3); sleep 0.01;\nupdate post set tag=1 WHERE id in (4,5,6); sleep 0.01;\n......\n\n4.17 Know Every SQL\nSHOW PROFILE\nMySQLdumpslow\nEXPLAIN\nShow Slow Log\nSHOW QUERY_RESPONSE_TIME(Percona)\nMySQLsla\nShow Processlist\n\n4.18 SQL 类军规小结\nSQL 语句尽可能简单\n保持事务(连接)短小\n尽可能避免使用 SP&#x2F;TRIG&#x2F;FUNC\n尽量不用 SELECT *\n改写 OR 语句\n避免负向查询和% 前缀模糊查询\n减少 COUNT(*)\nLIMIT 的高效分页\n用 UNION ALL 而非 UNION\n分解联接保证高幵发\nGROUP BY 去除排序\n同数据类型的列值比较\nLoad data 导数据\n打散大批量更新\nKnow Every SQL!\n\n五、约定类军规(5)5.1 隔离线上线下\n构建数据库的生态环境\n\n开发无线上库操作权限\n\n原则:线上连线上，线下连线下\n\n实时数据用 real 库\n模拟环境用 sim 库\n测试用 qa 库\n开发用 dev 库\n\n\n\n5.2 禁止未经 DBA 确认的子查询\nMySQL 子查询\n\n大部分情况优化较差\n特别 WHERE 中使用 IN id 的子查询  一般可用 JOIN 改写\n\n\n举例:\n\n\nSELECT * from table1 where id id from table2) in (SELECT insert into table1 (SELECT * from table2); -- 可能导致复制异常\n\n5.3 永远不在程序端显式加锁\n永远不在程序端对数据库显式加锁\n\n外部锁对数据库不可控\n高并发发时是灾难\n极难调试和排查\n\n\n并发扣款等一致性问题\n\n采用事务\n相对值修改\nCommit 前二次较验冲突\n\n\n\n5.4 统一字符集为 UTF8\n字符集:\n\nMySQL 4.1 以前叧有 latin1\n为多语言支持增加多字符集\n也带来了 N 多问题\n保持简单\n\n\n统一字符集:UTF8\n\n校对规则:utf8_general_ci\n\n乱码:SET NAMES UTF8\n\n\n5.5 统一命名规范\n库表等名称统一用小写\n\nLinux VS Windows\nMySQL 库表大小写敏感\n字段名的大小写不敏感\n\n\n索引命名默认为“idx_字段名”\n\n库名用缩写，尽量在 2~7 个字母\n\nDataSharing &#x3D;&#x3D;&gt; ds\n\n\n注意避免用保留字命名\n\n……\n\n\n5.6 注意避免用保留字命名\n举例:\n\nSELECT * from return;\nSELECT * from `return`;\n\nMySQL系统关键字\n\nADD\nALL\nALTER GOTO\nGRANT\nGROUP\nPURGE\nRAID0\nRANGE\nANALYZE\nAND\nAS HAVING\nHIGH_PRIORIT Y\nHOUR_MICROSEC OND\nREAD\nREADS\nREAL\nASC\nASENSITIVE\nBEFORE HOUR_MINUTE\nHOUR_SECON D\nIF\nREFERENCES\nREGEXP\nRELEASE\nBETWEEN\nBIGINT\nBINARY IGNORE\nIN\nINDEX\nRENAME\nREPEAT\nREPLACE\nBLOB\nBOTH\nBY INFILE\nINNER\nINOUT\nREQUIRE\nRESTRICT\nRETURN\nCALL\nCASCADE\nCASE INSENSITIVE\nINSERT\nINT\nREVOKE\nRIGHT\nRLIKE\nCHANGE\nCHAR\nCHARACTER INT1\nINT2\nINT3\nSCHEMA\nSCHEMAS\nSECOND_MICROSEC OND\nCHECK\nCOLLATE\nCOLUMN INT4\nINT8\nINTEGER\nSELECT\nSENSITIVE\nSEPARATOR\nCONDITION\nCONNECTION\nCONSTRAINT INTERVAL\nINTO\nIS\nSET\nSHOW\nSMALLINT\nCONTINUE\nCONVERT\nCREATE ITERATE\nJOIN\nKEY\nSPATIAL\nSPECIFIC\nSQL\nCROSS\nCURRENT_DA TE\nCURRENT_TIM KEYS E\nKILL\nLABEL\nSQLEXCEPTION\nSQLSTATE\nSQLWARNING\nCURRENT_TIMESTA MP\nCURRENT_US ER\nCURSOR LEADING\nLEAVE\nLEFT\nSQL_BIG_RESUL T\nSQL_CALC_FOUND_R OWS\nSQL_SMALL_RESULT\nDATABASE\nDATABASES\nDAY_HOUR LIKE\nLIMIT\nLINEAR\nSSL\nSTARTING\nSTRAIGHT_JOIN\nDAY_MICROSECON D\nDAY_MINUTE\nDAY_SECOND LINES\nLOAD\nLOCALTIME\nTABLE\nTERMINATED\nTHEN\nDEC\nDECIMAL\nDECLARE LOCALTIMESTAMP\nLOCK\nLONG\nTINYBLOB\nTINYINT\nTINYTEXT\nDEFAULT\nDELAYED\nDELETE LONGBLOB\nLONGTEXT\nLOOP\nTO\nTRAILING\nTRIGGER\nDESC\nDESCRIBE\nDETERMINISTI LOW_PRIORITY C\nMATCH\nMEDIUMBLOB\nTRUE\nUNDO\nUNION\nDISTINCT\nDISTINCTROW\nDIV MEDIUMINT\nMEDIUMTEXT\nMIDDLEINT\nUNIQUE\nUNLOCK\nUNSIGNED\nDOUBLE\nDROP\nDUAL\nMINUTE_MICROSECO ND\nMINUTE_SECO ND\nMOD\nUPDATE\nUSAGE\nUSE\nEACH\nELSE\nELSEIF MODIFIES\nNATURAL\nNOT\nUSING\nUTC_DATE\nUTC_TIME\nENCLOSED\nESCAPED\nEXISTS\nNO_WRITE_TO_BINL OG\nNULL\nNUMERIC\nUTC_TIMESTAM P\nVALUES\nVARBINARY\nEXIT\nEXPLAIN\nFALSE ON\nOPTIMIZE\nOPTION\nVARCHAR\nVARCHARACTER\nVARYING\nFETCH\nFLOAT\nFLOAT4 OPTIONALLY\nOR\nORDER\nWHEN\nWHERE\nWHILE\nFLOAT8\nFOR\nFORCE OUT\nOUTER\nOUTFILE\nWITH\nWRITE\nX509\nFOREIGN\nFROM\nFULLTEXT PRECISION\nPRIMARY\nPROCEDURE\nXOR\nYEAR_MONTH\nZEROFILL\n\n5.7 约定类军规小结\n隔离线上线下\n禁止未经 DBA 确认的子查询上线\n永远不在程序端显式加锁\n统一字符集为 UTF8\n统一命名规范\n\n六、原文链接\nhttp://weibo.com/wushizhan\n\n","slug":"MySQL/MySQL数据库开发的三十六条军规","date":"2022-02-26T03:37:18.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"d8253a8b0f6101721f69eb1f7316985f","title":"Mybatis一级缓存导致的内存溢出","content":"\n\n\n\n\n\n\n\n\n接上篇 Druid 监控导致的内存溢出问题定位处理 JVM 内存溢出相关，废话不多说直接上分析过程。\n\n\n1、服务器内存快照分析  首先通过快照查看最大的二十个对象如下图：  \n根据反馈数据可以发现前十个对象大小基本差不多，猜测应该由一个问题导致，点击去进一步定位问题。\n2、定位引起内存溢出的关键对象  发现引起内存溢出的对象很明确为 mybatis 的 PerpetualCache 对象：    \n3、分析引起内存溢出的原因\n猜测溢出\nPerpetualCache 其实是 Mybatis 的一级缓存对象，且全部为 HashMap 类型对象，所以可以大胆猜测是由于 Mybatis 一级缓存不正确使用造成的，敢于如此猜测是因为：\nMyBatis 对会话（Session）级别的一级缓存设计的比较简单，就简单地使用了 HashMap 来维护，并没有对 HashMap 的容量和大小进行限制。\n所以如果我们一直使用某一个 SqlSession 对象查询数据，这样会不会导致 HashMap 太大，而导致 java.lang.OutOfMemoryError 错误？\n\n\n\n验证溢出\nMybatis 的一级缓存是事务级别的，一旦事务提交就会清空。因此可能该线程的事务一直未结束和提交。那就从一个拥有大量查询业务繁杂的功能入手验证，结合二阶段定位到的零星线索，发现服务器内存溢出时正在处理的业务是数据下发，那我们就以次为入手点验证：\nA.首先设置 JVM 参数，为了尽快实现内存溢出效果，设定一个合适的参数，可根据本地环境调整：\n-server -XX:PermSize=256M -XX:MaxPermSize=256m\n-Xms300M -Xmx300M\n-Dcom.sun.management.jmxremote.port=8999\n-Dcom.sun.management.jmxremote.ssl=false\n-Dcom.sun.management.jmxremote.authenticate=false\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n\nB.开启 Jvisualvm 监控，应用中开启下发业务，获取监控数据：\n如下图所示可以看到，本地程序在运行一段时间后已经处于假死状态，GC 回收活动频繁，可堆内存基本未见有效回收，CPU 过山车式的起伏，很快内存溢出了，至此可以得出结论我们找对了入手点：\n\n\n\n\n\n修改溢出\n加断点分析下发业务发现，下发业务存在大量 for 循环引发大量数据库查询操作，且该操作参数不重复，也就导致了 Mybatis 的一级缓存一直无法命中，所以正好验证我们的猜测，在一次下发请求中 Mybatis 创建了海量的缓存数据，改部分数据在下发业务完成之前是无法释放的，占用了大量的内存资源，如果此时刚好服务器内存有限很容易引发 GC overhead limit exceded 错误，进而造成服务假死内存溢出：\n\n\n\n  结合项目实际情况针对一级缓存的可利用率实在过低，由于参数一直变动，缓存命中几率极低，从 MyBatis 一级缓存来看，它以单纯的 HashMap 做缓存，没有容量控制，而一次 SqlSession 中通常来说并不会有大量的查询操作，因此只适用于一次 SqlSession，且项目中已开启二级缓存，所以我们考虑修改一级缓存规则：\n  &lt;!-设置一级缓存模式为STATEMENT，默认为SESSION，SESSION为会话级别，STATEMENT为SQL级别-&gt;\n&lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;STATEMENT&quot;&#x2F;&gt;\n&lt;!-PS：一级缓存的范围有SESSION和STATEMENT两种，默认是SESSION，如果我们不需要使用一级缓存，那么我们可以把一级缓存的范围指定为STATEMENT，这样每次执行完一个Mapper语句后都会将一级缓存清除。如果需要更改一级缓存的范围，请在Mybatis的配置文件中，在&lt;settings&gt;下通过localCacheScope指定。-&gt;\n\n\n\n再次验证\n启动项目，开启下发业务，打开监控，效果如下：\n\n\n\n  818 家门店下发业务正常完成，期间堆内存回收稳定，无溢出情况出现（坡度较陡是因为本地 JVM 内存设置较低，为提高内存利用率，GC 回收频繁）。\n4、总结\n疑问：既然一级缓存会导致内存溢出，为什么 Mybatis 还如此设计？\nMyBatis 这样设计也有它自己的理由：\n\n\n\n\n\n\n\n\n\na.一般而言 SqlSession 的生存时间很短。一般情况下使用一个 SqlSession 对象执行的操作不会太多，执行完就会消亡；\n\n\n\n\n\n\n\n\n\nb.对于某一个 SqlSession 对象而言，只要执行 update 操作（update、insert、delete），都会将这个 SqlSession 对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响 JVM 内存空间的问题；\n\n\n\n\n\n\n\n\n\nc.可以手动地释放掉 SqlSession 对象中的缓存。\n\n收获：Mybatis 一级缓存的存储流程\n\n\n\n\n\n\n\n\n\na.MyBatis 的一级缓存是 SqlSession 级别的，但是它并不定义在 SqlSessio 接口的实现类 DefaultSqlSession 中，而是定义在 DefaultSqlSession 的成员变量 Executor 中，Executor 是在 openSession 的时候被实例化出来的，它的默认实现为 SimpleExecutor。\n\n\n\n\n\n\n\n\n\nb.MyBatis 中的一级缓存，与有没有配置无关，只要 SqlSession 存在，MyBastis 一级缓存就存在，localCache 的类型是 PerpetualCache，它其实很简单，一个 id 属性+一个 HashMap 属性而已，id 是一个名为”localCache”的字符串，HashMap 用于存储数据，Key 为 CacheKey，Value 为查询结果。\n\n\n\n\n\n\n\n\n\nc.MyBatis 的一级缓存查询的时候默认都是会先尝试从一级缓存中获取数据的，即想每次查询都走 DB 也行，将&lt;select&gt;标签中的 flushCache 属性设置为 true 即可，这意味着每次查询的时候都会清理一遍 PerpetualCache，PerpetualCache 中没数据，自然只能走 DB。\n\n\n","slug":"Java/Mybatis一级缓存导致的内存溢出","date":"2018-09-29T12:06:29.000Z","categories_index":"JAVA","tags_index":"JVM,OOM,Mybatis","author_index":"Anchor"},{"id":"9736882d32005a945dbd1b55fb5920ee","title":"Druid监控导致的内存溢出问题定位处理","content":"0、起因  一台部署于商户私有云中的应用频繁宕机，经查为 OOM，周期大约一周一次，较规律，所谓千里之堤毁于蚁穴，初步怀疑是轻微的内存泄漏不断积累导致的内存溢出，所以再次宕机出现时果断 dump 内存镜像开始分析\n1、内存溢出原理\n常见内存溢出：\n相信通过写 java 程序讨生活的人对内存溢出并不陌生，先看三张图：\n\n\n\nHeap space（堆空间）\n\nPermgen（永久代）\n\n元空间（Metaspace）\n\nJVM 内存模型\n\n\n  Java 应用程序在启动时会指定所需要的内存大小，它被分割成两个不同的区域：Heap space（堆空间）和Permgen（永久代）。\n  java.lang.OutOfMemoryError\n\n  正如字面意思，当应用程序试图向这两个空间添加更多的数据，但却没有足够的空间来容纳这些数据时，将会触发java.lang.OutOfMemoryError。\n\n内存溢出原因分析\n1、java.lang.OutOfMemoryError: PermGen space\nPermGen space的全称是Permanent Generation space,是指内存的永久保存区域, 这块内存主要是被 JVM 存放 Class 和 Meta 信息的,Class 在被 Load 时就会被放到PermGen space中, 同时 GC(Garbage Collection)不会在主程序运行期对 PermGen space进行清理。\n所以如果你的应用中有很多 CLASS 的话,就很可能出现 PermGen space 错误。\n通过上面的描述就可以得出：如果要加载的 class 与 jar 文件大小超过-XX:MaxPermSize 就有可能会产生 java.lang.OutOfMemoryError: PermGen space 。\n换句话说-XX:MaxPermSize 的大小要超过 class 与 jar 的大小。\n2、java.lang.OutOfMemoryError: Java heap space\n虽然各种 java 虚拟机的实现机制不一,但是heap space内存溢出产生的原因相同：那就是堆内存不够虚拟机分配了。\n由于内存的分配机制与 GC 是有联系的，也就是说内存不够用时有部分内存 GC 肯定无法释放，而我们要找的就是为什么 GC 释放不了堆内存。\n所以当产生heap space内存溢出时，堆内存中对象数量过多的就可能是问题的根源了。例外的情况是，程序确实需要那么多内存，这时就要考虑增大堆内存。\n\n\n2、内存溢出时应该做什么\n收集案发现场数据，尽快恢复系统\n获取内存快照，根据适用场景有以下三种方式：\n1、使用 jmap 命令在案发现场手动生成 dump 文件\njmap -dump:format=b,file=heap.dump \\`pid of java\\`\n2、使用 JVM 参数自动在案发当场获取 dump 文件\n-XX:+HeapDumpOnOutOfMemoryError\n3、使用其它工具获取 dump 文件，主要针对本地开发环境：\n分析 Heap Dump 的工具都可以获取 Heap Dump 文件。比如：jdk 自带的工具 jvisualvm。其它工具：Eclipse memory analyzer（jmat）、JProfiler 等。\n\n本地复现之 jvisualvm 的使用\n无论是为了再现案发场景还是验证修复效果，都需要我们在本地环境中监控 JVM 的运行情况，SO 以我熟悉的jvisualvm为例，简单说下使用方法\n\n\n\n\n\n\n\n\n\nVisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。（摘自官方）简单说来，VisualVM 是一种集成了多个 JDK 命令行工具的可视化工具，它能为您提供强大的分析能力。所有这些都是免费的！它囊括的命令行工具包括 jstat, JConsole, jstack, jmap 和 jinfo，这些工具与 JDK 的标准版本是一致的。 可以使用 VisualVM 生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析。尽管 VisualVM 自身要在 JDK6 这个版本上运行，但是 JDK1.4 以上版本的程序它都能监控。VisualVM 的一个最大好处就是，它已经在你的 JDK bin 目录里了，只要你使用的是 JDK1.6 Update7 之后的版本。点击一下 jvisualvm.exe 图标它就可以运行了，也可以终端或者 CMD 中使用 jvisualvm 命令启动。\nJvisualvm 本地联调的两种常用方法：\n1、Jvisualvm与IDEA集成，Intelij Idea -&gt; Preferences -&gt; Plugins -&gt;Browers Repositrories，搜索visualvm，选择install：安装成功后会添加visualvm的启动选项，启动 Tomcat 的同时会打开一个VisualVM的窗口。\n\n2、不通过插件直接启动，与本地 Tomcat 联调，需要配置一下 Tomcat，添加参数：\n-Dcom.sun.management.jmxremote.port&#x3D;8999\n-Dcom.sun.management.jmxremote.ssl&#x3D;false\n-Dcom.sun.management.jmxremote.authenticate&#x3D;false\n\n3、自造案发现场\n\n\n\n\n\n\n\n\n为了快速验证我们的工具以及加深对 OOM 的理解，我们自造几种内存溢出场景，代码我已准备妥当，可以直接复制运行验证，开始前记得根据示例调整 JVM 参数~\n\nPermGen OOM\n/**\n * @program: jvisualvmDemo\n * @description: jdk1.7永久区内存溢出\n * -XX:MaxPermSize=5m\n * -XX:+HeapDumpOnOutOfMemoryError\n * -XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n * @author: Anchor\n * @create: 2018-07-31\n **/\npublic class PermGenOOM &#123;\n    public static void main(String[] args) &#123;\n        while (true) &#123;\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(MetaOOM.OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() &#123;\n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;\n                    return proxy.invokeSuper(obj, args);\n                &#125;\n            &#125;);\n            //无限创建动态代理，生成Class对象\n            enhancer.create();\n        &#125;\n    &#125;\n    static class OOMObject &#123;\n\n    &#125;\n&#125;\n\n\nMetaOOM\n/**\n * @program: jvisualvmDemo\n * @description: 方法区内存异常\n * -XX:MetaspaceSize=8m\n * -XX:MaxMetaspaceSize=8m\n * -XX:+HeapDumpOnOutOfMemoryError\n * -XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n * @author: Anchor\n * @create: 2018-07-27\n **/\npublic class MetaOOM &#123;\n\n    public static void main(String[] args) &#123;\n        while (true) &#123;\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() &#123;\n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;\n                    return proxy.invokeSuper(obj, args);\n                &#125;\n            &#125;);\n            //无限创建动态代理，生成Class对象\n            enhancer.create();\n        &#125;\n    &#125;\n\n    static class OOMObject &#123;\n\n    &#125;\n&#125;\n\nHeapOOM\n/**\n * @program: jvisualvmDemo\n * @description: 堆内存异常\n * VM Args:\n *     //这两个参数保证了堆中的可分配内存固定为20M\n *     -Xms20m\n *     -Xmx20m\n *     -XX:+HeapDumpOnOutOfMemoryError\n *     -XX:HeapDumpPath=/Users/anchor/Downloads/dump/\n * @author: Anchor\n * @create: 2018-07-27\n **/\npublic class HeapOOM &#123;\n    //创建一个内部类用于创建对象使用\n    static class OOMObject &#123;\n    &#125;\n    public static void main(String[] args) &#123;\n        List&lt;OOMObject> list = new ArrayList&lt;OOMObject>();\n        //无限创建对象，在堆中\n        while (true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n&#125;\n\nJavaVMStackSOF\n/**\n * @program: jvisualvmDemo\n * @description: 栈内存异常\n * VM Args：\n *     //设置栈容量为160K，默认1M\n *    -Xss160k\n * @author: Anchor\n * @create: 2018-07-27\n **/\npublic class JavaVMStackSOF &#123;\n    private int stackLength = 1;\n    public void stackLeak() &#123;\n        stackLength++;\n        //递归调用，触发异常\n        stackLeak();\n    &#125;\n\n    public static void main(String[] args) throws Throwable &#123;\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try &#123;\n            oom.stackLeak();\n        &#125; catch (Throwable e) &#123;\n            System.out.println(\"stack length:\" + oom.stackLength);\n            throw e;\n        &#125;\n    &#125;\n&#125;\n\n4、案例分析\n\n\n\n\n\n\n\n\n啰里啰嗦这么终于要进入正题了 😹\n\n准备环境，测试脚本\n根据本地机器性能配置 JVM 参数：\n-server -XX:PermSize&#x3D;256M -XX:MaxPermSize&#x3D;256m -Xms300M -Xmx300M\n-Dcom.sun.management.jmxremote.port&#x3D;8999\n-Dcom.sun.management.jmxremote.ssl&#x3D;false\n-Dcom.sun.management.jmxremote.authenticate&#x3D;false\n\n准备测试脚本：\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom multiprocessing import Process,Pool\nimport os,time\nimport requests\n\ndef run_proc(name):\n    for i in range(30000):\n        postdata = &#123;'code': i&#125;\n        r = requests.post(\"http://localhost:8080/OOM.do\", data=postdata)\n\nif __name__ =='__main__':\n    print('Run the main process (%s).' % (os.getpid()))\n    mainStart = time.time()\n    p = Pool(8)\n    for i in range(16):\n        p.apply_async(run_proc,args=('Process'+str(i),))\n\n    print('Waiting for all subprocesses done ...')\n    p.close()\n    p.join()\n    print('All subprocesses done')\n    mainEnd = time.time()\n    print ('All process ran %0.2f seconds.' % (mainEnd-mainStart))\n\n内存快照分析\n快照导入 visualvm，简单翻了一下很快发现问题，内存中存在大量 SQL 片段未回收，如图：\n\n为何内存会被大量 SQL 片段占领，莫非？？？果断开启断言（瞎猜）模式，我们要复现问题！\n\n\n\n\n\n\n\n\n\n假设 A：使用了静态变量定义 SQL 片段，导致资源未回收翻代码确认，发现 SQL 使用 String 对象拼接，非静态变量，但是该 SQL 进行了上百次的拼接必然造成资源浪费加重 GC 负担,有优化空间改 StringBuild，测试之。\n脚本跑起来~ Emm~~ 貌似没啥效果\n\n\n\n\n\n\n\n\n\n假设 B：连接池不够用？\n翻代码确认，发现配置正常，改小连接池大小，测试之，无效。\n\n\n\n\n\n\n\n\n\n假设 C：数据库有死锁？\n但是与运维确认每次内存溢出只需重启应用即可恢复，数据库无需操作，PASS\n\n\n\n\n\n\n\n\n\n假设 D：。。。。。\n\n\n\n\n\n\n\n\n\n假设 X：难道 Druid 连接池会导致内存溢出？\n检查 Druid 配置，发现代码中除了使用了连接池还配置了 SQL 监控，URL 监控，那么监控数据存储在哪里了？难道默认是内存中？百度 Google 无果，直接动手压测，模拟 50W 请求，得到如下数据：成功的看到了内存溢出。\n\n对比生产机内存快照，发现有戏！组成结果基本一致，可是没道理啊，难度 Druid 还有这种大坑？不行不敢确定，那么我们反向验证下，如果我关掉 Druid 的监控呢？说干就干，再跑 50W 请求：\n\n欧克，果然有点意思，OOM 消失了(๑•̀ㅂ•́)و✧\n既然问题找到了，那么就要分析为啥会出现这种大坑，先从官网入手，翻下 Druid 的 lssues 发现竟然有前辈已经问过该类问题\n\nbut，官方并未回复，那么看起来这个问题太 low？\nEmm…. 那自己研究下好了\n\n进一步扩展\n翻阅官方文档， 在 SQL 合并配置 ，发现如下内容：\n\n\n\n\n\n\n\n\n\n当你程序中存在没有参数化的 sql 执行时，sql 统计的效果会不好。比如：select _ from t where id &#x3D; 1select _ from t where id &#x3D; 2select _ from t where id &#x3D; 3在统计中，显示为 3 条 sql，这不是我们希望要的效果。StatFilter 提供合并的功能，能够将这 3 个 SQL 合并为如下的 SQLselect _ from t where id &#x3D; ?\n问题到此已经基本明了，不规范的入参导致StatFilter未能成功合并 SQL，Druid 成功记录了所有的执行语句。。。。。。。\n大家可以自行体会下这两种写法的区别：\n\n\n\n5、内存溢出排查总结\n\n\n\n\n\n\n\n\n导致 OutOfMemoryError 异常的常见原因有以下几种：\n   - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；\n   - 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；\n   - 代码中存在死循环或循环产生过多重复的对象实体；\n   - 使用的第三方软件中的BUG；\n   - 启动参数内存值设定的过小；\n   - 编码不规范的隐患；\n\n","slug":"Java/Druid监控导致的内存溢出问题定位处理","date":"2018-08-06T06:03:15.000Z","categories_index":"JAVA","tags_index":"JVM,OOM,Druid","author_index":"Anchor"},{"id":"1a07a30e4d12a51de2d9119320d5847f","title":"MySQL 主键设计盘点","content":"主键定义唯一标识表中每行的一个列（或一组列）称为主键。主键用来表示一个特定的行。\n主键设计和应用原则除了满足MySQL强制实施的规则（主键不可重复；一行中主键不可为空）之外，主键的设计和应用应当还遵守以下公认的原则：\n\n不更新主键列中的值；\n不重用主键列的值；\n不在主键列中使用可能会更改的值。（例如，如果使用一个 名字作为主键以标识某个供应商，当该供应商合并和更改其 名字时，必须更改这个主键。）\n\n主键生成策略自增ID使用数据库的自动增长（auto_increment），是比较简单和常见的ID生成方案，数据库内部可以确保生成id的唯一性。优点：1、数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利。2、 数字型，占用空间小，易排序，在程序中传递方便。缺点：1、不支持水平分片架构，水平分片的设计当中，这种方法显然不能保证全局唯一。2、对数据库有依赖，每种数据库可能实现不一样，数据库切换时候，涉及到代码的修改，不利于扩展结论：自增id做主键适用于非分布式架构。\nUUID| **UUID:通用唯一识别码（英语：Universally Unique Identifier，缩写：UUID）是用于计算机体系中以识别信息数目的一个128位标识符，还有相关的术语：全局唯一标识符（GUID）。 根据标准方法生成，不依赖中央机构的注册和分配，UUID具有唯一性，这与其他大多数编号方案不同。重复UUID码概率接近零，可以忽略不计。UUID是由一组32位数的16进制数字所构成,标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例：550e8400-e29b-41d4-a716-446655440000\n\n\n\n到目前为止业界一共有5种方式生成UUID，详情可见IETF发布的UUID规范**A Universally Unique IDentifier (UUID) URN Namespace\n\n\n\n优点：性能非常高：本地生成，没有网络消耗。缺点：1、不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。2、信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。3、ID作为主键时在特定的环境会存在一些问题，比如需要排序的时候——UUID是无序的。4、MySQL官方有明确的建议主键要尽量越短越好，36个字符长度的UUID不符合要求。5、对MySQL索引不利：作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。关于MySQL 使用自增ID主键和UUID 作为主键的性能比较可以查看参考【8】。结论：1、uuid做主键适用于小规模分布式架构用。2、在使用uuid作为主键的时候，最好设计createtime（创建时间）列和modifytime（修改时间）列以应付可能的排序等场景。\n自建的id生成器Twitter的snowflake算法Twitter的snowflake算法的核心把时间戳，工作机器id，序列号组合在一起。除了最高位bit标记为不可用以外，其余三组bit占位均可浮动，看具体的业务需求而定。默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。\n具体可以查看：github.com&#x2F;twitter-arc…** （但是最近一次的提交是6年前，显示已经停止了对初始版snowflake的支持）**源码如下：\npackage com.yjd.comm.util;/**\n* Created by pc on 2017/8/16 0016.\n*/\n\n/**\n* Twitter_Snowflake&lt;br>\n* SnowFlake的结构如下(每部分用-分开):&lt;br>\n* 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br>\n* 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br>\n* 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)\n* 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br>\n* 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br>\n* 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br>\n* 加起来刚好64位，为一个Long型。&lt;br>\n* SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。\n*/\npublic class SnowflakeIdWorker &#123;\n    \n    // ==============================Fields===========================================\n    /**\n    * 开始时间截 (2015-01-01)\n    */\n    private final long twepoch = 1420041600000L;\n    \n    /**\n    * 机器id所占的位数\n    */\n    private final long workerIdBits = 5L;\n    \n    /**\n    * 数据标识id所占的位数\n    */\n    private final long datacenterIdBits = 5L;\n    \n    /**\n    * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)\n    */\n    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);\n    \n    /**\n    * 支持的最大数据标识id，结果是31\n    */\n    private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);\n    \n    /**\n    * 序列在id中占的位数\n    */\n    private final long sequenceBits = 12L;\n    \n    /**\n    * 机器ID向左移12位\n    */\n    private final long workerIdShift = sequenceBits;\n    \n    /**\n    * 数据标识id向左移17位(12+5)\n    */\n    private final long datacenterIdShift = sequenceBits + workerIdBits;\n    \n    /**\n    * 时间截向左移22位(5+5+12)\n    */\n    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n    \n    /**\n    * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)\n    */\n    private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);\n    \n    /**\n    * 工作机器ID(0~31)\n    */\n    private long workerId;\n    \n    /**\n    * 数据中心ID(0~31)\n    */\n    private long datacenterId;\n    \n    /**\n    * 毫秒内序列(0~4095)\n    */\n    private long sequence = 0L;\n    \n    /**\n    * 上次生成ID的时间截\n    */\n    private long lastTimestamp = -1L;\n    \n    //==============================Constructors=====================================\n    \n    /**\n    * 构造函数\n    *\n    * @param workerId     工作ID (0~31)\n    * @param datacenterId 数据中心ID (0~31)\n    */\n    public SnowflakeIdWorker(long workerId, long datacenterId) &#123;\n        if (workerId > maxWorkerId || workerId &lt; 0) &#123;\n            throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", maxWorkerId));\n        &#125;\n        if (datacenterId > maxDatacenterId || datacenterId &lt; 0) &#123;\n            throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", maxDatacenterId));\n        &#125;\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n    &#125;\n    \n    // ==============================Methods==========================================\n    \n    /**\n    * 获得下一个ID (该方法是线程安全的)\n    *\n    * @return SnowflakeId\n    */\n    public synchronized long nextId() &#123;\n        long timestamp = timeGen();\n        \n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常\n        if (timestamp &lt; lastTimestamp) &#123;\n            throw new RuntimeException(\n                String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n        &#125;\n        \n        //如果是同一时间生成的，则进行毫秒内序列\n        if (lastTimestamp == timestamp) &#123;\n            sequence = (sequence + 1) &amp; sequenceMask;\n            //毫秒内序列溢出\n            if (sequence == 0) &#123;\n                //阻塞到下一个毫秒,获得新的时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            &#125;\n        &#125;\n        //时间戳改变，毫秒内序列重置\n        else &#123;\n            sequence = 0L;\n        &#125;\n        \n        //上次生成ID的时间截\n        lastTimestamp = timestamp;\n        \n        //移位并通过或运算拼到一起组成64位的ID\n        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) //\n            | (datacenterId &lt;&lt; datacenterIdShift) //\n            | (workerId &lt;&lt; workerIdShift) //\n            | sequence;\n    &#125;\n    \n    /**\n    * 阻塞到下一个毫秒，直到获得新的时间戳\n    *\n    * @param lastTimestamp 上次生成ID的时间截\n    * @return 当前时间戳\n    */\n    protected long tilNextMillis(long lastTimestamp) &#123;\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) &#123;\n            timestamp = timeGen();\n        &#125;\n        return timestamp;\n    &#125;\n    \n    /**\n    * 返回以毫秒为单位的当前时间\n    *\n    * @return 当前时间(毫秒)\n    */\n    protected long timeGen() &#123;\n        return System.currentTimeMillis();\n    &#125;\n    \n    //==============================Test=============================================\n    \n    /**\n    * 测试\n    */\n    public static void main(String[] args) &#123;\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(1, 1);\n        long startime = System.currentTimeMillis();\n        for (int i = 0; i &lt; 4000000; i++) &#123;\n            long id = idWorker.nextId();\n            //            System.out.println(Long.toBinaryString(id));\n            //            System.out.println(id);\n        &#125;\n        System.out.println(System.currentTimeMillis() - startime);\n    &#125;\n&#125;\n\n\n优点：1、毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。 2、 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。 3、可以根据自身业务特性分配bit位，非常灵活。缺点：强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。结论：用自建的id生成器做主键适用于大规模分布式架构\n","slug":"MySQL/MySQL主键设计盘点","date":"2022-02-23T05:32:16.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"6dd356025f124f190d32c47865445ac7","title":"MySQL 常用函数&数据类型","content":"MySQL 常用函数汇总字符串函数\n\n\n函数\n功能\n\n\n\nCONCAT(s1,s2,……)\n字符串连接\n\n\nINSERT(str,x,y,instr)\n将指定开始标记到结束的字符串替换为指定字符串\n\n\nLOWER(str)\n将字符串所有字符转为小写\n\n\nUPPER(str)\n将字符串所有字符串转为大写\n\n\nLEFT(str,x)\n返回字符串 str 最左边的 x 个字符\n\n\nRIGHT(str,x)\n返回字符串 str 最右边的 x 个字符\n\n\nLPAD(str,n,pad)\n在 str 最左边填充 n 个 pad\n\n\nRPAD(str,n,pad)\n在 str 最右边填充 n 个 pad\n\n\nLTRIM(str)\n去掉字符串 str 左侧的空格\n\n\nRTRIM(str)\n去掉字符串 str 右侧的空格\n\n\nREPEAT(str,x)\n返回 str 重复 x 次的结果\n\n\nSTRCMP(s1,s2)\n比较字符串 s1 和 s2\n\n\nREPLACE(str,a,b)\n用字符串 b 替换字符串 str 中所有出现的字符串 a\n\n\nTRIM(str)\n去掉字符串行尾和行头的空格\n\n\nSUBSTRING(str,x,y)\n返回从字符串 str x 位置起 y 个字符长度的字串\n\n\n数学函数\n\n\n函数\n功能\n\n\n\nABS(x)\n返回 x 的绝对值\n\n\nCEIL(x)\n返回大于 x 的最小整数值\n\n\nFLOOR(x)\n返回小于 x 的最大整数值\n\n\nMOD(x,y)\n返回 x&#x2F;y 的模\n\n\nRAND()\n返回 0～1 内的随机值\n\n\nROUND(x,y)\n返回参数 x 的四舍五入的有 y 位小数的值\n\n\nTRUNCATE(x,y)\n返回数字 x 截断位 y 位小数的结果\n\n\n日期和时间函数\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前的日期和时间\n\n\nUNIX_TIMESTAMP(date)\n返回日期 date 的 UNIX 时间戳\n\n\nFROM_UNIXTIME\n返回 UNIX 时间戳的日期值\n\n\nWEEK(date)\n返回日期 date 为一年中的第几周\n\n\nYEAR(date)\n返回日期 date 的年份\n\n\nHOUR(time)\n返回 time 的小时值\n\n\nMINUTE(time)\n返回 time 的分钟值\n\n\nMONTHNAME(date)\n返回 date 的月份名\n\n\nDATE_FORMAT(date,fmt)\n返回按字符串 fmt 格式日期 date 值\n\n\nDATE_ADD(date,interval expr type)\n返回一个日期或时间值加上一个时间间隔的时间值\n\n\nDATEDIFF(expr,expr2)\n返回起始时间 expr 和结束时间 expr2 之间的天数\n\n\n流程函数\n\n\n函数\n功能\n\n\n\nIF(value,t f)\n如果 value 是真，返回 t；否则返回 f\n\n\nIFNULL(value1,value2)\n如果 value1 不为空，返回 value1，否则返回 value2\n\n\nCASE WHEN [value1] THEN[result1]…ELSE[default]END\n如果 value1 是真，返回 result1，否则返回 result\n\n\nCASE[expr] WHEN [value1]THEN[result1]…ELSE[default]END\n如果 expr 等于 value1，返回 result1，否则返回 default\n\n\n其他常用函数\n\n\n函数\n功能\n\n\n\nDATEBASE()\n返回当前数据库名\n\n\nVERSION()\n返回当前数据库版本\n\n\nUSER()\n返回当前登录用户名\n\n\nINET_ATON(ip)\n返回 ip 地址的数字表示\n\n\nINET_NTOA(num)\n返回数字代表的 ip 地址\n\n\nPASSWORD(str)\n返回字符串 str 的加密版本\n\n\nMD5()\n返回字符串 str 的 md5 值\n\n\nMySQL 数据类型串数据类型\n\n\n数据类型\n说明\n\n\n\nCHAR\n1～255 个字符的定长串。它的长度必须在创建时指定，否则 MySQL 假定为 CHAR(1)\n\n\nENUM\n接受最多 64 K 个串组成的一个预定义集合的某个串\n\n\nLONGTEXT\n与 TEXT 相同，但最大长度为 4GB\n\n\nMEDIUMTEXT\n与 TEXT 相同，但最大长度为 16K\n\n\nSET\n接受最多 64 个串组成的一个预定义集合的零个或多个串\n\n\nTEXT\n最大长度为 64K 的变长文本\n\n\nTINYTEXT\n与 TEXT 相同，但最大长度为 255 字节\n\n\nVARCHAR\n长度可变，最多不超过 255 字节。如果在创建时指定为 VARCHAR(n)，则可存储 0 到 n 个字符的变长串（其中 n≤255）\n\n\n数值数据类型\n\n\n数据类型\n说明\n\n\n\nBIT\n位字段，1～64 位。（在 MySQL 5 之前，BIT 在功能上等价于 TINYINT\n\n\nBIGINT\n整数值，支持9223372036854775808～9223372036854775807（如果是 UNSIGNED，为 0～18446744073709551615）的数\n\n\nBOOLEAN（或 BOOL）\n布尔标志，或者为 0 或者为 1，主要用于开&#x2F;关（on&#x2F;off）标志\n\n\nDECIMAL（或 DEC）\n精度可变的浮点值\n\n\nDOUBLE\n双精度浮点值\n\n\nFLOAT\n单精度浮点值\n\n\nINT（或 INTEGER）\n整数值，支持2147483648～2147483647（如果是 UNSIGNED，为 0～4294967295）的数\n\n\nMEDIUMINT\n整数值，支持8388608～8388607（如果是 UNSIGNED，为 0～16777215）的数\n\n\nREAL\n4 字节的浮点值\n\n\nSMALLINT\n整数值，支持32768～32767（如果是 UNSIGNED，为 0～65535）的数\n\n\nTINYINT\n整数值，支持128～127（如果为 UNSIGNED，为 0～255）的数\n\n\n日期和时间数据类型\n\n\n数据类型\n说明\n\n\n\nDATE\n表示 1000-01-01～9999-12-31 的日期，格式为 YYYY-MM-DD\n\n\nDATETIME\nDATE 和 TIME 的组合\n\n\nTIMESTAMP\n功能和 DATETIME 相同（但范围较小）\n\n\nTIME\n格式为 HH:MM:SS\n\n\nYEAR\n用 2 位数字表示，范围是 70（1970 年）～69（2069 年），用 4 位数字表示，范围是 1901 年～2155 年\n\n\n二进制数据类型\n\n\n数据类型\n说明\n\n\n\nBLOB\nBlob 最大长度为 64KB\n\n\nMEDIUMBLOB\nBlob 最大长度为 16MB\n\n\nLONGBLOB\nBlob 最大长度为 4GB\n\n\nTINYBLOB\nBlob 最大长度为 255 字节\n\n\n","slug":"MySQL/MySQL常用函数汇总","date":"2022-02-23T05:32:16.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"87cebc6d905dece24636202906841487","title":"MySQL 数据库设计规范","content":"MySQL 数据库设计规范1. 规范背景与目的MySQL 数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用 MySQL 数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导 RD、QA、OP 等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL 编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。\n2. 设计规范2.1 数据库设计以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。\n对于不满足【高危】和【强制】两个级别的设计，DBA 会强制打回要求修改。\n2.1.1 一般命名规则\n【强制】使用小写，有助于提高打字速度，避免因大小写敏感而导致的错误。\n【强制】没有空格，使用下划线代替。\n【强制】名称中没有数字，只有英文字母。\n【强制】有效的可理解的名称。\n【强制】名称应该是自我解释的。\n【强制】名称不应超过 32 个字符。\n【强制】避免使用前缀。\n\n2.1.2 库\n【强制】遵守以上全部一般命名规则。 \n【强制】使用单数。 \n【强制】库的名称格式：业务系统名称_子系统名。 \n【强制】一般分库名称命名格式是库通配名_编号，编号从 0 开始递增，比如 northwind_001，以时间进行分库的名称格式是库通配名_时间。 \n【强制】创建数据库时必须显式指定字符集，并且字符集只能是 utf8 或者 utf8mb4。创建数据库 SQL 举例：  create database db_name default character set utf8;\n\n2.1.3 表\n【强制】遵守以上全部一般命名规则。\n【强制】使用单数。\n【强制】相关模块的表名与表名之间尽量体现 join 的关系，如 user 表和 user_login 表。\n【强制】创建表时必须显式指定字符集为 utf8 或 utf8mb4。\n【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为 InnoDB。当需要使用除 InnoDB&#x2F;MyISAM&#x2F;Memory 以外的存储引擎时，必须通过 DBA 审核才能在生产环境中使用。因为 InnoDB 表支持事务、行锁、宕机恢复、MVCC 等关系型数据库重要特性，为业界使用最多的 MySQL 存储引擎。而这是其它大多数存储引擎不具备的，因此首推 InnoDB。\n【强制】建表必须有 comment。\n【强制】关于主键：(1) 命名为 id，类型为 int 或 bigint，且为 auto_increment；(2) 标识表里每一行主体的字段不要设为主键，建议设为其它字段如 user_id，order_id等，并建立 unique key 索引。因为如果设为主键且主键值为随机插入，则会导致 InnoDB 内部 page 分裂和大量随机 I&#x2F;O，性能下降。\n【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段 create_time 和最后更新时间字段 update_time，便于排查问题。\n【建议】表中所有字段必须都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT 值。因为使用 NULL 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。\n【建议】建议对表里的 blob、text 等大字段，垂直拆分到其它表里，仅在需要读这些对象的时候才去 select。\n【建议】反范式设计：把经常需要 join 查询的字段，在其它表里冗余一份。如 username 属性在 user_account，user_login_log 等表里冗余一份，减少 join 查询。\n【强制】中间表用于保留中间结果集，名称必须以 tmp_ 开头。备份表用于备份或抓取源表快照，名称必须以 bak_ 开头。中间表和备份表定期清理。\n【强制】对于超过 100W 行的大表进行 alter table，必须经过 DBA 审核，并在业务低峰期执行。因为 alter table 会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。\n\n2.1.4 字段\n【强制】遵守以上全部一般命名规则。\n【建议】尽可能选择短的或一两个单词。\n【强制】避免使用保留字作为字段名称：order，date，name 是数据库的保留字，避免使用它。可以为这些名称添加前缀使其易于理解，如 user_name，signup_date 等。\n【强制】避免使用与表名相同的字段名，这会在编写查询时造成混淆。\n【强制】在数据库模式上定义外键。\n【强制】避免使用缩写或基于首字母缩写词的名称。\n【强制】外键列必须具有表名及其主键，例如：blog_id 表示来自表博客的外键 id。\n\n2.1.5 字段数据类型优化\n【建议】表中的自增列（auto_increment 属性），推荐使用 bigint 类型。因为无符号 int 存储范围为 0~4,294,967,295（不到 43 亿），溢出后会导致报错。 \n【建议】业务中选择性很少的状态 status、类型 type 等字段推荐使用 tinytint 或者 smallint 类型节省存储空间。 \n【建议】业务中 IP 地址字段推荐使用 int 类型，不推荐用 char(15)。因为 int 只占 4 字节，可以用如下函数相互转换，而 char(15) 占用至少 15 字节。\n\nSQL: \nselect inet_aton('192.168.2.12');\nselect inet_ntoa(3232236044);\nPHP: \nip2long('192.168.2.12'); \nlong2ip(3530427185);\n\nJava:  \npublic static long ipToLong(String addr)&#123;\n    String[] addrArray = addr.split(\"\\\\.\");\n    long num = 0;\n    for (int i = 0; i &lt; addrArray.length; i++)&#123;\n        int power = 3 - i;\n        num += ((Integer.parseInt(addrArray[i]) % 256 * Math.pow(256, power)));\n    &#125;\n    return num;\n&#125;\n\npublic static String longToIp(long i)&#123;\n    return ((i >> 24) &amp; 0xFF) + \".\" +\n           ((i >> 16) &amp; 0xFF) + \".\" +\n           ((i >> 8) &amp; 0xFF) + \".\" +\n           (i &amp; 0xFF);\n&#125;\n\n\n【建议】不推荐使用 enum，set。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用 tinyint 或 smallint。 \n【建议】不推荐使用 blob，text 等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和 PM、RD 沟通，是否真的需要这么大字段。InnoDB 中当一行记录超过 8098 字节时，会将该记录中选取最长的一个字段将其 768 字节放在原始 page 里，该字段余下内容放在 overflow-page 里。不幸的是在 compact 行格式下，原始 page 和 overflow-page 都会加载。 \n【建议】存储金钱的字段，建议用 int 以分为单位存储，最大数值约 4290 万，程序端乘以 100 和除以 100 进行存取。因为 int 占用 4 字节，而 double 占用 8 字节，空间浪费。 \n【建议】文本数据尽量用 varchar 存储。因为 varchar 是变长存储，比 char 更省空间。MySQL server 层规定一行所有文本最多存 65535 字节，因此在 utf8 字符集下最多存 21844 个字符，超过会自动转换为 mediumtext 字段。而 text 在 utf8 字符集下最多存 21844 个字符，mediumtext 最多存 2^24&#x2F;3 个字符，longtext 最多存 2^32 个字符。一般建议用 varchar 类型，字符数不要超过 2700。 \n【建议】时间类型尽量选取 timestamp。因为 datetime 占用 8 字节，timestamp 仅占用 4 字节，但是范围为 1970-01-01 00:00:01 到 2038-01-01 00:00:00。更为高阶的方法，选用 int 来存储时间，使用 SQL 函数 unix_timestamp() 和 from_unixtime() 来进行转换。\n\n\n详细存储大小参考下图：  \n\n\n类型（同义词）\n存储长度(BYTES)\n最小值(SIGNED&#x2F;UNSIGNED)\n最大值(SIGNED&#x2F;UNSIGNED)\n\n\n\n整形数字\n\n\n\n\n\nTINYINT\n1\n-128&#x2F;0\n127&#x2F;255\n\n\nSMALLINT\n2\n-32,768&#x2F;0\n32767&#x2F;65,535\n\n\nMEDIUMINT\n3\n-8,388,608&#x2F;0\n8388607&#x2F;16,777,215&#x2F;\n\n\nINT(INTEGER)\n4\n-2,14,7483,648&#x2F;0\n2147483647&#x2F;4,294,967,295&#x2F;\n\n\nBIGINT\n8\n-2^63&#x2F;0\n263-1&#x2F;264-1\n\n\n小数支持\n\n\n\n\n\nFLOAT[(M[,D])]\n4 or 8\n-\n\n\n\nDOUBLE[(M[,D])]\n\n\n\n\n\n(REAL, DOUBLE PRECISION)\n8\n-\n\n\n\n时间类型\n\n\n\n\n\nDATETIME\n8\n1001-01-01 00:00:00\n9999-12-31 23:59:59\n\n\nDATE\n3\n1001-01-01\n9999-12-31\n\n\nTIME\n3\n00:00:00\n23:59:59\n\n\nYEAR\n1\n1001\n9999\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:00\n\n\n\n\n\n2.1.6 索引设计\n【强制】InnoDB 表必须主键为 id int/bigint auto_increment，且主键值禁止被更新。\n【建议】主键的名称以 pk_ 开头，唯一键以 uk_ 开头，普通索引以 ix_ 开头，一律使用小写格式，以表名&#x2F;字段的名称或缩写作为后缀。\n【强制】InnoDB 和 MyISAM 存储引擎表，索引类型必须为 BTREE；MEMORY 表可以根据需要选择 HASH 或者 BTREE 类型索引。\n【强制】单个索引中每个索引记录的长度不能超过 64KB。\n【建议】单个表上的索引个数不能超过 7 个。\n【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列 user_id 的区分度可由 select count(distinct user_id) 计算出来。\n【建议】在多表 join 的 SQL 里，保证被驱动表的连接列上有索引，这样 join 执行效率最高。\n【建议】建表或加索引时，保证表里互相不存在冗余索引。对于 MySQL 来说，如果表里已经存在 key(a, b)，则 key(a) 为冗余索引，需要删除。\n【建议】如果选择性超过 20%，那么全表扫描比使用索引性能更优，即没有设置索引的必要。\n\n2.1.7 分库分表、分区表\n【强制】分区表的分区字段（partition-key）必须有索引，或者是组合索引的首列。\n【强制】单个分区表中的分区（包括子分区）个数不能超过 1024。\n【强制】上线前 RD 或者 DBA 必须指定分区表的创建、清理策略。\n【强制】访问分区表的 SQL 必须包含分区键。\n【建议】单个分区文件不超过 2G，总大小不超过 50G。建议总分区数不超过 20 个。\n【强制】对于分区表执行 alter table 操作，必须在业务低峰期执行。\n【强制】采用分库策略的，库的数量不能超过 1024。\n【强制】采用分表策略的，表的数量不能超过 4096。\n【建议】单个分表不超过 500W 行，ibd 文件大小不超过 2G，这样才能让数据分布式变得性能更佳。\n【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。\n\n2.1.8 字符集\n【强制】数据库本身库、表、列所有字符集必须保持一致，为 utf8 或 utf8mb4。\n【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为 utf8。\n\n2.1.9 程序层 DAO 设计建议\n【建议】新的代码不要用 model，推荐使用手动拼 SQL + 绑定变量传入参数的方式。因为 model 虽然可以使用面向对象的方式操作 db，但是其使用不当很容易造成生成的 SQL 非常复杂，且 model 层自己做的强制类型转换性能较差，最终导致数据库性能下降。\n【建议】前端程序连接 MySQL 或者 Redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。\n【建议】前端程序报错里尽量能够提示 MySQL 或 Redis 原生态的报错信息，便于排查错误。\n【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。\n【建议】对于 log 或 history 类型的表，随时间增长容易越来越大，因此上线前 RD 或者 DBA 必须建立表数据清理或归档方案。\n【建议】在应用程序设计阶段，RD 必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20 秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。\n【建议】多个并发业务逻辑访问同一块数据（InnoDB 表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类 SQL 尽量基于主键去更新。\n【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。\n【建议】对于单表读写比大于 10:1 的数据行或单个列，可以将热点数据放在缓存里（如 Memcached 或 Redis），加快访问速度，降低 MySQL 压力。\n\n2.1.10 一个规范的建表语句示例\n一个较为规范的建表语句为： create table user \n( \n    `id`            bigint(11) not null auto_increment, \n    `user_id`       bigint(11) not null comment '用户 ID', \n    `username`      varchar(45) not null comment '登录名', \n    `email`         varchar(30) not null comment '邮箱', \n    `nickname`      varchar(45) not null comment '昵称', \n    `avatar`        int(11) not null comment '头像', \n    `birthday`      date not null comment '生日', \n    `gender`        tinyint(4) default '0' comment '性别', \n    `intro`         varchar(150) default null comment '简介', \n    `resume_url`    varchar(300) not null comment '简历存放地址', \n    `register_ip`   int not null comment '用户注册时的源 IP', \n    `review_status` tinyint not null comment '审核状态，1-通过，2-审核中，3-未通过，4-尚未提交审核', \n    `create_time`   timestamp not null comment '记录创建的时间', \n    `update_time`   timestamp not null comment '资料修改的时间', \n    \n    primary key (`id`), \n    unique key `idx_user_id` (`user_id`), \n    key `idx_username`(`username`), \n    key `idx_create_time`(`create_time`, `review_status`) \n) \nengine = InnoDB\ndefault charset = utf8 \ncomment = '用户基本信息';\n\n2.2 SQL 编写2.2.1 DML 语句\n【强制】select 语句必须指定具体字段名称，禁止写成 *。因为 select * 会将不该读的数据也从 MySQL 里读出来，造成网卡压力。\n【强制】insert 语句指定具体字段名称，不要写成 insert into t1 values(…)，道理同上。\n【建议】insert into … values(xx),(xx),(xx)…，这里 xx 的值不要超过 5000 个。值过多虽然上线很快，但会引起主从同步延迟。\n【建议】select 语句不要使用 union，推荐使用 union all，并且 union 子句个数限制在 5 个以内。因为 union all 不需要去重，节省数据库资源，提高性能。\n【建议】in 值列表限制在 500 以内。例如 select … where user_id in(…500 个以内…)，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。\n【建议】事务里批量更新数据需要控制数量，进行必要的 sleep，做到少量多次。\n【强制】事务涉及的表必须全部是 InnoDB 表。否则一旦失败不会全部回滚，且易造成主从库同步终端。\n【强制】写入和事务发往主库，只读 SQL 发往从库。\n【强制】除静态表或小表（100 行以内），dml 语句必须有 where 条件，且使用索引查找。\n【强制】生产环境禁止使用 hint，如 sql_no_cache，force index，ignore key，straight join 等。因为 hint 是用来强制 sql 按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信 MySQL 优化器。\n【强制】where 条件里等号左右字段类型必须一致，否则无法利用索引。\n【建议】select|update|delete|replace 要有 where 子句，且 where 子句的条件必需使用索引查找。\n【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于 100 行以下的静态表可以全表扫描。查询数据量不要超过表行数的 25%，否则不会利用索引。\n【强制】where 子句中禁止只使用全模糊的 like 条件进行查找，必须有其它等值或范围查询条件，否则无法利用索引。\n【建议】索引列不要使用函数或表达式，否则无法利用索引。如 where length(name) = &#39;admin&#39; 或 where user_id + 2 = 10023。\n【建议】减少使用 or 语句，可将 or 语句优化为 union，然后在各个 where 条件上建立索引。如 where a = 1 or b = 2 优化为 where a = 1 … union … where b = 2, key(a), key(b)。\n【建议】分页查询，当 limit 起点较高时，可先用过滤条件进行过滤。如 select a, b, c from t1 limit 10000, 20; 优化为: select a, b, c from t1 where id &gt; 10000 limit 20;。\n\n2.2.2 多表连接\n【强制】禁止跨 DB 的 join 语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。\n【强制】禁止在业务的更新类 SQL 语句中使用 join，比如 update t1 join t2 …。\n【建议】不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 join 来代替子查询。\n【建议】线上环境，多表 join 不要超过 3 个表。\n【建议】多表连接查询推荐使用别名，且 select 列表中要用别名引用字段，数据库.表格式，如 select a from db1.table1 alias1 where …。\n【建议】在多表 join 中，尽量选取结果集较小的表作为驱动表，来 join 其它表。\n\n2.2.3 事务\n【建议】事务中 insert|update|delete|replace 语句操作的行数控制在 2000 以内，以及 where 子句中 in 列表的传参个数控制在 500 以内。\n【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的 sleep，一般建议值 5-10 秒。\n【建议】对于有 auto_increment 属性字段的表的插入操作，并发需要控制在 200 以内。\n【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为 repeatable-read。\n【建议】事务里包含 SQL 不超过 5 个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL 内部缓存、连接消耗过多等雪崩问题。\n【建议】事务里更新语句尽量基于主键或 unique key，如 update … where id = XX;，否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。\n【建议】尽量把一些典型外部调用移出事务，如调用 Web Service，访问文件存储等，从而避免事务过长。\n【建议】对于 MySQL 主从延迟严格敏感的 select 语句，请开启事务强制访问主库。\n\n2.2.4 排序和分组\n【建议】减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。\n【建议】order by、group by、distinct 这些 SQL 尽量利用索引直接检索出排序好的数据。如 where a = 1 order by 可以利用 key(a, b)。\n【建议】包含了 order by、group by、distinct 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。\n\n2.2.5 线上禁止使用的 SQL 语句\n【高危】禁用 update|delete t1 … where a = XX limit XX; 这种带 limit 的更新语句。因为会导致主从不一致，导致数据错乱。建议加上 order by PK。\n【高危】禁止使用关联子查询，如 update t1 set … where name in(select name from user where …);，效率极其低下。\n【强制】禁用 procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。\n【强制】禁用 insert into … on duplicate key update … 在高并发环境下，会造成主从不一致。\n【强制】禁止联表更新语句，如 update t1, t2 where t1.id = t2.id …。\n\n","slug":"MySQL/MySQL数据库设计规范","date":"2022-02-23T03:37:18.000Z","categories_index":"MySQL","tags_index":"MySQL","author_index":"Anchor"},{"id":"b4b30b3366bb496de67ea3da9b9ffa6f","title":"Java 基础","content":"一、数据类型基本类型\nbyte&#x2F;8\nchar&#x2F;16\nshort&#x2F;16\nint&#x2F;32\nfloat&#x2F;32\nlong&#x2F;64\ndouble&#x2F;64\nboolean&#x2F;~\n\nboolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。\n\nPrimitive Data Types\nThe Java® Virtual Machine Specification\n\n包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\nInteger x = 2;     // 装箱 调用了 Integer.valueOf(2)\nint y = x;         // 拆箱 调用了 X.intValue()\n\n\nAutoboxing and Unboxing\n\n缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于：\n\nnew Integer(123) 每次都会新建一个对象；\nInteger.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\n\nInteger x = new Integer(123);\nInteger y = new Integer(123);\nSystem.out.println(x == y);    // false\nInteger z = Integer.valueOf(123);\nInteger k = Integer.valueOf(123);\nSystem.out.println(z == k);   // true\n\nvalueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\npublic static Integer valueOf(int i) &#123;\n    if (i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n&#125;\n\n在 Java 8 中，Integer 缓存池的大小默认为 -128~127。\nstatic final int low = -128;\nstatic final int high;\nstatic final Integer cache[];\n\nstatic &#123;\n    // high value may be configured by property\n    int h = 127;\n    String integerCacheHighPropValue =\n        sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n    if (integerCacheHighPropValue != null) &#123;\n        try &#123;\n            int i = parseInt(integerCacheHighPropValue);\n            i = Math.max(i, 127);\n            // Maximum array size is Integer.MAX_VALUE\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n        &#125; catch( NumberFormatException nfe) &#123;\n            // If the property cannot be parsed into an int, ignore it.\n        &#125;\n    &#125;\n    high = h;\n\n    cache = new Integer[(high - low) + 1];\n    int j = low;\n    for(int k = 0; k &lt; cache.length; k++)\n        cache[k] = new Integer(j++);\n\n    // range [-128, 127] must be interned (JLS7 5.1.7)\n    assert IntegerCache.high >= 127;\n&#125;\n\n编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。\nInteger m = 123;\nInteger n = 123;\nSystem.out.println(m == n); // true\n\n基本类型对应的缓冲池如下：\n\nboolean values true and false\nall byte values\nshort values between -128 and 127\nint values between -128 and 127\nchar in the range \\u0000 to \\u007F\n\n在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。\n在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax&#x3D; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。\n[StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123\n](https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123)\n二、String概览String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）在 Java 8 中，String 内部使用 char 数组存储数据。\npublic final class String\n    implements java.io.Serializable, Comparable&lt;String>, CharSequence &#123;\n    /** The value is used for character storage. */\n    private final char value[];\n&#125;\n\n在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。\npublic final class String\n    implements java.io.Serializable, Comparable&lt;String>, CharSequence &#123;\n    /** The value is used for character storage. */\n    private final byte[] value;\n\n    /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */\n    private final byte coder;\n&#125;\n\nvalue 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。\n不可变的好处1. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\n2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\n\n3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。\n4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用。\nProgram Creek : Why String is immutable in Java?\nString, StringBuffer and StringBuilder1. 可变性\nString 不可变\nStringBuffer 和 StringBuilder 可变\n\n2. 线程安全\nString 不可变，因此是线程安全的\nStringBuilder 不是线程安全的\nStringBuffer 是线程安全的，内部使用 synchronized 进行同步\n\nStackOverflow : String, StringBuffer, and StringBuilder\nString Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。\n当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。\n下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 “aaa” 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。\nString s1 = new String(\"aaa\");\nString s2 = new String(\"aaa\");\nSystem.out.println(s1 == s2);           // false\nString s3 = s1.intern();\nString s4 = s2.intern();\nSystem.out.println(s3 == s4);           // true\n\n如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。\nString s5 = \"bbb\";\nString s6 = \"bbb\";\nSystem.out.println(s5 == s6);  // true\n\n在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。\n\nStackOverflow : What is String interning?\n深入解析 String#intern\n\nnew String(“abc”)使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。\n\n“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；\n而使用 new 的方式会在堆中创建一个字符串对象。\n\n创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。\npublic class NewStringTest &#123;\n    public static void main(String[] args) &#123;\n        String s = new String(\"abc\");\n    &#125;\n&#125;\n\n使用 javap -verbose 进行反编译，得到以下内容：\n// ...\nConstant pool:\n// ...\n   #2 = Class              #18            // java/lang/String\n   #3 = String             #19            // abc\n// ...\n  #18 = Utf8               java/lang/String\n  #19 = Utf8               abc\n// ...\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=3, locals=2, args_size=1\n         0: new           #2                  // class java/lang/String\n         3: dup\n         4: ldc           #3                  // String abc\n         6: invokespecial #4                  // Method java/lang/String.\"&lt;init>\":(Ljava/lang/String;)V\n         9: astore_1\n// ...\n\n在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。\n以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。\npublic String(String original) &#123;\n    this.value = original.value;\n    this.hash = original.hash;\n&#125;\n\n三、运算参数传递Java 的参数是以值传递的形式传入方法中，而不是引用传递。以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。\npublic class Dog &#123;\n\n    String name;\n\n    Dog(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getName() &#123;\n        return this.name;\n    &#125;\n\n    void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    String getObjectAddress() &#123;\n        return super.toString();\n    &#125;\n&#125;\n\n在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。\nclass PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(\"A\");\n        func(dog);\n        System.out.println(dog.getName());          // B\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        dog.setName(\"B\");\n    &#125;\n&#125;\n\n但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。\npublic class PassByValueExample &#123;\n    public static void main(String[] args) &#123;\n        Dog dog = new Dog(\"A\");\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        func(dog);\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        System.out.println(dog.getName());          // A\n    &#125;\n\n    private static void func(Dog dog) &#123;\n        System.out.println(dog.getObjectAddress()); // Dog@4554617c\n        dog = new Dog(\"B\");\n        System.out.println(dog.getObjectAddress()); // Dog@74a14482\n        System.out.println(dog.getName());          // B\n    &#125;\n&#125;\n\nStackOverflow: Is Java “pass-by-reference” or “pass-by-value”?\nfloat 与 doubleJava 不能隐式执行向下转型，因为这会使得精度降低。1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。\n// float f = 1.1;\n\n1.1f 字面量才是 float 类型。\nfloat f = 1.1f;\n\n隐式类型转换因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。\nshort s1 = 1;\n// s1 = s1 + 1;\n\n但是使用 +&#x3D; 或者 ++ 运算符会执行隐式类型转换。\ns1 += 1;\ns1++;\n\n上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：\ns1 = (short) (s1 + 1);\n\nStackOverflow : Why don’t Java’s +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; compound assignment operators require casting?\nswitch从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。\nString s = \"a\";\nswitch (s) &#123;\n    case \"a\":\n        System.out.println(\"aaa\");\n        break;\n    case \"b\":\n        System.out.println(\"bbb\");\n        break;\n&#125;\n\nswitch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n// long x = 111;\n// switch (x) &#123; // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'\n//     case 111:\n//         System.out.println(111);\n//         break;\n//     case 222:\n//         System.out.println(222);\n//         break;\n// &#125;\n\nStackOverflow : Why can’t your switch statement data type be long, Java?\n四、关键字final1. 数据声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n\n对于基本类型，final 使数值不变；\n对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。\n\nfinal int x = 1;\n// x = 2;  // cannot assign value to final variable 'x'\nfinal A y = new A();\ny.a = 1;\n\n2. 方法声明方法不能被子类重写。\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n3. 类声明类不允许被继承。\nstatic1. 静态变量\n静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。\n实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n\npublic class A &#123;\n\n    private int x;         // 实例变量\n    private static int y;  // 静态变量\n\n    public static void main(String[] args) &#123;\n        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context\n        A a = new A();\n        int x = a.x;\n        int y = A.y;\n    &#125;\n&#125;\n\n2. 静态方法静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\npublic abstract class A &#123;\n    public static void func1()&#123;\n    &#125;\n    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'\n&#125;\n\n只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。\npublic class A &#123;\n\n    private static int x;\n    private int y;\n\n    public static void func1()&#123;\n        int a = x;\n        // int b = y;  // Non-static field 'y' cannot be referenced from a static context\n        // int b = this.y;     // 'A.this' cannot be referenced from a static context\n    &#125;\n&#125;\n\n3. 静态语句块静态语句块在类初始化时运行一次。\npublic class A &#123;\n    static &#123;\n        System.out.println(\"123\");\n    &#125;\n\n    public static void main(String[] args) &#123;\n        A a1 = new A();\n        A a2 = new A();\n    &#125;\n&#125;\n\n// 只会打印一次\n123\n\n4. 静态内部类非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。\npublic class OuterClass &#123;\n\n    class InnerClass &#123;\n    &#125;\n\n    static class StaticInnerClass &#123;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context\n        OuterClass outerClass = new OuterClass();\n        InnerClass innerClass = outerClass.new InnerClass();\n        StaticInnerClass staticInnerClass = new StaticInnerClass();\n    &#125;\n&#125;\n\n静态内部类不能访问外部类的非静态的变量和方法。\n5. 静态导包在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。\nimport static com.xxx.ClassName.*\n\n6. 初始化顺序静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\npublic static String staticField = \"静态变量\";\n\nstatic &#123;\n    System.out.println(\"静态语句块\");\n&#125;\n\npublic String field = \"实例变量\";\n\n&#123;\n    System.out.println(\"普通语句块\");\n&#125;\n\n最后才是构造函数的初始化。\npublic InitialOrderTest() &#123;\n    System.out.println(\"构造函数\");\n&#125;\n\n存在继承的情况下，初始化顺序为：\n\n父类（静态变量、静态语句块）\n子类（静态变量、静态语句块）\n父类（实例变量、普通语句块）\n父类（构造函数）\n子类（实例变量、普通语句块）\n子类（构造函数）\n\n五、Object 通用方法概览public native int hashCode()\n\npublic boolean equals(Object obj)\n\nprotected native Object clone() throws CloneNotSupportedException\n\npublic String toString()\n\npublic final native Class&lt;?> getClass()\n\nprotected void finalize() throws Throwable &#123;&#125;\n\npublic final native void notify()\n\npublic final native void notifyAll()\n\npublic final native void wait(long timeout) throws InterruptedException\n\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\npublic final void wait() throws InterruptedException\n\nequals()1. 等价关系两个对象具有等价关系，需要满足以下五个条件：\nⅠ 自反性x.equals(x); // true\n\nⅡ 对称性x.equals(y) == y.equals(x); // true\n\nⅢ 传递性if (x.equals(y) &amp;&amp; y.equals(z))\n    x.equals(z); // true;\n\nⅣ 一致性多次调用 equals() 方法结果不变\nx.equals(y) == x.equals(y); // true\n\nⅤ 与 null 的比较对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\nx.equals(null); // false;\n\n2. 等价与相等\n对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法。\n对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。\n\nInteger x = new Integer(1);\nInteger y = new Integer(1);\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x == y);      // false\n\n3. 实现\n检查是否为同一个对象的引用，如果是直接返回 true；\n检查是否是同一个类型，如果不是，直接返回 false；\n将 Object 对象进行转型；\n判断每个关键域是否相等。\n\npublic class EqualExample &#123;\n\n    private int x;\n    private int y;\n    private int z;\n\n    public EqualExample(int x, int y, int z) &#123;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        EqualExample that = (EqualExample) o;\n\n        if (x != that.x) return false;\n        if (y != that.y) return false;\n        return z == that.z;\n    &#125;\n&#125;\n\nhashCode()hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。\n在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。\nHashSet  和 HashMap 等集合类使用了 hashCode()  方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode()  方法。\n下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。\nEqualExample e1 = new EqualExample(1, 1, 1);\nEqualExample e2 = new EqualExample(1, 1, 1);\nSystem.out.println(e1.equals(e2)); // true\nHashSet&lt;EqualExample> set = new HashSet&lt;>();\nset.add(e1);\nset.add(e2);\nSystem.out.println(set.size());   // 2\n\n理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。\nR 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。\n@Override\npublic int hashCode() &#123;\n    int result = 17;\n    result = 31 * result + x;\n    result = 31 * result + y;\n    result = 31 * result + z;\n    return result;\n&#125;\n\ntoString()默认返回 ToStringExample@4554617c  这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 \npublic class ToStringExample &#123;\n\n    private int number;\n\n    public ToStringExample(int number) &#123;\n        this.number = number;\n    &#125;\n&#125;\n\nToStringExample example = new ToStringExample(123);\nSystem.out.println(example.toString());\n\nToStringExample@4554617c\n\nclone()1. cloneableclone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\npublic class CloneExample &#123;\n    private int a;\n    private int b;\n&#125;\n\nCloneExample e1 = new CloneExample();\n// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'\n\n重写 clone() 得到以下实现：\npublic class CloneExample &#123;\n    private int a;\n    private int b;\n\n    @Override\n    public CloneExample clone() throws CloneNotSupportedException &#123;\n        return (CloneExample)super.clone();\n    &#125;\n&#125;\n\nCloneExample e1 = new CloneExample();\ntry &#123;\n    CloneExample e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\n\njava.lang.CloneNotSupportedException: CloneExample\n\n以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。\n应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。\npublic class CloneExample implements Cloneable &#123;\n    private int a;\n    private int b;\n\n    @Override\n    public Object clone() throws CloneNotSupportedException &#123;\n        return super.clone();\n    &#125;\n&#125;\n\n2. 浅拷贝拷贝对象和原始对象的引用类型引用同一个对象。\npublic class ShallowCloneExample implements Cloneable &#123;\n\n    private int[] arr;\n\n    public ShallowCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected ShallowCloneExample clone() throws CloneNotSupportedException &#123;\n        return (ShallowCloneExample) super.clone();\n    &#125;\n&#125;\n\nShallowCloneExample e1 = new ShallowCloneExample();\nShallowCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 222\n\n3. 深拷贝拷贝对象和原始对象的引用类型引用不同对象。\npublic class DeepCloneExample implements Cloneable &#123;\n\n    private int[] arr;\n\n    public DeepCloneExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n\n    @Override\n    protected DeepCloneExample clone() throws CloneNotSupportedException &#123;\n        DeepCloneExample result = (DeepCloneExample) super.clone();\n        result.arr = new int[arr.length];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            result.arr[i] = arr[i];\n        &#125;\n        return result;\n    &#125;\n&#125;\n\nDeepCloneExample e1 = new DeepCloneExample();\nDeepCloneExample e2 = null;\ntry &#123;\n    e2 = e1.clone();\n&#125; catch (CloneNotSupportedException e) &#123;\n    e.printStackTrace();\n&#125;\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n4. clone() 的替代方案使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\npublic class CloneConstructorExample &#123;\n\n    private int[] arr;\n\n    public CloneConstructorExample() &#123;\n        arr = new int[10];\n        for (int i = 0; i &lt; arr.length; i++) &#123;\n            arr[i] = i;\n        &#125;\n    &#125;\n\n    public CloneConstructorExample(CloneConstructorExample original) &#123;\n        arr = new int[original.arr.length];\n        for (int i = 0; i &lt; original.arr.length; i++) &#123;\n            arr[i] = original.arr[i];\n        &#125;\n    &#125;\n\n    public void set(int index, int value) &#123;\n        arr[index] = value;\n    &#125;\n\n    public int get(int index) &#123;\n        return arr[index];\n    &#125;\n&#125;\n\nCloneConstructorExample e1 = new CloneConstructorExample();\nCloneConstructorExample e2 = new CloneConstructorExample(e1);\ne1.set(2, 222);\nSystem.out.println(e2.get(2)); // 2\n\n六、继承访问权限Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n可以对类或类中的成员（字段和方法）加上访问修饰符。\n\n类可见表示其它类可以用这个类创建实例对象。\n成员可见表示其它类可以用这个类的实例对象访问到该成员；\n\nprotected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\n设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\n如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。\n字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。\npublic class AccessExample &#123;\n    public String id;\n&#125;\n\n可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\npublic class AccessExample &#123;\n\n    private int id;\n\n    public String getId() &#123;\n        return id + \"\";\n    &#125;\n\n    public void setId(String id) &#123;\n        this.id = Integer.valueOf(id);\n    &#125;\n&#125;\n\n但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\npublic class AccessWithInnerClassExample &#123;\n\n    private class InnerClass &#123;\n        int x;\n    &#125;\n\n    private InnerClass innerClass;\n\n    public AccessWithInnerClassExample() &#123;\n        innerClass = new InnerClass();\n    &#125;\n\n    public int getValue() &#123;\n        return innerClass.x;  // 直接访问\n    &#125;\n&#125;\n\n抽象类与接口1. 抽象类抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。\n抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。\npublic abstract class AbstractClassExample &#123;\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() &#123;\n        System.out.println(\"func2\");\n    &#125;\n&#125;\n\npublic class AbstractExtendClassExample extends AbstractClassExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(\"func1\");\n    &#125;\n&#125;\n\n// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated\nAbstractClassExample ac2 = new AbstractExtendClassExample();\nac2.func1();\n\n2. 接口接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。\n接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。\n接口的字段默认都是 static 和 final 的。\npublic interface InterfaceExample &#123;\n\n    void func1();\n\n    default void func2()&#123;\n        System.out.println(\"func2\");\n    &#125;\n\n    int x = 123;\n    // int y;               // Variable 'y' might not have been initialized\n    public int z = 0;       // Modifier 'public' is redundant for interface fields\n    // private int k = 0;   // Modifier 'private' not allowed here\n    // protected int l = 0; // Modifier 'protected' not allowed here\n    // private void fun3(); // Modifier 'private' not allowed here\n&#125;\n\npublic class InterfaceImplementExample implements InterfaceExample &#123;\n    @Override\n    public void func1() &#123;\n        System.out.println(\"func1\");\n    &#125;\n&#125;\n\n// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated\nInterfaceExample ie2 = new InterfaceImplementExample();\nie2.func1();\nSystem.out.println(InterfaceExample.x);\n\n3. 比较\n从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。\n从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。\n接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。\n接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。\n\n4. 使用选择使用接口：\n\n需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；\n需要使用多重继承。\n\n使用抽象类：\n\n需要在几个相关的类中共享代码。\n需要能控制继承来的成员的访问权限，而不是都为 public。\n需要继承非静态和非常量字段。\n\n在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\n\nAbstract Methods and Classes\n深入理解 abstract class 和 interface\nWhen to Use Abstract Class and Interface\nJava 9 Private Methods in Interfaces\n\nsuper\n访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。\n访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。\n\npublic class SuperExample &#123;\n\n    protected int x;\n    protected int y;\n\n    public SuperExample(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n\n    public void func() &#123;\n        System.out.println(\"SuperExample.func()\");\n    &#125;\n&#125;\n\npublic class SuperExtendExample extends SuperExample &#123;\n\n    private int z;\n\n    public SuperExtendExample(int x, int y, int z) &#123;\n        super(x, y);\n        this.z = z;\n    &#125;\n\n    @Override\n    public void func() &#123;\n        super.func();\n        System.out.println(\"SuperExtendExample.func()\");\n    &#125;\n&#125;\n\nSuperExample e = new SuperExtendExample(1, 2, 3);\ne.func();\n\nSuperExample.func()\nSuperExtendExample.func()\n\nUsing the Keyword super\n重写与重载1. 重写（Override）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n为了满足里式替换原则，重写有以下三个限制：\n\n子类方法的访问权限必须大于等于父类方法；\n子类方法的返回类型必须是父类方法返回类型或为其子类型。\n子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。\n\n使用 @Override  注解，可以让编译器帮忙检查是否满足上面的三个限制条件。 \n下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：\n\n子类方法访问权限为 public，大于父类的 protected。\n子类的返回类型为 ArrayList，是父类返回类型 List 的子类。\n子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。\n子类重写方法使用 @Override  注解，从而让编译器自动检查是否满足限制条件。\n\nclass SuperClass &#123;\n    protected List&lt;Integer> func() throws Throwable &#123;\n        return new ArrayList&lt;>();\n    &#125;\n&#125;\n\nclass SubClass extends SuperClass &#123;\n    @Override\n    public ArrayList&lt;Integer> func() throws Exception &#123;\n        return new ArrayList&lt;>();\n    &#125;\n&#125;\n\n在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：\n\nthis.func(this)\nsuper.func(this)\nthis.func(super)\nsuper.func(super)\n\n/*\n    A\n    |\n    B\n    |\n    C\n    |\n    D\n */\n\n\nclass A &#123;\n\n    public void show(A obj) &#123;\n        System.out.println(\"A.show(A)\");\n    &#125;\n\n    public void show(C obj) &#123;\n        System.out.println(\"A.show(C)\");\n    &#125;\n&#125;\n\nclass B extends A &#123;\n\n    @Override\n    public void show(A obj) &#123;\n        System.out.println(\"B.show(A)\");\n    &#125;\n&#125;\n\nclass C extends B &#123;\n&#125;\n\nclass D extends C &#123;\n&#125;\n\npublic static void main(String[] args) &#123;\n\n    A a = new A();\n    B b = new B();\n    C c = new C();\n    D d = new D();\n\n    // 在 A 中存在 show(A obj)，直接调用\n    a.show(a); // A.show(A)\n    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A\n    a.show(b); // A.show(A)\n    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用\n    b.show(c); // A.show(C)\n    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C\n    b.show(d); // A.show(C)\n\n    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样\n    A ba = new B();\n    ba.show(c); // A.show(C)\n    ba.show(d); // A.show(C)\n&#125;\n\n2. 重载（Overload）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n应该注意的是，返回值不同，其它都相同不算是重载。\nclass OverloadingExample &#123;\n    public void show(int x) &#123;\n        System.out.println(x);\n    &#125;\n\n    public void show(int x, String y) &#123;\n        System.out.println(x + \" \" + y);\n    &#125;\n&#125;\n\npublic static void main(String[] args) &#123;\n    OverloadingExample example = new OverloadingExample();\n    example.show(1);\n    example.show(1, \"2\");\n&#125;\n\n七、反射每个类都有一个   Class   对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。\n类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\nClass 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：\n\nField  ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；\nMethod  ：可以使用 invoke() 方法调用与 Method 对象关联的方法；\nConstructor  ：可以用 Constructor 的 newInstance() 创建新的对象。\n\n反射的优点：\n可扩展性   ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。\n类浏览器和可视化开发环境   ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。\n调试器和测试工具   ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。\n\n反射的缺点：尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。\n\n性能开销   ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 \n安全限制   ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 \n内部暴露   ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 \nTrail: The Reflection API \n深入解析 Java 反射（1）- 基础\n\n八、异常Throwable 可以用来表示任何可以作为异常抛出的类，分为两种：  Error   和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：\n\n受检异常  ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；\n非受检异常  ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。\n\n\n\nJava Exception Interview Questions and Answers \nJava提高篇——Java 异常处理\n\n九、泛型public class Box&lt;T> &#123;\n    // T stands for \"Type\"\n    private T t;\n    public void set(T t) &#123; this.t = t; &#125;\n    public T get() &#123; return t; &#125;\n&#125;\n\n\nJava 泛型详解\n10 道 Java 泛型面试题\n\n十、注解Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\n注解 Annotation 实现原理与自定义注解例子\n十一、特性Java 各版本的新特性New highlights in Java SE 8\nLambda Expressions\nPipelines and Streams\nDate and Time API\nDefault Methods\nType Annotations\nNashhorn JavaScript Engine\nConcurrent Accumulators\nParallel operations\nPermGen Error Removed\n\nNew highlights in Java SE 7\nStrings in Switch Statement\nType Inference for Generic Instance Creation\nMultiple Exception Handling\nSupport for Dynamic Languages\nTry with Resources\nJava nio Package\nBinary Literals, Underscore in literals\nDiamond Syntax\n\n\nDifference between Java 1.8 and Java 1.7?\nJava 8 特性\n\nJava 与 C++ 的区别\nJava 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。\nJava 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。\nJava 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。\nJava 支持自动垃圾回收，而 C++ 需要手动回收。\nJava 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。\nJava 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。\nJava 的 goto 是保留字，但是不可用，C++ 可以使用 goto。\n\nWhat are the main differences between Java and C++?\nJRE or JDK\nJRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。\nJDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。\n\n","slug":"Java/JAVA基础","date":"2022-02-22T05:32:16.000Z","categories_index":"JAVA","tags_index":"JAVA,Java基础,Spring","author_index":"Anchor"},{"id":"ad849fabb64e7ddec346e0f489d0c75c","title":"Kafka同组下多消费者仅一个消费者消费的情况处理","content":"1、问题描述线上某个服务有多个节点，每个节点都有一个消费者消费 Kafka 消息，查看日志发现仅有一个服务的消费者在正常运行，其他全部罢工中\n2、问题定位同组下监听同一 topic 中有多个消费者，但是只有一个消费者消费，一般情况是因为 Kafka 设置的partition的数量为 1,本地验证修改partition数量，问题消失。\n3、解决办法在 kafka 服务器下运行如下命令修改 kafka 的partition\n./kafka-topics.sh --zookeeper localhost:2181 --alter --topic topic名称 --partitions 10\n\n备注：topic 名称为正在使用的 topic 名称，后面那个数量为需要设置的 partition 的数量，这里设置为 10\n4、总结与扩展又查阅了相关资料，总结了一下 kafka 中 partition 和消费者的对应关系如下：\n\n消费者多于 partition同一个 partition 内的消息只能被同一个组中的一个 consumer 消费。当消费者数量多于 partition 的数量时，多余的消费者空闲。\n例子：\n有消息 1，2，3，4，5，6，7，8，9 ，partition 数量为 1，消费者数量为 2\nc1 消费：1，2，3，4，5，6，7，8，9\nc2 消费：\n\n消费者小于 partition\n（1）.partition 不是消费者倍数\n  会有多个partition对应一个消费者\n\n  例子：\n\n  有消息1，2，3，4，5，6，7，8，9      partition数量为3，消费者数量为2\n\n  c1消费：1，3，4，6，7，9\n\n  c2消费：2，5，8\n\n（2）.partition 是消费者倍数\n  消息在同一个组之间的消费者之间均分\n\n  例子：\n\n  有消息1，2，3，4，5，6，7，8，9      partition数量为3，消费者数量为3\n\n  c1消费：2，5，8\n\n  c2消费：3，6，9\n\n  c3消费：1，4，7\n\n\n多组同 topic 情况\n每个组都会消费同样的消息，同一消息会被多组消息\n  例子：\n\n  消息 1，2，3，4，5，6，7，8，9 `partition` 数量为 3，g1 组消费者数量为 3，g2 组消费者数量为 1\n\n  g1 组：\n\n  c1 消费：2，5，8\n\n  c2 消费：3，6，9\n\n  c3 消费：1，4，7\n\n  g2 组：\n\n  c1 消费：1，2，3，4，5，6，7，8，9\n\n\n\n","slug":"Kafka/Kafka同组下多消费者仅一个消费者消费的情况处理","date":"2019-04-10T12:42:52.000Z","categories_index":"JAVA","tags_index":"Kafka","author_index":"Anchor"}]