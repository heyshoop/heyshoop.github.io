{"title":"浪浪山打工人旅游指南（一）Java 面试题【汇总篇】","uid":"c498ccbc5dc4c0c1651c7cd1edb0e954","slug":"浪浪山打工人/浪浪山打工人旅游指南（一）Java 面试题【汇总篇】","date":"2023-01-16T13:58:28.000Z","updated":"2023-01-17T10:15:27.637Z","comments":true,"path":"api/articles/浪浪山打工人/浪浪山打工人旅游指南（一）Java 面试题【汇总篇】.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/lbjn.png","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>2023年1月份最新基础汇总篇，Java开发技术栈知识点都有涉及，主要面向1-2年修为的浪浪山小妖，温故而知新<br>旅游前读这一篇就够了</p></blockquote>\n<h1 id=\"一、基础篇\"><a href=\"#一、基础篇\" class=\"headerlink\" title=\"一、基础篇\"></a>一、基础篇</h1><h2 id=\"1-1-Java语言有哪些特点\"><a href=\"#1-1-Java语言有哪些特点\" class=\"headerlink\" title=\"1.1.Java语言有哪些特点\"></a>1.1.Java语言有哪些特点</h2><ol>\n<li>简单易学、有丰富的类库</li>\n<li>面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）</li>\n<li>与平台无关性（JVM是Java跨平台使用的根本）</li>\n<li>可靠安全</li>\n<li>支持多线程</li>\n</ol>\n<h2 id=\"1-2-面向对象和面向过程的区别\"><a href=\"#1-2-面向对象和面向过程的区别\" class=\"headerlink\" title=\"1.2.面向对象和面向过程的区别\"></a>1.2.面向对象和面向过程的区别</h2><p><strong>面向过程</strong>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发。<br><strong>面向对象</strong>：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>\n<h2 id=\"1-3-八种基本数据类型的大小，以及他们的封装类\"><a href=\"#1-3-八种基本数据类型的大小，以及他们的封装类\" class=\"headerlink\" title=\"1.3.八种基本数据类型的大小，以及他们的封装类\"></a>1.3.八种基本数据类型的大小，以及他们的封装类</h2><table>\n<thead>\n<tr>\n<th><strong>基本类型</strong></th>\n<th><strong>大小（字节）</strong></th>\n<th><strong>默认值</strong></th>\n<th><strong>封装类</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>1</td>\n<td>(byte)0</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>(short)0</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>0</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8</td>\n<td>0L</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>0.0f</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>0.0d</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>-</td>\n<td>false</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>2</td>\n<td>\\u0000(null)</td>\n<td>Character</td>\n</tr>\n</tbody></table>\n<ol>\n<li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li>\n<li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</li>\n</ol>\n<p>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</p>\n<h2 id=\"1-4-标识符的命名规则\"><a href=\"#1-4-标识符的命名规则\" class=\"headerlink\" title=\"1.4.标识符的命名规则\"></a>1.4.标识符的命名规则</h2><p><strong>标识符的含义：</strong><br>是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。<br><strong>命名规则：（硬性要求）</strong><br>标识符可以包含英文字母，0-9的数字，$以及_<br>标识符不能以数字开头<br>标识符不是关键字<br><strong>命名规范：（非硬性要求）</strong><br>类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。<br>变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。<br>方法名规范：同变量名。</p>\n<h2 id=\"1-5-instanceof-关键字的作用\"><a href=\"#1-5-instanceof-关键字的作用\" class=\"headerlink\" title=\"1.5.instanceof 关键字的作用\"></a>1.5.instanceof 关键字的作用</h2><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> result <span class=\"token operator\">=</span> obj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Class</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。<br>注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//编译不通过 i必须是引用类型，不能是基本类型</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//编译不通过</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integer <span class=\"token keyword\">instanceof</span>  <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回false。</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"1-6-Java自动装箱与拆箱\"><a href=\"#1-6-Java自动装箱与拆箱\" class=\"headerlink\" title=\"1.6.Java自动装箱与拆箱\"></a>1.6.Java自动装箱与拆箱</h2><p><strong>装箱</strong>就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的valueOf(int) 方法<br><strong>拆箱</strong>就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）。调用方法：Integer的intValue方法<br>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>面试题1： 以下代码会输出什么？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n   \n    <span class=\"token class-name\">Integer</span> i1 <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Integer</span> i2 <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Integer</span> i3 <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Integer</span> i4 <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n   \n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i1<span class=\"token operator\">==</span>i2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i3<span class=\"token operator\">==</span>i4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行结果:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Integer</span> <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> <span class=\"token operator\">-</span><span class=\"token number\">128</span> <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token class-name\">IntegerCache</span><span class=\"token punctuation\">.</span>high<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">IntegerCache</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">128</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中IntegerCache类的实现为：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">IntegerCache</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Integer</span> cache<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> low <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">128</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// high value may be configured by property</span>\n      <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>integerCacheHighPropValue <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// Use Long.decode here to avoid invoking methods that</span>\n        <span class=\"token comment\">// require Integer's autoboxing cache to be initialized</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>integerCacheHighPropValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        i <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">127</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// Maximum array size is Integer.MAX_VALUE</span>\n        h <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span> <span class=\"token operator\">-</span> <span class=\"token operator\">-</span>low<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n      high <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n      cache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>high <span class=\"token operator\">-</span> low<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> low<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> cache<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cache<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">IntegerCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。<br>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。<br>面试题2：以下代码输出什么？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n   \n    <span class=\"token class-name\">Double</span> i1 <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Double</span> i2 <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Double</span> i3 <span class=\"token operator\">=</span> <span class=\"token number\">200.0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Double</span> i4 <span class=\"token operator\">=</span> <span class=\"token number\">200.0</span><span class=\"token punctuation\">;</span>\n   \n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i1<span class=\"token operator\">==</span>i2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i3<span class=\"token operator\">==</span>i4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>\n<h2 id=\"1-7-重载和重写的区别\"><a href=\"#1-7-重载和重写的区别\" class=\"headerlink\" title=\"1.7.重载和重写的区别\"></a>1.7.重载和重写的区别</h2><h3 id=\"重写-Override\"><a href=\"#重写-Override\" class=\"headerlink\" title=\"重写(Override)\"></a>重写(Override)</h3><p>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// TODO Auto-generated method stub</span>\n    <span class=\"token class-name\">Son</span> s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Son</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Father</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// TODO Auto-generated method stub</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello by \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"重写总结\"><a href=\"#重写总结\" class=\"headerlink\" title=\"重写总结\"></a>重写总结</h3><ol>\n<li>发生在父类与子类之间</li>\n<li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</li>\n<li>访问修饰符的限制一定要大于被重写方法的访问修饰符(public&gt;protected&gt;default&gt;private)</li>\n<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>\n</ol>\n<h3 id=\"重载（Overload）\"><a href=\"#重载（Overload）\" class=\"headerlink\" title=\"重载（Overload）\"></a>重载（Overload）</h3><p>在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// TODO Auto-generated method stub</span>\n    <span class=\"token class-name\">Father</span> s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Father</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wintershii\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"重载总结\"><a href=\"#重载总结\" class=\"headerlink\" title=\"重载总结\"></a>重载总结</h3><ol>\n<li>重载Overload是一个类中多态性的一种表现</li>\n<li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li>\n<li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li>\n</ol>\n<h2 id=\"1-8-equals与-x3D-x3D-的区别\"><a href=\"#1-8-equals与-x3D-x3D-的区别\" class=\"headerlink\" title=\"1.8.equals与&#x3D;&#x3D;的区别\"></a>1.8.equals与&#x3D;&#x3D;的区别</h2><h3 id=\"x3D-x3D\"><a href=\"#x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;\"></a>&#x3D;&#x3D;</h3><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p>\n<ol>\n<li>比较的是操作符两端的操作数是否是同一个对象。</li>\n<li>两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。</li>\n<li>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true），因为他们都指向地址为10的堆。</li>\n</ol>\n<h3 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h3><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“&#x3D;&#x3D;”，替换成equals</p>\n<h2 id=\"1-9-Hashcode的作用\"><a href=\"#1-9-Hashcode的作用\" class=\"headerlink\" title=\"1.9.Hashcode的作用\"></a>1.9.Hashcode的作用</h2><p>java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。<br>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。<br>hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。<br>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>\n<h2 id=\"1-10-String、String-StringBuffer-和-StringBuilder-的区别是什么\"><a href=\"#1-10-String、String-StringBuffer-和-StringBuilder-的区别是什么\" class=\"headerlink\" title=\"1.10.String、String StringBuffer 和 StringBuilder 的区别是什么?\"></a>1.10.String、String StringBuffer 和 StringBuilder 的区别是什么?</h2><p>String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符。<br>StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n  * The value is used for character storage.\n  */</span>\n  <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> value<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>\n<h2 id=\"1-11-ArrayList和linkedList的区别\"><a href=\"#1-11-ArrayList和linkedList的区别\" class=\"headerlink\" title=\"1.11.ArrayList和linkedList的区别\"></a>1.11.ArrayList和linkedList的区别</h2><p>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。<br>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,(因为删除数据以后, 需要把后面所有的数据前移)<br>缺点: 数组初始化必须指定初始化的长度, 否则报错，例如:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//推介使用int[] 这种方式初始化</span>\n<span class=\"token keyword\">int</span> c<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">23</span><span class=\"token punctuation\">,</span><span class=\"token number\">43</span><span class=\"token punctuation\">,</span><span class=\"token number\">56</span><span class=\"token punctuation\">,</span><span class=\"token number\">78</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//长度：4，索引范围：[0,3]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。<br>List有两个重要的实现类：ArrayList和LinkedList<br>ArrayList: 可以看作是能够自动增长容量的数组<br>ArrayList的toArray方法返回一个数组<br>ArrayList的asList方法返回一个列表<br>ArrayList底层的实现是Array, 数组扩容实现<br>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</p>\n<h2 id=\"1-12-HashMap和HashTable的区别\"><a href=\"#1-12-HashMap和HashTable的区别\" class=\"headerlink\" title=\"1.12.HashMap和HashTable的区别\"></a>1.12.HashMap和HashTable的区别</h2><ul>\n<li>两者父类不同</li>\n</ul>\n<p>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p>\n<ul>\n<li>对外提供的接口不同</li>\n</ul>\n<p>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。<br>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。</p>\n<ul>\n<li>对null的支持不同</li>\n</ul>\n<p>Hashtable：key和value都不能为null。<br>HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。</p>\n<ul>\n<li>安全性不同</li>\n</ul>\n<p>HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。<br>Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。<br>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。<br>ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p>\n<ul>\n<li>初始容量大小和每次扩充容量大小不同</li>\n<li>计算hash值的方法不同</li>\n</ul>\n<h2 id=\"1-13-Collection包结构，与Collections的区别\"><a href=\"#1-13-Collection包结构，与Collections的区别\" class=\"headerlink\" title=\"1.13.Collection包结构，与Collections的区别\"></a>1.13.Collection包结构，与Collections的区别</h2><p>Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；<br>Collections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>\n<h2 id=\"1-14-Java的四种引用，强弱软虚\"><a href=\"#1-14-Java的四种引用，强弱软虚\" class=\"headerlink\" title=\"1.14. Java的四种引用，强弱软虚\"></a>1.14. Java的四种引用，强弱软虚</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用在程序内存不足时，会被回收，使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span>\n<span class=\"token comment\">// 这里的软引用指的是指向new String(\"str\")的引用，也就是SoftReference类中T</span>\n<span class=\"token class-name\">SoftReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> wrf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SoftReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>可用场景：</strong> 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> wrf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入ReferenceQueue 中。注意哦，其它引用是被JVM回收后才被传入ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用<br>例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">PhantomReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> prf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PhantomReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效<br>上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用( SoftReference 等)。</p>\n<h2 id=\"1-15-泛型常用特点\"><a href=\"#1-15-泛型常用特点\" class=\"headerlink\" title=\"1.15.泛型常用特点\"></a>1.15.泛型常用特点</h2><p>泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：<br><strong>“泛型” 意味着编写的代码可以被不同类型的对象所重用。</strong><br>“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> iniData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>使用泛型的好处？<br>以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p>\n<h2 id=\"1-16-Java创建对象有几种方式？\"><a href=\"#1-16-Java创建对象有几种方式？\" class=\"headerlink\" title=\"1.16.Java创建对象有几种方式？\"></a>1.16.Java创建对象有几种方式？</h2><p>java中提供了以下四种创建对象的方式:</p>\n<ul>\n<li>new创建新对象</li>\n<li>通过反射机制</li>\n<li>采用clone机制</li>\n<li>通过序列化机制</li>\n</ul>\n<h2 id=\"1-17-有没有可能两个不相等的对象有相同的hashcode\"><a href=\"#1-17-有没有可能两个不相等的对象有相同的hashcode\" class=\"headerlink\" title=\"1.17.有没有可能两个不相等的对象有相同的hashcode\"></a>1.17.有没有可能两个不相等的对象有相同的hashcode</h2><p>有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以下几种方式来处理:</p>\n<ul>\n<li>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</li>\n<li>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入</li>\n<li>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.</li>\n</ul>\n<h2 id=\"1-18-深拷贝和浅拷贝的区别是什么\"><a href=\"#1-18-深拷贝和浅拷贝的区别是什么\" class=\"headerlink\" title=\"1.18.深拷贝和浅拷贝的区别是什么?\"></a>1.18.深拷贝和浅拷贝的区别是什么?</h2><ul>\n<li>浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</li>\n<li>深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</li>\n</ul>\n<h2 id=\"1-19-final有哪些用法\"><a href=\"#1-19-final有哪些用法\" class=\"headerlink\" title=\"1.19.final有哪些用法?\"></a>1.19.final有哪些用法?</h2><p>final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:</p>\n<ol>\n<li>被final修饰的类不可以被继承</li>\n<li>被final修饰的方法不可以被重写</li>\n<li>被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</li>\n<li>被final修饰的方法,JVM会尝试将其内联,以提高运行效率</li>\n<li>被final修饰的常量,在编译阶段会存入常量池中.</li>\n</ol>\n<p>除此之外,编译器对final域要遵守的两个重排序规则更好:</p>\n<ol>\n<li>在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序</li>\n<li>初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序。</li>\n</ol>\n<h2 id=\"1-20-static都有哪些用法\"><a href=\"#1-20-static都有哪些用法\" class=\"headerlink\" title=\"1.20.static都有哪些用法?\"></a>1.20.static都有哪些用法?</h2><p>所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量&#x2F;方法都属于类的静态资源,类实例所共享.<br>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> calss <span class=\"token class-name\">PreCache</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">static</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//执行相关操作</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>此外static也多用于修饰内部类,此时称之为静态内部类.<br>最后一种用法就是静态导包,即 import static .import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">static</span> <span class=\"token import static\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//System.out.println(Math.sin(20));传统做法</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">sin</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"1-21-3-0-1-x3D-x3D-0-3返回值是什么\"><a href=\"#1-21-3-0-1-x3D-x3D-0-3返回值是什么\" class=\"headerlink\" title=\"1.21.3*0.1&#x3D;&#x3D;0.3返回值是什么\"></a>1.21.3*0.1&#x3D;&#x3D;0.3返回值是什么</h2><p>false,因为有些浮点数不能完全精确的表示出来</p>\n<h2 id=\"1-22-a-x3D-a-b与a-x3D-b有什么区别吗\"><a href=\"#1-22-a-x3D-a-b与a-x3D-b有什么区别吗\" class=\"headerlink\" title=\"1.22.a&#x3D;a+b与a+&#x3D;b有什么区别吗?\"></a>1.22.a&#x3D;a+b与a+&#x3D;b有什么区别吗?</h2><p>+&#x3D; 操作符会进行隐式自动类型转换,此处a+&#x3D;b隐式的将加操作的结果类型强制转换为持有结果的类型,而a&#x3D;a+b则不会自动进行类型转换.如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">byte</span> a <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">byte</span> b <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\nb <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 报编译错误:cannot convert from int to byte</span>\nb <span class=\"token operator\">+=</span> a<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>以下代码是否有错,有的话怎么改？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">short</span> s1<span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>有错误.short类型在进行运算时会自动提升为int类型,也就是说 s1+1 的运算结果是int类型,而s1是short类型,此时编译器会报错。<br>正确写法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">short</span> s1<span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>+&#x3D;操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错。</p>\n<h2 id=\"1-23-try-catch-finally，try里有return，finally还执行么？\"><a href=\"#1-23-try-catch-finally，try里有return，finally还执行么？\" class=\"headerlink\" title=\"1.23.try catch finally，try里有return，finally还执行么？\"></a>1.23.try catch finally，try里有return，finally还执行么？</h2><p>执行，并且finally的执行早于try里面的return<br>结论：</p>\n<ol>\n<li>不管有木有出现异常，finally块中代码都会执行；</li>\n<li>当try和catch中有return时，finally仍然会执行；</li>\n<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li>\n<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</li>\n</ol>\n<h2 id=\"1-24-Excption与Error包结构\"><a href=\"#1-24-Excption与Error包结构\" class=\"headerlink\" title=\"1.24.Excption与Error包结构\"></a>1.24.Excption与Error包结构</h2><p>Java可抛出(Throwable)的结构分为三种类型：被检查的异常(CheckedException)，运行时异常(RuntimeException)，错误(Error)。</p>\n<h3 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h3><p><strong>定义</strong>:RuntimeException及其子类都被称为运行时异常。<br><strong>特点</strong>:Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产生的ConcurrentModificationException异常（java.util包下面的所有的集合类都是快速失败的，“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制，这个错叫并发修改异常。Fail-safe，java.util.concurrent包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的表现。<br>ConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了。）等，都属于运行时异常。<br>常见的五种运行时异常：</p>\n<ul>\n<li>ClassCastException（类转换异常）</li>\n<li>IndexOutOfBoundsException（数组越界）</li>\n<li>NullPointerException（空指针异常）</li>\n<li>ArrayStoreException（数据存储异常，操作数组是类型不一致）</li>\n<li>BufferOverflowException</li>\n</ul>\n<h3 id=\"被检查异常\"><a href=\"#被检查异常\" class=\"headerlink\" title=\"被检查异常\"></a>被检查异常</h3><p><strong>定义</strong>:Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。<br><strong>特点</strong>: Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。被检查异常通常都是可以恢复的。<br>如：<br>IOException<br>FileNotFoundException<br>SQLException<br>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException 。</p>\n<h3 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h3><p><strong>定义</strong>: Error类及其子类。<br><strong>特点</strong>: 和运行时异常一样，编译器也不会对错误进行检查。<br>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。出现这种错误会导致程序终止运行。<br>OutOfMemoryError、ThreadDeath。<br>Java虚拟机规范规定JVM的内存分为了好几块，比如堆，栈，程序计数器，方法区等</p>\n<h2 id=\"1-25-OOM你遇到过哪些情况，SOF你遇到过哪些情况\"><a href=\"#1-25-OOM你遇到过哪些情况，SOF你遇到过哪些情况\" class=\"headerlink\" title=\"1.25.OOM你遇到过哪些情况，SOF你遇到过哪些情况\"></a>1.25.OOM你遇到过哪些情况，SOF你遇到过哪些情况</h2><h3 id=\"OutOfMemoryError异常\"><a href=\"#OutOfMemoryError异常\" class=\"headerlink\" title=\"OutOfMemoryError异常\"></a>OutOfMemoryError异常</h3><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。<br>Java Heap 溢出：<br>一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。<br>java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。<br>出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。<br>如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。<br>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p>\n<h3 id=\"虚拟机栈和本地方法栈溢出\"><a href=\"#虚拟机栈和本地方法栈溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈溢出\"></a>虚拟机栈和本地方法栈溢出</h3><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。<br>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常<br>这里需要注意当栈的大小越大可分配的线程数就越少。</p>\n<h3 id=\"运行时常量池溢出\"><a href=\"#运行时常量池溢出\" class=\"headerlink\" title=\"运行时常量池溢出\"></a>运行时常量池溢出</h3><p>异常信息：java.lang.OutOfMemoryError:PermGenspace<br>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。</p>\n<h3 id=\"方法区溢出\"><a href=\"#方法区溢出\" class=\"headerlink\" title=\"方法区溢出\"></a>方法区溢出</h3><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。<br>异常信息：java.lang.OutOfMemoryError:PermGenspace<br>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。</p>\n<h3 id=\"SOF（堆栈溢出StackOverflow）\"><a href=\"#SOF（堆栈溢出StackOverflow）\" class=\"headerlink\" title=\"SOF（堆栈溢出StackOverflow）\"></a>SOF（堆栈溢出StackOverflow）</h3><p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。<br>栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。</p>\n<h2 id=\"1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么\"><a href=\"#1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么\" class=\"headerlink\" title=\"1.26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?\"></a>1.26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。<br>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。<br>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输<br>入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间<br>内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<h2 id=\"1-27-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#1-27-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"1.27.线程有哪些基本状态？这些状态是如何定义的?\"></a>1.27.线程有哪些基本状态？这些状态是如何定义的?</h2><ul>\n<li><p>新建(new)：新创建了一个线程对象。</p>\n</li>\n<li><p>可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</p>\n</li>\n<li><p>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</p>\n</li>\n<li><p>阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>阻塞的情况分三种：<br>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。<br>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br>(三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。</p></blockquote>\n</li>\n<li><p>死亡(terminated)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301162059533.png\"></p>\n<h2 id=\"1-28-Java-中-IO-流\"><a href=\"#1-28-Java-中-IO-流\" class=\"headerlink\" title=\"1.28.Java 中 IO 流\"></a>1.28.Java 中 IO 流</h2><p>Java 中 IO 流分为几种?</p>\n<ul>\n<li>按照流的流向分，可以分为输入流和输出流；</li>\n<li>按照操作单元划分，可以划分为字节流和字符流；</li>\n<li>按照流的角色划分为节点流和处理流。</li>\n</ul>\n<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。<br><strong>InputStream&#x2F;Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br><strong>OutputStream&#x2F;Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。<br>按操作方式分类结构图：<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301162059379.png\"><br>按操作对象分类结构图：<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301162100636.png\"></p>\n<h2 id=\"1-29-java反射的作用于原理\"><a href=\"#1-29-java反射的作用于原理\" class=\"headerlink\" title=\"1.29.java反射的作用于原理\"></a>1.29.java反射的作用于原理</h2><h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。<br>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>\n<h3 id=\"哪里会用到反射机制？\"><a href=\"#哪里会用到反射机制？\" class=\"headerlink\" title=\"哪里会用到反射机制？\"></a>哪里会用到反射机制？</h3><p>jdbc就是典型的反射<br>Class.forName(‘com.mysql.jdbc.Driver.class’);&#x2F;&#x2F;加载MySQL的驱动类<br>这就是反射。如hibernate，struts等框架使用反射实现的。</p>\n<h3 id=\"反射的实现方式\"><a href=\"#反射的实现方式\" class=\"headerlink\" title=\"反射的实现方式\"></a>反射的实现方式</h3><p>获取Class对象，有4中方法：</p>\n<ol>\n<li>Class.forName(“类的路径”)；</li>\n<li>类名.class</li>\n<li>对象名.getClass()</li>\n<li>基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象</li>\n</ol>\n<h3 id=\"实现Java反射的类\"><a href=\"#实现Java反射的类\" class=\"headerlink\" title=\"实现Java反射的类\"></a>实现Java反射的类</h3><ol>\n<li>Class：表示正在运行的Java应用程序中的类和接口（注意： 所有获取对象的信息都需要Class类来实现）。</li>\n<li>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</li>\n<li>Constructor：提供关于类的单个构造方法的信息以及它的访问权限</li>\n<li>Method：提供类或接口中某个方法的信息</li>\n</ol>\n<h3 id=\"反射机制的优缺点\"><a href=\"#反射机制的优缺点\" class=\"headerlink\" title=\"反射机制的优缺点\"></a>反射机制的优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>能够运行时动态获取类的实例，提高灵活性；</li>\n<li>与动态编译结合</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li><p>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>解决方案：<br>1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度；<br>2、多次创建一个类的实例时，有缓存会快很多<br>3、ReflectASM工具类，通过字节码生成的方式加快反射速度</p></blockquote>\n</li>\n<li><p>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</p>\n</li>\n</ol>\n<h2 id=\"1-30-说说List-Set-Map三者的区别？\"><a href=\"#1-30-说说List-Set-Map三者的区别？\" class=\"headerlink\" title=\"1.30.说说List,Set,Map三者的区别？\"></a>1.30.说说List,Set,Map三者的区别？</h2><p><strong>List(对付顺序的好帮手)</strong>: List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象<br><strong>Set(注重独一无二的性质)</strong>: 不允许重复的集合。不会有多个元素引用相同的对象。<br><strong>Map(用Key来搜索的专家)</strong>: 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p>\n<h1 id=\"二、JVM篇\"><a href=\"#二、JVM篇\" class=\"headerlink\" title=\"二、JVM篇\"></a>二、JVM篇</h1><h2 id=\"2-1-知识点汇总\"><a href=\"#2-1-知识点汇总\" class=\"headerlink\" title=\"2.1.知识点汇总\"></a>2.1.知识点汇总</h2><p>JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高。由于脑图内容实在过于庞大，这里就不展开了，详情可见：<a href=\"https://www.processon.com/view/link/63c6114575fa681b61283d3d\">JVM知识点</a>。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301171748391.png\"></p>\n<h2 id=\"2-2-知识点详解\"><a href=\"#2-2-知识点详解\" class=\"headerlink\" title=\"2.2.知识点详解\"></a>2.2.知识点详解</h2><h3 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h3><p>线程独占:栈,本地方法栈,程序计数器<br>线程共享:堆,方法区</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法<br>出口等信息.调用方法时执行入栈,方法返回式执行出栈.</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现</p>\n<h3 id=\"JVM-内存可见性\"><a href=\"#JVM-内存可见性\" class=\"headerlink\" title=\"JVM 内存可见性\"></a>JVM 内存可见性</h3><p>JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证</p>\n<h2 id=\"2-3-类加载与卸载\"><a href=\"#2-3-类加载与卸载\" class=\"headerlink\" title=\"2.3.类加载与卸载\"></a>2.3.类加载与卸载</h2><h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301171749000.jpeg\"><br>JVM类加载过程分为：加载 、链接 、初始化 、使用 、卸载 这五个阶段，其中链接阶段又包括： 验证 、 准备 、 解析 。<br><strong>加载</strong> ：通过类的完全限定名，查找此类的二进制字节码文件，通过该字节码文件创建Class对象。<br><strong>链接</strong> ：包含 验证 、 准备 、 解析 三个阶段：</p>\n<ul>\n<li><strong>验证</strong> ：确保Class文件复合虚拟机规定的Class文件格式，包含文件格式验证、元数据验证、字节码验证、引用符号验证。</li>\n<li><strong>准备</strong> ：为类的静态变量分配内存并设置初始化值，注：这里不包含final修饰的静态变量，因为final修饰的静态变量是在编译期分配。</li>\n<li><strong>解析</strong> ：将常量池的间接引用转换为直接引用，解析包含字段解析、接口解析、方法解析。</li>\n</ul>\n<p><strong>初始化</strong> ：初始化静态变量和静态块，先初始化父类，再初始化当前类，只有对类主动时才会初始化。<br><strong>使用</strong> ：程序代码执行时使用，new出对象程序中使用。<br><strong>卸载</strong> ：程序代码退出、异常、结束等，执行垃圾回收。</p>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><ul>\n<li>创建类的实例，也就是new一个对象。</li>\n<li>访问类的静态方法或者静态变量（包含静态变量赋值）。</li>\n<li>使用Class.forName()反射类。</li>\n<li>子类初始化的时候。</li>\n<li>JVM启动时标明的启动类。</li>\n</ul>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>类加载器包括启动类加载器、扩展类加载器、系统类加载器、自定义类加载器四种加载器。</p>\n<p><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载Java类的核心类，是用原生代码实现。下面代码可以获得启动类加载器所加载的Java核心类库。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token constant\">URL</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> urLs <span class=\"token operator\">=</span> <span class=\"token class-name\">Launcher</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBootstrapClassPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getURLs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token constant\">URL</span> url <span class=\"token operator\">:</span> urLs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">toExternalForm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>扩展类加载器（Extensions ClassLoader）</strong>：负责加载JRE的扩展目录lib&#x2F;ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为Null。</p>\n<p><strong>系统类加载器（System Class Loader）</strong>：负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性。可以通过ClassLoader.getSystemClassLoader()方法获取当前系统类加载器，一般情况是自定义类加载器的父加载器。由Java语言实现，父类加载器为扩展类加载器。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSystemClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSystemClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>自定义类加载器（Custom ClassLoader）</strong>：用户可以通过继承ClassLoader类实现自定义类加载器。由Java语言实现，自定义类加载器的父类是系统类加载器。</p>\n<h3 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h3><p>JVM的类加载机制主要有全盘负责、双亲委派、缓存机制三种加载机制。</p>\n<ul>\n<li><strong>全盘负责</strong>：当一个类加载器加载某个Class时，该Class所依赖和引用其他Class也会由该类加载器负责加载，除非指定了使用其他类加载器加载。</li>\n<li><strong>双亲委派</strong>：先让父类加载器加载该Class，只有在父类加载器无法加载该类时才尝试使用自己的类加载器加载。通俗的讲就是在某个特定的类加载器接到加载类请求时，先寄托给父加载器加载，依次递归，如果父加载器可以加载时则成功返回，如果不可以加载就自己去加载。</li>\n<li><strong>缓存机制</strong>：缓存机制会确保所有加载过的Class都被会缓存，当程序中需要某个Class时，类加载器先从缓存区中搜索该Class，只有缓存区中不存在该Class对象时，系统才会读取该类的二进制数据，并将其转换为Class对象，存入缓存区。这就是为什么我们修改Class文件之后，必须重启JVM才会生效的原因。</li>\n</ul>\n<p>其中<strong>双亲委派机制优势</strong>：</p>\n<ul>\n<li>父类加载器成功加载则返回，子类加载器不会再加载，防止了重复加载。</li>\n<li>防止核心API库被随意篡改。比如有一个要加载java.lang.Integer类的请求，通过双亲委派进制加载传递到启动类加载器，在在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，可以防止核心API被随意篡改。</li>\n</ul>\n<h3 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h3><h4 id=\"G1算法\"><a href=\"#G1算法\" class=\"headerlink\" title=\"G1算法\"></a>G1算法</h4><p>1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全部的增量式清理,以保证停顿时间不会过长。<br>其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区。<br>同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间。<br><strong>年轻代回收</strong>:<br>并行复制采用复制算法,并行收集,会StopTheWorld.<br><strong>老年代回收</strong>:<br>会对年轻代一并回收<br>初始标记完成堆root对象的标记,会StopTheWorld.<br>并发标记 GC线程和应用线程并发执行.<br>最终标记完成三色标记周期,会StopTheWorld.<br>复制&#x2F;清楚会优先对可回收空间加大的区域进行回收</p>\n<h4 id=\"ZGC算法\"><a href=\"#ZGC算法\" class=\"headerlink\" title=\"ZGC算法\"></a>ZGC算法</h4><p>高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停顿时间</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>着色指针<br>读屏障<br>并发处理<br>基于region<br>内存压缩(整理)</p></blockquote>\n<p>roots标记：标记root对象,会StopTheWorld。<br>并发标记：利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld。<br>清除会清理标记为不可用的对象。<br>roots重定位：是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生。重定位最开始会StopTheWorld,却决于重定位集与对象总活动集的比例。<br>并发重定位与并发标记类似。</p>\n<h2 id=\"2-4-简述一下JVM的内存模型\"><a href=\"#2-4-简述一下JVM的内存模型\" class=\"headerlink\" title=\"2.4.简述一下JVM的内存模型\"></a>2.4.简述一下JVM的内存模型</h2><p>JVM定义了不同运行时数据区，他们是用来执行应用程序的。某些区域随着JVM启动及销毁，另外一些区域的数据是线程性独立的，随着线程创建和销毁。</p>\n<h3 id=\"线程私有区\"><a href=\"#线程私有区\" class=\"headerlink\" title=\"线程私有区\"></a>线程私有区</h3><h4 id=\"程序计数器-1\"><a href=\"#程序计数器-1\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p>当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。</p>\n<h4 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h4><p>线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。</p>\n<h4 id=\"本地方法栈-1\"><a href=\"#本地方法栈-1\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p>\n<h3 id=\"线程共享区\"><a href=\"#线程共享区\" class=\"headerlink\" title=\"线程共享区\"></a>线程共享区</h3><h4 id=\"方法区-1\"><a href=\"#方法区-1\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><p>线程共享的，用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。若要分代，算是永久代（老年代），以前类大多“static”的，很少被卸载或收集，现回收废弃常量和无用的类。其中运行时常量池存放编译生成的各种常量。（如果hotspot虚拟机确定一个类的定义信息<br>不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收）</p>\n<h4 id=\"堆-1\"><a href=\"#堆-1\" class=\"headerlink\" title=\"堆\"></a>堆</h4><p>存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的Eden区中，经过GC后进入新生代的S0区中，再经过GC进入新生代的S1区中，15次GC后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则OutOfMemoryError。</p>\n<h2 id=\"2-5-堆和栈的区别\"><a href=\"#2-5-堆和栈的区别\" class=\"headerlink\" title=\"2.5.堆和栈的区别\"></a>2.5.堆和栈的区别</h2><p>栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。<br><strong>1、功能不同</strong><br>栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。<br><strong>2、共享性不同</strong><br>栈内存是线程私有的。<br>堆内存是所有线程共有的。<br><strong>3、异常错误不同</strong><br>如果栈内存或者堆内存不足都会抛出异常。<br>栈空间不足：java.lang.StackOverFlowError。<br>堆空间不足：java.lang.OutOfMemoryError。<br><strong>4、空间大小</strong><br>栈的空间大小远远小于堆的</p>\n<h2 id=\"2-6-什么时候会触发FullGC\"><a href=\"#2-6-什么时候会触发FullGC\" class=\"headerlink\" title=\"2.6.什么时候会触发FullGC\"></a>2.6.什么时候会触发FullGC</h2><p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p>\n<ol>\n<li><p>旧生代空间不足</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></blockquote>\n</li>\n<li><p>Permanet Generation空间满</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote>\n</li>\n<li><p>CMS GC时出现promotion failed和concurrent mode failure</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。<br>应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime&#x3D;5（单位为ms）来避免。</p></blockquote>\n</li>\n<li><p>统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。<br>例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。<br>当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。<br>除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java Dsun.rmi.dgc.client.gcInterval&#x3D;3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p></blockquote>\n</li>\n</ol>\n<h2 id=\"2-7-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？\"><a href=\"#2-7-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？\" class=\"headerlink\" title=\"2.7.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？\"></a>2.7.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>\n<h2 id=\"2-8-Java内存结构\"><a href=\"#2-8-Java内存结构\" class=\"headerlink\" title=\"2.8.Java内存结构\"></a>2.8.Java内存结构</h2><p>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。<br><strong>Java堆（Heap）</strong>,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br><strong>方法区（Method Area）</strong>,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<br><strong>JVM栈（JVM Stacks）</strong>,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><strong>本地方法栈（Native Method Stacks）</strong>,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>\n<h2 id=\"2-9-对象分配规则\"><a href=\"#2-9-对象分配规则\" class=\"headerlink\" title=\"2.9.对象分配规则\"></a>2.9.对象分配规则</h2><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。<br>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。<br>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。<br>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。<br>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</p>\n<h2 id=\"2-10-Java对象创建过程\"><a href=\"#2-10-Java对象创建过程\" class=\"headerlink\" title=\"2.10.Java对象创建过程\"></a>2.10.Java对象创建过程</h2><ol>\n<li>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</li>\n<li>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</li>\n<li>将除对象头外的对象内存空间初始化为0</li>\n<li>对对象头进行必要设置</li>\n</ol>\n<h2 id=\"2-11-类的生命周期\"><a href=\"#2-11-类的生命周期\" class=\"headerlink\" title=\"2.11.类的生命周期\"></a>2.11.类的生命周期</h2><p>类的生命周期包括这几个部分，<strong>加载、连接、初始化、使用和卸载</strong>，其中前三部是类的加载的过程加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象连接，连接又包含三块内容：<strong>验证、准备、初始化。</strong></p>\n<h2 id=\"2-12-简述Java的对象结构\"><a href=\"#2-12-简述Java的对象结构\" class=\"headerlink\" title=\"2.12.简述Java的对象结构\"></a>2.12.简述Java的对象结构</h2><p>Java对象由三个部分组成：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<br><strong>对象头</strong>由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32&#x2F;64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。<br><strong>实例数据</strong>用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）<br><strong>对齐填充</strong>：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）</p>\n<h2 id=\"2-13-如何判断对象可以被回收？\"><a href=\"#2-13-如何判断对象可以被回收？\" class=\"headerlink\" title=\"2.13.如何判断对象可以被回收？\"></a>2.13.如何判断对象可以被回收？</h2><p>判断对象是否存活一般有两种方式：<br><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。<br><strong>可达性分析（Reachability Analysis）</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p>\n<h2 id=\"2-14-JVM的永久代中会发生垃圾回收么？\"><a href=\"#2-14-JVM的永久代中会发生垃圾回收么？\" class=\"headerlink\" title=\"2.14.JVM的永久代中会发生垃圾回收么？\"></a>2.14.JVM的永久代中会发生垃圾回收么？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>\n<h2 id=\"2-15-垃圾收集算法\"><a href=\"#2-15-垃圾收集算法\" class=\"headerlink\" title=\"2.15.垃圾收集算法\"></a>2.15.垃圾收集算法</h2><p>GC最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。<br><strong>标记 -清除算法</strong>，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。<br><strong>复制算法</strong>，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br><strong>标记-压缩算法</strong>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br><strong>分代收集算法</strong>，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>\n<h2 id=\"2-16-调优命令有哪些？\"><a href=\"#2-16-调优命令有哪些？\" class=\"headerlink\" title=\"2.16.调优命令有哪些？\"></a>2.16.调优命令有哪些？</h2><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo<br><strong>jps</strong>，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。<br><strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。<br><strong>jmap</strong>，JVM Memory Map命令用于生成heap dump文件<br><strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看<br><strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。<br><strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p>\n<h2 id=\"2-17-调优工具\"><a href=\"#2-17-调优工具\" class=\"headerlink\" title=\"2.17.调优工具\"></a>2.17.调优工具</h2><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。<br><strong>jconsole</strong>，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控<br><strong>jvisualvm</strong>，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。<br>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br><strong>GChisto</strong>，一款专业分析gc日志的工具</p>\n<h2 id=\"2-18-Minor-GC与Full-GC分别在什么时候发生？\"><a href=\"#2-18-Minor-GC与Full-GC分别在什么时候发生？\" class=\"headerlink\" title=\"2.18.Minor GC与Full GC分别在什么时候发生？\"></a>2.18.Minor GC与Full GC分别在什么时候发生？</h2><p>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC</p>\n<h2 id=\"2-19-你知道哪些JVM性能调优\"><a href=\"#2-19-你知道哪些JVM性能调优\" class=\"headerlink\" title=\"2.19.你知道哪些JVM性能调优\"></a>2.19.你知道哪些JVM性能调优</h2><p><strong>设定堆内存大小</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-Xmx：堆内存最大限制。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>设定新生代大小</strong>。 新生代不宜太小，否则会有大量对象涌入老年代</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-XX:NewSize：新生代大小\n-XX:NewRatio 新生代和老生代占比\n-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>设定垃圾回收器</strong> 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC</p>\n<h2 id=\"2-20-简述Java垃圾回收机制\"><a href=\"#2-20-简述Java垃圾回收机制\" class=\"headerlink\" title=\"2.20.简述Java垃圾回收机制?\"></a>2.20.简述Java垃圾回收机制?</h2><p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收</p>\n<h2 id=\"2-21-什么是类加载器，类加载器有哪些\"><a href=\"#2-21-什么是类加载器，类加载器有哪些\" class=\"headerlink\" title=\"2.21.什么是类加载器，类加载器有哪些?\"></a>2.21.什么是类加载器，类加载器有哪些?</h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。<br>主要有一下四种类加载器:<br>**启动类加载器(Bootstrap ClassLoader)**用来加载java核心类库，无法被java程序直接引用。<br><strong>扩展类加载器(extensions class loader)</strong>:它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br><strong>系统类加载器（system class loader）</strong>：它根据 Java 应用的类路径(CLASSPATH）来加载 Java类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。<br><strong>用户自定义类加载器</strong>，通过继承 java.lang.ClassLoader类的方式实现。</p>\n<h2 id=\"2-22-你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理-过程中有哪些收获？\"><a href=\"#2-22-你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理-过程中有哪些收获？\" class=\"headerlink\" title=\"2.22.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？\"></a>2.22.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？</h2><p>常见的原因:<br>内存加载的数据量太大：一次性从数据库取太多数据；<br>集合类中有对对象的引用，使用后未清空，GC不能进行回收；<br>代码中存在循环产生过多的重复对象；<br>启动参数堆内存值小。</p>\n<h2 id=\"2-23-JDK-1-8之后Perm-Space有哪些变动-MetaSpace⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩\"><a href=\"#2-23-JDK-1-8之后Perm-Space有哪些变动-MetaSpace⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩\" class=\"headerlink\" title=\"2.23.JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?\"></a>2.23.JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?</h2><p>JDK 1.8后用元空间替代了 Perm Space；字符串常量存放到堆内存中。<br>MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。<br><strong>-XX:MetaspaceSize</strong>：分配给类元数据空间（以字节计）的初始大小（Oracle逻辑存储上的初始高水位，the initial high-water-mark）。此值为估计值，MetaspaceSize的值设置的过大会延长垃圾回收时<br>间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。<br><strong>-XX:MaxMetaspaceSize</strong>：分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</p>\n<p><strong>持续更新中….</strong></p>\n","text":" 2023年1月份最新基础汇总篇，Java开发技术栈知识点都有涉及，主要面向1-2年修为的浪浪山小妖，温故而知新旅游前读这一篇就够了 一、基础篇1.1.Java语言有哪些特点 简单易学、有丰富的类库 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高） 与平台无关性（J...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"浪浪山打工人","slug":"浪浪山打工人","count":2,"path":"api/categories/浪浪山打工人.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":4,"path":"api/tags/JAVA.json"},{"name":"Java基础","slug":"Java基础","count":3,"path":"api/tags/Java基础.json"},{"name":"Java面试题","slug":"Java面试题","count":2,"path":"api/tags/Java面试题.json"},{"name":"2023汇总篇","slug":"2023汇总篇","count":1,"path":"api/tags/2023汇总篇.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87\"><span class=\"toc-text\">一、基础篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-Java%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.1.Java语言有哪些特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.2.面向对象和面向过程的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E5%B0%81%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">1.3.八种基本数据类型的大小，以及他们的封装类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">1.4.标识符的命名规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-instanceof-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.5.instanceof 关键字的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">1.6.Java自动装箱与拆箱</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.7.重载和重写的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99-Override\"><span class=\"toc-text\">重写(Override)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">重写总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89\"><span class=\"toc-text\">重载（Overload）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">重载总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-equals%E4%B8%8E-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.8.equals与&#x3D;&#x3D;的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D-x3D\"><span class=\"toc-text\">&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#equals\"><span class=\"toc-text\">equals</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-9-Hashcode%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.9.Hashcode的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-10-String%E3%80%81String-StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.10.String、String StringBuffer 和 StringBuilder 的区别是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-11-ArrayList%E5%92%8ClinkedList%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.11.ArrayList和linkedList的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-12-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.12.HashMap和HashTable的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-13-Collection%E5%8C%85%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%8ECollections%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.13.Collection包结构，与Collections的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-14-Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%BA%E5%BC%B1%E8%BD%AF%E8%99%9A\"><span class=\"toc-text\">1.14. Java的四种引用，强弱软虚</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">强引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">软引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%B1%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">弱引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">虚引用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-15-%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.15.泛型常用特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-16-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">1.16.Java创建对象有几种方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-17-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode\"><span class=\"toc-text\">1.17.有没有可能两个不相等的对象有相同的hashcode</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-18-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.18.深拷贝和浅拷贝的区别是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-19-final%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.19.final有哪些用法?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-20-static%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.20.static都有哪些用法?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-21-3-0-1-x3D-x3D-0-3%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.21.3*0.1&#x3D;&#x3D;0.3返回值是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-22-a-x3D-a-b%E4%B8%8Ea-x3D-b%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97\"><span class=\"toc-text\">1.22.a&#x3D;a+b与a+&#x3D;b有什么区别吗?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-23-try-catch-finally%EF%BC%8Ctry%E9%87%8C%E6%9C%89return%EF%BC%8Cfinally%E8%BF%98%E6%89%A7%E8%A1%8C%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.23.try catch finally，try里有return，finally还执行么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-24-Excption%E4%B8%8EError%E5%8C%85%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.24.Excption与Error包结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">运行时异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A2%AB%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">被检查异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">错误</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-25-OOM%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%8CSOF%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5\"><span class=\"toc-text\">1.25.OOM你遇到过哪些情况，SOF你遇到过哪些情况</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OutOfMemoryError%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">OutOfMemoryError异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">虚拟机栈和本地方法栈溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">运行时常量池溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">方法区溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SOF%EF%BC%88%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BAStackOverflow%EF%BC%89\"><span class=\"toc-text\">SOF（堆栈溢出StackOverflow）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-26-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%82%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-27-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9F%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84\"><span class=\"toc-text\">1.27.线程有哪些基本状态？这些状态是如何定义的?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-28-Java-%E4%B8%AD-IO-%E6%B5%81\"><span class=\"toc-text\">1.28.Java 中 IO 流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-29-java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.29.java反射的作用于原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F\"><span class=\"toc-text\">什么是反射？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">哪里会用到反射机制？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">反射的实现方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0Java%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">实现Java反射的类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">反射机制的优缺点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">缺点</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-30-%E8%AF%B4%E8%AF%B4List-Set-Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">1.30.说说List,Set,Map三者的区别？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81JVM%E7%AF%87\"><span class=\"toc-text\">二、JVM篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">2.1.知识点汇总</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">2.2.知识点详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">JVM内存模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><span class=\"toc-text\">本地方法栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">程序计数器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">方法区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVM-%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">JVM 内存可见性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD\"><span class=\"toc-text\">2.3.类加载与卸载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">类加载过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">类加载时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">类加载器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">类加载机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">回收算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#G1%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">G1算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ZGC%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">ZGC算法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.4.简述一下JVM的内存模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA\"><span class=\"toc-text\">线程私有区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-1\"><span class=\"toc-text\">程序计数器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">虚拟机栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-1\"><span class=\"toc-text\">本地方法栈</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA\"><span class=\"toc-text\">线程共享区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA-1\"><span class=\"toc-text\">方法区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86-1\"><span class=\"toc-text\">堆</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.5.堆和栈的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91FullGC\"><span class=\"toc-text\">2.6.什么时候会触发FullGC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-%E4%BB%80%E4%B9%88%E6%98%AFJava%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Java%E8%A2%AB%E7%A7%B0%E4%BD%9C%E6%98%AF%E2%80%9C%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%9D%EF%BC%9F\"><span class=\"toc-text\">2.7.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.8.Java内存结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-9-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">2.9.对象分配规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-10-Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">2.10.Java对象创建过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-11-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">2.11.类的生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-12-%E7%AE%80%E8%BF%B0Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.12.简述Java的对象结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-13-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F\"><span class=\"toc-text\">2.13.如何判断对象可以被回收？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-14-JVM%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">2.14.JVM的永久代中会发生垃圾回收么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-15-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.15.垃圾收集算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-16-%E8%B0%83%E4%BC%98%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">2.16.调优命令有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-17-%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">2.17.调优工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-18-Minor-GC%E4%B8%8EFull-GC%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%EF%BC%9F\"><span class=\"toc-text\">2.18.Minor GC与Full GC分别在什么时候发生？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-19-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BJVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">2.19.你知道哪些JVM性能调优</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-20-%E7%AE%80%E8%BF%B0Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.20.简述Java垃圾回收机制?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-21-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">2.21.什么是类加载器，类加载器有哪些?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-22-%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87OutOfMemory%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F%E5%A4%84%E7%90%86-%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B6%E8%8E%B7%EF%BC%9F\"><span class=\"toc-text\">2.22.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-23-JDK-1-8%E4%B9%8B%E5%90%8EPerm-Space%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8A%A8-MetaSpace%E2%BC%A4%E2%BC%A9%E9%BB%98%E8%AE%A4%E6%98%AF%E2%BD%86%E9%99%90%E7%9A%84%E4%B9%88-%E8%BF%98%E6%98%AF%E4%BD%A0%E4%BB%AC%E4%BC%9A%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E2%BD%85%E5%BC%8F%E6%9D%A5%E6%8C%87%E5%AE%9A%E2%BC%A4%E2%BC%A9\"><span class=\"toc-text\">2.23.JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?</span></a></li></ol></li></ol>","author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> 浪浪山打工人 <br /> @ <b>TG：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Druid监控导致的内存溢出问题定位处理","uid":"9736882d32005a945dbd1b55fb5920ee","slug":"Java/Druid监控导致的内存溢出问题定位处理","date":"2018-08-06T06:03:15.000Z","updated":"2023-01-17T07:32:06.801Z","comments":true,"path":"api/articles/Java/Druid监控导致的内存溢出问题定位处理.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/jks.jpg","text":"0、起因 一台部署于商户私有云中的应用频繁宕机，经查为 OOM，周期大约一周一次，较规律，所谓千里之堤毁于蚁穴，初步怀疑是轻微的内存泄漏不断积累导致的内存溢出，所以再次宕机出现时果断 dump 内存镜像开始分析 1、内存溢出原理 常见内存溢出： 相信通过写 java 程序讨生活的...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":7,"path":"api/categories/JAVA.json"}],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"OOM","slug":"OOM","count":2,"path":"api/tags/OOM.json"},{"name":"Druid","slug":"Druid","count":1,"path":"api/tags/Druid.json"}],"author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> 浪浪山打工人 <br /> @ <b>TG：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"浪浪山打工人旅游指南（零）系列的起源","uid":"b560fa9a3b1b6316fdcd91b0b326e0f3","slug":"浪浪山打工人/浪浪山打工人旅游指南（零）系列的起源","date":"2023-01-16T11:26:11.000Z","updated":"2023-01-17T10:16:02.819Z","comments":true,"path":"api/articles/浪浪山打工人/浪浪山打工人旅游指南（零）系列的起源.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/lls.jpg","text":" “我想离开浪浪山”，小猪妖如是说道。 每一个打工人都身处于困住自己的浪浪山里，在干着“大王让我来巡山”的工作，想要走出去闯闯，却要被身边的声音所左右。 最终也没有勇气走出浪浪山，或者说当你离开这座浪浪山后，你会发现有无数个浪浪山…… 小猪妖的故事触动了很多打工人的心，让无数人直...","link":"","photos":[],"count_time":{"symbolsCount":717,"symbolsTime":"1 mins."},"categories":[{"name":"浪浪山打工人","slug":"浪浪山打工人","count":2,"path":"api/categories/浪浪山打工人.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":4,"path":"api/tags/JAVA.json"},{"name":"Java基础","slug":"Java基础","count":3,"path":"api/tags/Java基础.json"},{"name":"Java面试题","slug":"Java面试题","count":2,"path":"api/tags/Java面试题.json"}],"author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> 浪浪山打工人 <br /> @ <b>TG：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}