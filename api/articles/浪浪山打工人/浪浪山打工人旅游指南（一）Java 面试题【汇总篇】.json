{"title":"浪浪山打工人旅游指南（一）Java 面试题【汇总篇】","uid":"c498ccbc5dc4c0c1651c7cd1edb0e954","slug":"浪浪山打工人/浪浪山打工人旅游指南（一）Java 面试题【汇总篇】","date":"2023-01-16T13:58:28.000Z","updated":"2023-01-22T07:11:07.335Z","comments":true,"path":"api/articles/浪浪山打工人/浪浪山打工人旅游指南（一）Java 面试题【汇总篇】.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/lls.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>2023年1月份最新基础汇总篇，Java开发技术栈知识点都有涉及，主要面向1-2年修为的浪浪山小妖，温故而知新<br>旅游前读这一篇就够了</p></blockquote>\n<h1 id=\"一、基础篇\"><a href=\"#一、基础篇\" class=\"headerlink\" title=\"一、基础篇\"></a>一、基础篇</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>基础篇可搭配<a href=\"https://www.alihai5.com/post/Java%2FJava%20%E6%8A%80%E6%9C%AF%E6%A0%88%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89\">Java 技术栈（基础篇）</a> 食用。</p></blockquote>\n<h2 id=\"1-1-Java语言有哪些特点\"><a href=\"#1-1-Java语言有哪些特点\" class=\"headerlink\" title=\"1.1.Java语言有哪些特点\"></a>1.1.Java语言有哪些特点</h2><ol>\n<li>简单易学、有丰富的类库</li>\n<li>面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）</li>\n<li>与平台无关性（JVM是Java跨平台使用的根本）</li>\n<li>可靠安全</li>\n<li>支持多线程</li>\n</ol>\n<h2 id=\"1-2-面向对象和面向过程的区别\"><a href=\"#1-2-面向对象和面向过程的区别\" class=\"headerlink\" title=\"1.2.面向对象和面向过程的区别\"></a>1.2.面向对象和面向过程的区别</h2><p><strong>面向过程</strong>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发。<br><strong>面向对象</strong>：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p>\n<h2 id=\"1-3-八种基本数据类型的大小，以及他们的封装类\"><a href=\"#1-3-八种基本数据类型的大小，以及他们的封装类\" class=\"headerlink\" title=\"1.3.八种基本数据类型的大小，以及他们的封装类\"></a>1.3.八种基本数据类型的大小，以及他们的封装类</h2><table>\n<thead>\n<tr>\n<th><strong>基本类型</strong></th>\n<th><strong>大小（字节）</strong></th>\n<th><strong>默认值</strong></th>\n<th><strong>封装类</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>1</td>\n<td>(byte)0</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>(short)0</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>0</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8</td>\n<td>0L</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>0.0f</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>0.0d</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>-</td>\n<td>false</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>2</td>\n<td>\\u0000(null)</td>\n<td>Character</td>\n</tr>\n</tbody></table>\n<ol>\n<li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li>\n<li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</li>\n</ol>\n<p>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</p>\n<h2 id=\"1-4-标识符的命名规则\"><a href=\"#1-4-标识符的命名规则\" class=\"headerlink\" title=\"1.4.标识符的命名规则\"></a>1.4.标识符的命名规则</h2><p><strong>标识符的含义：</strong><br>是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。<br><strong>命名规则：（硬性要求）</strong><br>标识符可以包含英文字母，0-9的数字，$以及_<br>标识符不能以数字开头<br>标识符不是关键字<br><strong>命名规范：（非硬性要求）</strong><br>类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。<br>变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。<br>方法名规范：同变量名。</p>\n<h2 id=\"1-5-instanceof-关键字的作用\"><a href=\"#1-5-instanceof-关键字的作用\" class=\"headerlink\" title=\"1.5.instanceof 关键字的作用\"></a>1.5.instanceof 关键字的作用</h2><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> result <span class=\"token operator\">=</span> obj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Class</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。<br>注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//编译不通过 i必须是引用类型，不能是基本类型</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//编译不通过</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integer <span class=\"token keyword\">instanceof</span>  <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回false。</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"1-6-Java自动装箱与拆箱\"><a href=\"#1-6-Java自动装箱与拆箱\" class=\"headerlink\" title=\"1.6.Java自动装箱与拆箱\"></a>1.6.Java自动装箱与拆箱</h2><p><strong>装箱</strong>就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的valueOf(int) 方法<br><strong>拆箱</strong>就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）。调用方法：Integer的intValue方法<br>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>面试题1： 以下代码会输出什么？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n   \n    <span class=\"token class-name\">Integer</span> i1 <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Integer</span> i2 <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Integer</span> i3 <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Integer</span> i4 <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n   \n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i1<span class=\"token operator\">==</span>i2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i3<span class=\"token operator\">==</span>i4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行结果:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Integer</span> <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> <span class=\"token operator\">-</span><span class=\"token number\">128</span> <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token class-name\">IntegerCache</span><span class=\"token punctuation\">.</span>high<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">IntegerCache</span><span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">128</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中IntegerCache类的实现为：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">IntegerCache</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Integer</span> cache<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> low <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">128</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// high value may be configured by property</span>\n      <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>integerCacheHighPropValue <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// Use Long.decode here to avoid invoking methods that</span>\n        <span class=\"token comment\">// require Integer's autoboxing cache to be initialized</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>integerCacheHighPropValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        i <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">127</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// Maximum array size is Integer.MAX_VALUE</span>\n        h <span class=\"token operator\">=</span> <span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span> <span class=\"token operator\">-</span> <span class=\"token operator\">-</span>low<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n      high <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n      cache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>high <span class=\"token operator\">-</span> low<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> low<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> cache<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        cache<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">IntegerCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。<br>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。<br>面试题2：以下代码输出什么？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n   \n    <span class=\"token class-name\">Double</span> i1 <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Double</span> i2 <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Double</span> i3 <span class=\"token operator\">=</span> <span class=\"token number\">200.0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Double</span> i4 <span class=\"token operator\">=</span> <span class=\"token number\">200.0</span><span class=\"token punctuation\">;</span>\n   \n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i1<span class=\"token operator\">==</span>i2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i3<span class=\"token operator\">==</span>i4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>\n<h2 id=\"1-7-重载和重写的区别\"><a href=\"#1-7-重载和重写的区别\" class=\"headerlink\" title=\"1.7.重载和重写的区别\"></a>1.7.重载和重写的区别</h2><h3 id=\"重写-Override\"><a href=\"#重写-Override\" class=\"headerlink\" title=\"重写(Override)\"></a>重写(Override)</h3><p>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// TODO Auto-generated method stub</span>\n    <span class=\"token class-name\">Son</span> s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Son</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Son</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Father</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// TODO Auto-generated method stub</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello by \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"重写总结\"><a href=\"#重写总结\" class=\"headerlink\" title=\"重写总结\"></a>重写总结</h3><ol>\n<li>发生在父类与子类之间</li>\n<li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</li>\n<li>访问修饰符的限制一定要大于被重写方法的访问修饰符(public&gt;protected&gt;default&gt;private)</li>\n<li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li>\n</ol>\n<h3 id=\"重载（Overload）\"><a href=\"#重载（Overload）\" class=\"headerlink\" title=\"重载（Overload）\"></a>重载（Overload）</h3><p>在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// TODO Auto-generated method stub</span>\n    <span class=\"token class-name\">Father</span> s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Father</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wintershii\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"重载总结\"><a href=\"#重载总结\" class=\"headerlink\" title=\"重载总结\"></a>重载总结</h3><ol>\n<li>重载Overload是一个类中多态性的一种表现</li>\n<li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li>\n<li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li>\n</ol>\n<h2 id=\"1-8-equals与-x3D-x3D-的区别\"><a href=\"#1-8-equals与-x3D-x3D-的区别\" class=\"headerlink\" title=\"1.8.equals与&#x3D;&#x3D;的区别\"></a>1.8.equals与&#x3D;&#x3D;的区别</h2><h3 id=\"x3D-x3D\"><a href=\"#x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;\"></a>&#x3D;&#x3D;</h3><p>&#x3D;&#x3D; 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p>\n<ol>\n<li>比较的是操作符两端的操作数是否是同一个对象。</li>\n<li>两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。</li>\n<li>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true），因为他们都指向地址为10的堆。</li>\n</ol>\n<h3 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h3><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“&#x3D;&#x3D;”，替换成equals</p>\n<h2 id=\"1-9-Hashcode的作用\"><a href=\"#1-9-Hashcode的作用\" class=\"headerlink\" title=\"1.9.Hashcode的作用\"></a>1.9.Hashcode的作用</h2><p>java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。<br>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。<br>hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。<br>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>\n<h2 id=\"1-10-String、String-StringBuffer-和-StringBuilder-的区别是什么\"><a href=\"#1-10-String、String-StringBuffer-和-StringBuilder-的区别是什么\" class=\"headerlink\" title=\"1.10.String、String StringBuffer 和 StringBuilder 的区别是什么?\"></a>1.10.String、String StringBuffer 和 StringBuilder 的区别是什么?</h2><p>String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">char</span> value<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符。<br>StringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n  * The value is used for character storage.\n  */</span>\n  <span class=\"token keyword\">char</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> value<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>\n<h2 id=\"1-11-ArrayList和linkedList的区别\"><a href=\"#1-11-ArrayList和linkedList的区别\" class=\"headerlink\" title=\"1.11.ArrayList和linkedList的区别\"></a>1.11.ArrayList和linkedList的区别</h2><p>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。<br>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,(因为删除数据以后, 需要把后面所有的数据前移)<br>缺点: 数组初始化必须指定初始化的长度, 否则报错，例如:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//推介使用int[] 这种方式初始化</span>\n<span class=\"token keyword\">int</span> c<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">23</span><span class=\"token punctuation\">,</span><span class=\"token number\">43</span><span class=\"token punctuation\">,</span><span class=\"token number\">56</span><span class=\"token punctuation\">,</span><span class=\"token number\">78</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//长度：4，索引范围：[0,3]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。<br>List有两个重要的实现类：ArrayList和LinkedList<br>ArrayList: 可以看作是能够自动增长容量的数组<br>ArrayList的toArray方法返回一个数组<br>ArrayList的asList方法返回一个列表<br>ArrayList底层的实现是Array, 数组扩容实现<br>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。</p>\n<h2 id=\"1-12-HashMap和HashTable的区别\"><a href=\"#1-12-HashMap和HashTable的区别\" class=\"headerlink\" title=\"1.12.HashMap和HashTable的区别\"></a>1.12.HashMap和HashTable的区别</h2><ul>\n<li>两者父类不同</li>\n</ul>\n<p>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p>\n<ul>\n<li>对外提供的接口不同</li>\n</ul>\n<p>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。<br>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。</p>\n<ul>\n<li>对null的支持不同</li>\n</ul>\n<p>Hashtable：key和value都不能为null。<br>HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key值对应的value为null。</p>\n<ul>\n<li>安全性不同</li>\n</ul>\n<p>HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。<br>Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。<br>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。<br>ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p>\n<ul>\n<li>初始容量大小和每次扩充容量大小不同</li>\n<li>计算hash值的方法不同</li>\n</ul>\n<h2 id=\"1-13-Collection包结构，与Collections的区别\"><a href=\"#1-13-Collection包结构，与Collections的区别\" class=\"headerlink\" title=\"1.13.Collection包结构，与Collections的区别\"></a>1.13.Collection包结构，与Collections的区别</h2><p>Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set；<br>Collections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>\n<h2 id=\"1-14-Java的四种引用，强弱软虚\"><a href=\"#1-14-Java的四种引用，强弱软虚\" class=\"headerlink\" title=\"1.14. Java的四种引用，强弱软虚\"></a>1.14. Java的四种引用，强弱软虚</h2><h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>软引用在程序内存不足时，会被回收，使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span>\n<span class=\"token comment\">// 这里的软引用指的是指向new String(\"str\")的引用，也就是SoftReference类中T</span>\n<span class=\"token class-name\">SoftReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> wrf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SoftReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>可用场景：</strong> 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> wrf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入ReferenceQueue 中。注意哦，其它引用是被JVM回收后才被传入ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用<br>例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">PhantomReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> prf <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PhantomReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"str\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可用场景： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效<br>上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用( SoftReference 等)。</p>\n<h2 id=\"1-15-泛型常用特点\"><a href=\"#1-15-泛型常用特点\" class=\"headerlink\" title=\"1.15.泛型常用特点\"></a>1.15.泛型常用特点</h2><p>泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：<br><strong>“泛型” 意味着编写的代码可以被不同类型的对象所重用。</strong><br>“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> iniData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>使用泛型的好处？<br>以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p>\n<h2 id=\"1-16-Java创建对象有几种方式？\"><a href=\"#1-16-Java创建对象有几种方式？\" class=\"headerlink\" title=\"1.16.Java创建对象有几种方式？\"></a>1.16.Java创建对象有几种方式？</h2><p>java中提供了以下四种创建对象的方式:</p>\n<ul>\n<li>new创建新对象</li>\n<li>通过反射机制</li>\n<li>采用clone机制</li>\n<li>通过序列化机制</li>\n</ul>\n<h2 id=\"1-17-有没有可能两个不相等的对象有相同的hashcode\"><a href=\"#1-17-有没有可能两个不相等的对象有相同的hashcode\" class=\"headerlink\" title=\"1.17.有没有可能两个不相等的对象有相同的hashcode\"></a>1.17.有没有可能两个不相等的对象有相同的hashcode</h2><p>有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以下几种方式来处理:</p>\n<ul>\n<li>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</li>\n<li>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入</li>\n<li>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.</li>\n</ul>\n<h2 id=\"1-18-深拷贝和浅拷贝的区别是什么\"><a href=\"#1-18-深拷贝和浅拷贝的区别是什么\" class=\"headerlink\" title=\"1.18.深拷贝和浅拷贝的区别是什么?\"></a>1.18.深拷贝和浅拷贝的区别是什么?</h2><ul>\n<li>浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</li>\n<li>深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</li>\n</ul>\n<h2 id=\"1-19-final有哪些用法\"><a href=\"#1-19-final有哪些用法\" class=\"headerlink\" title=\"1.19.final有哪些用法?\"></a>1.19.final有哪些用法?</h2><p>final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:</p>\n<ol>\n<li>被final修饰的类不可以被继承</li>\n<li>被final修饰的方法不可以被重写</li>\n<li>被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</li>\n<li>被final修饰的方法,JVM会尝试将其内联,以提高运行效率</li>\n<li>被final修饰的常量,在编译阶段会存入常量池中.</li>\n</ol>\n<p>除此之外,编译器对final域要遵守的两个重排序规则更好:</p>\n<ol>\n<li>在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序</li>\n<li>初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序。</li>\n</ol>\n<h2 id=\"1-20-static都有哪些用法\"><a href=\"#1-20-static都有哪些用法\" class=\"headerlink\" title=\"1.20.static都有哪些用法?\"></a>1.20.static都有哪些用法?</h2><p>所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量&#x2F;方法都属于类的静态资源,类实例所共享.<br>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> calss <span class=\"token class-name\">PreCache</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">static</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//执行相关操作</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>此外static也多用于修饰内部类,此时称之为静态内部类.<br>最后一种用法就是静态导包,即 import static .import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">static</span> <span class=\"token import static\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//System.out.println(Math.sin(20));传统做法</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">sin</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"1-21-3-0-1-x3D-x3D-0-3返回值是什么\"><a href=\"#1-21-3-0-1-x3D-x3D-0-3返回值是什么\" class=\"headerlink\" title=\"1.21.3*0.1&#x3D;&#x3D;0.3返回值是什么\"></a>1.21.3*0.1&#x3D;&#x3D;0.3返回值是什么</h2><p>false,因为有些浮点数不能完全精确的表示出来</p>\n<h2 id=\"1-22-a-x3D-a-b与a-x3D-b有什么区别吗\"><a href=\"#1-22-a-x3D-a-b与a-x3D-b有什么区别吗\" class=\"headerlink\" title=\"1.22.a&#x3D;a+b与a+&#x3D;b有什么区别吗?\"></a>1.22.a&#x3D;a+b与a+&#x3D;b有什么区别吗?</h2><p>+&#x3D; 操作符会进行隐式自动类型转换,此处a+&#x3D;b隐式的将加操作的结果类型强制转换为持有结果的类型,而a&#x3D;a+b则不会自动进行类型转换.如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">byte</span> a <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">byte</span> b <span class=\"token operator\">=</span> <span class=\"token number\">127</span><span class=\"token punctuation\">;</span>\nb <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 报编译错误:cannot convert from int to byte</span>\nb <span class=\"token operator\">+=</span> a<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>以下代码是否有错,有的话怎么改？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">short</span> s1<span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>有错误.short类型在进行运算时会自动提升为int类型,也就是说 s1+1 的运算结果是int类型,而s1是short类型,此时编译器会报错。<br>正确写法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">short</span> s1<span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\ns1 <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>+&#x3D;操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错。</p>\n<h2 id=\"1-23-try-catch-finally，try里有return，finally还执行么？\"><a href=\"#1-23-try-catch-finally，try里有return，finally还执行么？\" class=\"headerlink\" title=\"1.23.try catch finally，try里有return，finally还执行么？\"></a>1.23.try catch finally，try里有return，finally还执行么？</h2><p>执行，并且finally的执行早于try里面的return<br>结论：</p>\n<ol>\n<li>不管有木有出现异常，finally块中代码都会执行；</li>\n<li>当try和catch中有return时，finally仍然会执行；</li>\n<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li>\n<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</li>\n</ol>\n<h2 id=\"1-24-Excption与Error包结构\"><a href=\"#1-24-Excption与Error包结构\" class=\"headerlink\" title=\"1.24.Excption与Error包结构\"></a>1.24.Excption与Error包结构</h2><p>Java可抛出(Throwable)的结构分为三种类型：被检查的异常(CheckedException)，运行时异常(RuntimeException)，错误(Error)。</p>\n<h3 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h3><p><strong>定义</strong>:RuntimeException及其子类都被称为运行时异常。<br><strong>特点</strong>:Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产生的ConcurrentModificationException异常（java.util包下面的所有的集合类都是快速失败的，“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制，这个错叫并发修改异常。Fail-safe，java.util.concurrent包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的表现。<br>ConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了。）等，都属于运行时异常。<br>常见的五种运行时异常：</p>\n<ul>\n<li>ClassCastException（类转换异常）</li>\n<li>IndexOutOfBoundsException（数组越界）</li>\n<li>NullPointerException（空指针异常）</li>\n<li>ArrayStoreException（数据存储异常，操作数组是类型不一致）</li>\n<li>BufferOverflowException</li>\n</ul>\n<h3 id=\"被检查异常\"><a href=\"#被检查异常\" class=\"headerlink\" title=\"被检查异常\"></a>被检查异常</h3><p><strong>定义</strong>:Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。<br><strong>特点</strong>: Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。被检查异常通常都是可以恢复的。<br>如：<br>IOException<br>FileNotFoundException<br>SQLException<br>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的FileNotFoundException 。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException 。</p>\n<h3 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h3><p><strong>定义</strong>: Error类及其子类。<br><strong>特点</strong>: 和运行时异常一样，编译器也不会对错误进行检查。<br>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。出现这种错误会导致程序终止运行。<br>OutOfMemoryError、ThreadDeath。<br>Java虚拟机规范规定JVM的内存分为了好几块，比如堆，栈，程序计数器，方法区等</p>\n<h2 id=\"1-25-OOM你遇到过哪些情况，SOF你遇到过哪些情况\"><a href=\"#1-25-OOM你遇到过哪些情况，SOF你遇到过哪些情况\" class=\"headerlink\" title=\"1.25.OOM你遇到过哪些情况，SOF你遇到过哪些情况\"></a>1.25.OOM你遇到过哪些情况，SOF你遇到过哪些情况</h2><h3 id=\"OutOfMemoryError异常\"><a href=\"#OutOfMemoryError异常\" class=\"headerlink\" title=\"OutOfMemoryError异常\"></a>OutOfMemoryError异常</h3><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。<br>Java Heap 溢出：<br>一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。<br>java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。<br>出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。<br>如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。<br>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p>\n<h3 id=\"虚拟机栈和本地方法栈溢出\"><a href=\"#虚拟机栈和本地方法栈溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈溢出\"></a>虚拟机栈和本地方法栈溢出</h3><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。<br>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常<br>这里需要注意当栈的大小越大可分配的线程数就越少。</p>\n<h3 id=\"运行时常量池溢出\"><a href=\"#运行时常量池溢出\" class=\"headerlink\" title=\"运行时常量池溢出\"></a>运行时常量池溢出</h3><p>异常信息：java.lang.OutOfMemoryError:PermGenspace<br>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。</p>\n<h3 id=\"方法区溢出\"><a href=\"#方法区溢出\" class=\"headerlink\" title=\"方法区溢出\"></a>方法区溢出</h3><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。<br>异常信息：java.lang.OutOfMemoryError:PermGenspace<br>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。</p>\n<h3 id=\"SOF（堆栈溢出StackOverflow）\"><a href=\"#SOF（堆栈溢出StackOverflow）\" class=\"headerlink\" title=\"SOF（堆栈溢出StackOverflow）\"></a>SOF（堆栈溢出StackOverflow）</h3><p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。<br>因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。<br>栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。</p>\n<h2 id=\"1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么\"><a href=\"#1-26-简述线程、程序、进程的基本概念。以及他们之间关系是什么\" class=\"headerlink\" title=\"1.26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?\"></a>1.26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。<br>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。<br>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输<br>入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间<br>内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>\n<h2 id=\"1-27-线程有哪些基本状态？这些状态是如何定义的\"><a href=\"#1-27-线程有哪些基本状态？这些状态是如何定义的\" class=\"headerlink\" title=\"1.27.线程有哪些基本状态？这些状态是如何定义的?\"></a>1.27.线程有哪些基本状态？这些状态是如何定义的?</h2><ul>\n<li><p>新建(new)：新创建了一个线程对象。</p>\n</li>\n<li><p>可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</p>\n</li>\n<li><p>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</p>\n</li>\n<li><p>阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>阻塞的情况分三种：<br>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。<br>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br>(三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。</p></blockquote>\n</li>\n<li><p>死亡(terminated)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301162059533.png\"></p>\n<h2 id=\"1-28-Java-中-IO-流\"><a href=\"#1-28-Java-中-IO-流\" class=\"headerlink\" title=\"1.28.Java 中 IO 流\"></a>1.28.Java 中 IO 流</h2><p>Java 中 IO 流分为几种?</p>\n<ul>\n<li>按照流的流向分，可以分为输入流和输出流；</li>\n<li>按照操作单元划分，可以划分为字节流和字符流；</li>\n<li>按照流的角色划分为节点流和处理流。</li>\n</ul>\n<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。<br><strong>InputStream&#x2F;Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br><strong>OutputStream&#x2F;Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。<br>按操作方式分类结构图：<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301162059379.png\"><br>按操作对象分类结构图：<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301162100636.png\"></p>\n<h2 id=\"1-29-java反射的作用于原理\"><a href=\"#1-29-java反射的作用于原理\" class=\"headerlink\" title=\"1.29.java反射的作用于原理\"></a>1.29.java反射的作用于原理</h2><h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。<br>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>\n<h3 id=\"哪里会用到反射机制？\"><a href=\"#哪里会用到反射机制？\" class=\"headerlink\" title=\"哪里会用到反射机制？\"></a>哪里会用到反射机制？</h3><p>jdbc就是典型的反射<br>Class.forName(‘com.mysql.jdbc.Driver.class’);&#x2F;&#x2F;加载MySQL的驱动类<br>这就是反射。如hibernate，struts等框架使用反射实现的。</p>\n<h3 id=\"反射的实现方式\"><a href=\"#反射的实现方式\" class=\"headerlink\" title=\"反射的实现方式\"></a>反射的实现方式</h3><p>获取Class对象，有4中方法：</p>\n<ol>\n<li>Class.forName(“类的路径”)；</li>\n<li>类名.class</li>\n<li>对象名.getClass()</li>\n<li>基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象</li>\n</ol>\n<h3 id=\"实现Java反射的类\"><a href=\"#实现Java反射的类\" class=\"headerlink\" title=\"实现Java反射的类\"></a>实现Java反射的类</h3><ol>\n<li>Class：表示正在运行的Java应用程序中的类和接口（注意： 所有获取对象的信息都需要Class类来实现）。</li>\n<li>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</li>\n<li>Constructor：提供关于类的单个构造方法的信息以及它的访问权限</li>\n<li>Method：提供类或接口中某个方法的信息</li>\n</ol>\n<h3 id=\"反射机制的优缺点\"><a href=\"#反射机制的优缺点\" class=\"headerlink\" title=\"反射机制的优缺点\"></a>反射机制的优缺点</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>能够运行时动态获取类的实例，提高灵活性；</li>\n<li>与动态编译结合</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li><p>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>解决方案：<br>1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度；<br>2、多次创建一个类的实例时，有缓存会快很多<br>3、ReflectASM工具类，通过字节码生成的方式加快反射速度</p></blockquote>\n</li>\n<li><p>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</p>\n</li>\n</ol>\n<h2 id=\"1-30-说说List-Set-Map三者的区别？\"><a href=\"#1-30-说说List-Set-Map三者的区别？\" class=\"headerlink\" title=\"1.30.说说List,Set,Map三者的区别？\"></a>1.30.说说List,Set,Map三者的区别？</h2><p><strong>List(对付顺序的好帮手)</strong>: List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象<br><strong>Set(注重独一无二的性质)</strong>: 不允许重复的集合。不会有多个元素引用相同的对象。<br><strong>Map(用Key来搜索的专家)</strong>: 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p>\n<h1 id=\"二、JVM篇\"><a href=\"#二、JVM篇\" class=\"headerlink\" title=\"二、JVM篇\"></a>二、JVM篇</h1><h2 id=\"2-1-知识点汇总\"><a href=\"#2-1-知识点汇总\" class=\"headerlink\" title=\"2.1.知识点汇总\"></a>2.1.知识点汇总</h2><p>JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高。由于脑图内容实在过于庞大，这里就不展开了，详情可见：<a href=\"https://www.processon.com/view/link/63c6114575fa681b61283d3d\">JVM知识点</a>。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301171748391.png\"></p>\n<h2 id=\"2-2-知识点详解\"><a href=\"#2-2-知识点详解\" class=\"headerlink\" title=\"2.2.知识点详解\"></a>2.2.知识点详解</h2><h3 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h3><p>线程独占:栈,本地方法栈,程序计数器<br>线程共享:堆,方法区</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法<br>出口等信息.调用方法时执行入栈,方法返回式执行出栈.</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现</p>\n<h3 id=\"JVM-内存可见性\"><a href=\"#JVM-内存可见性\" class=\"headerlink\" title=\"JVM 内存可见性\"></a>JVM 内存可见性</h3><p>JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证</p>\n<h2 id=\"2-3-类加载与卸载\"><a href=\"#2-3-类加载与卸载\" class=\"headerlink\" title=\"2.3.类加载与卸载\"></a>2.3.类加载与卸载</h2><h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301171749000.jpeg\"><br>JVM类加载过程分为：加载 、链接 、初始化 、使用 、卸载 这五个阶段，其中链接阶段又包括： 验证 、 准备 、 解析 。<br><strong>加载</strong> ：通过类的完全限定名，查找此类的二进制字节码文件，通过该字节码文件创建Class对象。<br><strong>链接</strong> ：包含 验证 、 准备 、 解析 三个阶段：</p>\n<ul>\n<li><strong>验证</strong> ：确保Class文件复合虚拟机规定的Class文件格式，包含文件格式验证、元数据验证、字节码验证、引用符号验证。</li>\n<li><strong>准备</strong> ：为类的静态变量分配内存并设置初始化值，注：这里不包含final修饰的静态变量，因为final修饰的静态变量是在编译期分配。</li>\n<li><strong>解析</strong> ：将常量池的间接引用转换为直接引用，解析包含字段解析、接口解析、方法解析。</li>\n</ul>\n<p><strong>初始化</strong> ：初始化静态变量和静态块，先初始化父类，再初始化当前类，只有对类主动时才会初始化。<br><strong>使用</strong> ：程序代码执行时使用，new出对象程序中使用。<br><strong>卸载</strong> ：程序代码退出、异常、结束等，执行垃圾回收。</p>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><ul>\n<li>创建类的实例，也就是new一个对象。</li>\n<li>访问类的静态方法或者静态变量（包含静态变量赋值）。</li>\n<li>使用Class.forName()反射类。</li>\n<li>子类初始化的时候。</li>\n<li>JVM启动时标明的启动类。</li>\n</ul>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p>类加载器包括启动类加载器、扩展类加载器、系统类加载器、自定义类加载器四种加载器。</p>\n<p><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载Java类的核心类，是用原生代码实现。下面代码可以获得启动类加载器所加载的Java核心类库。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token constant\">URL</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> urLs <span class=\"token operator\">=</span> <span class=\"token class-name\">Launcher</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBootstrapClassPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getURLs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token constant\">URL</span> url <span class=\"token operator\">:</span> urLs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">toExternalForm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>扩展类加载器（Extensions ClassLoader）</strong>：负责加载JRE的扩展目录lib&#x2F;ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为Null。</p>\n<p><strong>系统类加载器（System Class Loader）</strong>：负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性。可以通过ClassLoader.getSystemClassLoader()方法获取当前系统类加载器，一般情况是自定义类加载器的父加载器。由Java语言实现，父类加载器为扩展类加载器。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSystemClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSystemClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>自定义类加载器（Custom ClassLoader）</strong>：用户可以通过继承ClassLoader类实现自定义类加载器。由Java语言实现，自定义类加载器的父类是系统类加载器。</p>\n<h3 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h3><p>JVM的类加载机制主要有全盘负责、双亲委派、缓存机制三种加载机制。</p>\n<ul>\n<li><strong>全盘负责</strong>：当一个类加载器加载某个Class时，该Class所依赖和引用其他Class也会由该类加载器负责加载，除非指定了使用其他类加载器加载。</li>\n<li><strong>双亲委派</strong>：先让父类加载器加载该Class，只有在父类加载器无法加载该类时才尝试使用自己的类加载器加载。通俗的讲就是在某个特定的类加载器接到加载类请求时，先寄托给父加载器加载，依次递归，如果父加载器可以加载时则成功返回，如果不可以加载就自己去加载。</li>\n<li><strong>缓存机制</strong>：缓存机制会确保所有加载过的Class都被会缓存，当程序中需要某个Class时，类加载器先从缓存区中搜索该Class，只有缓存区中不存在该Class对象时，系统才会读取该类的二进制数据，并将其转换为Class对象，存入缓存区。这就是为什么我们修改Class文件之后，必须重启JVM才会生效的原因。</li>\n</ul>\n<p>其中<strong>双亲委派机制优势</strong>：</p>\n<ul>\n<li>父类加载器成功加载则返回，子类加载器不会再加载，防止了重复加载。</li>\n<li>防止核心API库被随意篡改。比如有一个要加载java.lang.Integer类的请求，通过双亲委派进制加载传递到启动类加载器，在在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，可以防止核心API被随意篡改。</li>\n</ul>\n<h3 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h3><h4 id=\"G1算法\"><a href=\"#G1算法\" class=\"headerlink\" title=\"G1算法\"></a>G1算法</h4><p>1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全部的增量式清理,以保证停顿时间不会过长。<br>其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区。<br>同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间。<br><strong>年轻代回收</strong>:<br>并行复制采用复制算法,并行收集,会StopTheWorld.<br><strong>老年代回收</strong>:<br>会对年轻代一并回收<br>初始标记完成堆root对象的标记,会StopTheWorld.<br>并发标记 GC线程和应用线程并发执行.<br>最终标记完成三色标记周期,会StopTheWorld.<br>复制&#x2F;清楚会优先对可回收空间加大的区域进行回收</p>\n<h4 id=\"ZGC算法\"><a href=\"#ZGC算法\" class=\"headerlink\" title=\"ZGC算法\"></a>ZGC算法</h4><p>高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停顿时间</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>着色指针<br>读屏障<br>并发处理<br>基于region<br>内存压缩(整理)</p></blockquote>\n<p>roots标记：标记root对象,会StopTheWorld。<br>并发标记：利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld。<br>清除会清理标记为不可用的对象。<br>roots重定位：是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生。重定位最开始会StopTheWorld,却决于重定位集与对象总活动集的比例。<br>并发重定位与并发标记类似。</p>\n<h2 id=\"2-4-简述一下JVM的内存模型\"><a href=\"#2-4-简述一下JVM的内存模型\" class=\"headerlink\" title=\"2.4.简述一下JVM的内存模型\"></a>2.4.简述一下JVM的内存模型</h2><p>JVM定义了不同运行时数据区，他们是用来执行应用程序的。某些区域随着JVM启动及销毁，另外一些区域的数据是线程性独立的，随着线程创建和销毁。</p>\n<h3 id=\"线程私有区\"><a href=\"#线程私有区\" class=\"headerlink\" title=\"线程私有区\"></a>线程私有区</h3><h4 id=\"程序计数器-1\"><a href=\"#程序计数器-1\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p>当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为空。</p>\n<h4 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h4><p>线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。</p>\n<h4 id=\"本地方法栈-1\"><a href=\"#本地方法栈-1\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p>\n<h3 id=\"线程共享区\"><a href=\"#线程共享区\" class=\"headerlink\" title=\"线程共享区\"></a>线程共享区</h3><h4 id=\"方法区-1\"><a href=\"#方法区-1\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><p>线程共享的，用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。若要分代，算是永久代（老年代），以前类大多“static”的，很少被卸载或收集，现回收废弃常量和无用的类。其中运行时常量池存放编译生成的各种常量。（如果hotspot虚拟机确定一个类的定义信息<br>不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收）</p>\n<h4 id=\"堆-1\"><a href=\"#堆-1\" class=\"headerlink\" title=\"堆\"></a>堆</h4><p>存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的Eden区中，经过GC后进入新生代的S0区中，再经过GC进入新生代的S1区中，15次GC后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则OutOfMemoryError。</p>\n<h2 id=\"2-5-堆和栈的区别\"><a href=\"#2-5-堆和栈的区别\" class=\"headerlink\" title=\"2.5.堆和栈的区别\"></a>2.5.堆和栈的区别</h2><p>栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。<br><strong>1、功能不同</strong><br>栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。<br><strong>2、共享性不同</strong><br>栈内存是线程私有的。<br>堆内存是所有线程共有的。<br><strong>3、异常错误不同</strong><br>如果栈内存或者堆内存不足都会抛出异常。<br>栈空间不足：java.lang.StackOverFlowError。<br>堆空间不足：java.lang.OutOfMemoryError。<br><strong>4、空间大小</strong><br>栈的空间大小远远小于堆的</p>\n<h2 id=\"2-6-什么时候会触发FullGC\"><a href=\"#2-6-什么时候会触发FullGC\" class=\"headerlink\" title=\"2.6.什么时候会触发FullGC\"></a>2.6.什么时候会触发FullGC</h2><p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p>\n<ol>\n<li><p>旧生代空间不足</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p></blockquote>\n</li>\n<li><p>Permanet Generation空间满</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space<br>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p></blockquote>\n</li>\n<li><p>CMS GC时出现promotion failed和concurrent mode failure</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。<br>应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime&#x3D;5（单位为ms）来避免。</p></blockquote>\n</li>\n<li><p>统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。<br>例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。<br>当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。<br>除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java Dsun.rmi.dgc.client.gcInterval&#x3D;3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p></blockquote>\n</li>\n</ol>\n<h2 id=\"2-7-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？\"><a href=\"#2-7-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？\" class=\"headerlink\" title=\"2.7.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？\"></a>2.7.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>\n<h2 id=\"2-8-Java内存结构\"><a href=\"#2-8-Java内存结构\" class=\"headerlink\" title=\"2.8.Java内存结构\"></a>2.8.Java内存结构</h2><p>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。<br><strong>Java堆（Heap）</strong>,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br><strong>方法区（Method Area）</strong>,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<br><strong>JVM栈（JVM Stacks）</strong>,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><strong>本地方法栈（Native Method Stacks）</strong>,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>\n<h2 id=\"2-9-对象分配规则\"><a href=\"#2-9-对象分配规则\" class=\"headerlink\" title=\"2.9.对象分配规则\"></a>2.9.对象分配规则</h2><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。<br>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。<br>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。<br>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。<br>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</p>\n<h2 id=\"2-10-Java对象创建过程\"><a href=\"#2-10-Java对象创建过程\" class=\"headerlink\" title=\"2.10.Java对象创建过程\"></a>2.10.Java对象创建过程</h2><ol>\n<li>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</li>\n<li>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</li>\n<li>将除对象头外的对象内存空间初始化为0</li>\n<li>对对象头进行必要设置</li>\n</ol>\n<h2 id=\"2-11-类的生命周期\"><a href=\"#2-11-类的生命周期\" class=\"headerlink\" title=\"2.11.类的生命周期\"></a>2.11.类的生命周期</h2><p>类的生命周期包括这几个部分，<strong>加载、连接、初始化、使用和卸载</strong>，其中前三部是类的加载的过程加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象连接，连接又包含三块内容：<strong>验证、准备、初始化。</strong></p>\n<h2 id=\"2-12-简述Java的对象结构\"><a href=\"#2-12-简述Java的对象结构\" class=\"headerlink\" title=\"2.12.简述Java的对象结构\"></a>2.12.简述Java的对象结构</h2><p>Java对象由三个部分组成：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<br><strong>对象头</strong>由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32&#x2F;64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。<br><strong>实例数据</strong>用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）<br><strong>对齐填充</strong>：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）</p>\n<h2 id=\"2-13-如何判断对象可以被回收？\"><a href=\"#2-13-如何判断对象可以被回收？\" class=\"headerlink\" title=\"2.13.如何判断对象可以被回收？\"></a>2.13.如何判断对象可以被回收？</h2><p>判断对象是否存活一般有两种方式：<br><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。<br><strong>可达性分析（Reachability Analysis）</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p>\n<h2 id=\"2-14-JVM的永久代中会发生垃圾回收么？\"><a href=\"#2-14-JVM的永久代中会发生垃圾回收么？\" class=\"headerlink\" title=\"2.14.JVM的永久代中会发生垃圾回收么？\"></a>2.14.JVM的永久代中会发生垃圾回收么？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>\n<h2 id=\"2-15-垃圾收集算法\"><a href=\"#2-15-垃圾收集算法\" class=\"headerlink\" title=\"2.15.垃圾收集算法\"></a>2.15.垃圾收集算法</h2><p>GC最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。<br><strong>标记 -清除算法</strong>，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。<br><strong>复制算法</strong>，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br><strong>标记-压缩算法</strong>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br><strong>分代收集算法</strong>，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>\n<h2 id=\"2-16-调优命令有哪些？\"><a href=\"#2-16-调优命令有哪些？\" class=\"headerlink\" title=\"2.16.调优命令有哪些？\"></a>2.16.调优命令有哪些？</h2><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo<br><strong>jps</strong>，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。<br><strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。<br><strong>jmap</strong>，JVM Memory Map命令用于生成heap dump文件<br><strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看<br><strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。<br><strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p>\n<h2 id=\"2-17-调优工具\"><a href=\"#2-17-调优工具\" class=\"headerlink\" title=\"2.17.调优工具\"></a>2.17.调优工具</h2><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。<br><strong>jconsole</strong>，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控<br><strong>jvisualvm</strong>，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。<br>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br><strong>GChisto</strong>，一款专业分析gc日志的工具</p>\n<h2 id=\"2-18-Minor-GC与Full-GC分别在什么时候发生？\"><a href=\"#2-18-Minor-GC与Full-GC分别在什么时候发生？\" class=\"headerlink\" title=\"2.18.Minor GC与Full GC分别在什么时候发生？\"></a>2.18.Minor GC与Full GC分别在什么时候发生？</h2><p>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC</p>\n<h2 id=\"2-19-你知道哪些JVM性能调优\"><a href=\"#2-19-你知道哪些JVM性能调优\" class=\"headerlink\" title=\"2.19.你知道哪些JVM性能调优\"></a>2.19.你知道哪些JVM性能调优</h2><p><strong>设定堆内存大小</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-Xmx：堆内存最大限制。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>设定新生代大小</strong>。 新生代不宜太小，否则会有大量对象涌入老年代</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-XX:NewSize：新生代大小\n-XX:NewRatio 新生代和老生代占比\n-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>设定垃圾回收器</strong> 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC</p>\n<h2 id=\"2-20-简述Java垃圾回收机制\"><a href=\"#2-20-简述Java垃圾回收机制\" class=\"headerlink\" title=\"2.20.简述Java垃圾回收机制?\"></a>2.20.简述Java垃圾回收机制?</h2><p>在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收</p>\n<h2 id=\"2-21-什么是类加载器，类加载器有哪些\"><a href=\"#2-21-什么是类加载器，类加载器有哪些\" class=\"headerlink\" title=\"2.21.什么是类加载器，类加载器有哪些?\"></a>2.21.什么是类加载器，类加载器有哪些?</h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。<br>主要有一下四种类加载器:<br>**启动类加载器(Bootstrap ClassLoader)**用来加载java核心类库，无法被java程序直接引用。<br><strong>扩展类加载器(extensions class loader)</strong>:它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br><strong>系统类加载器（system class loader）</strong>：它根据 Java 应用的类路径(CLASSPATH）来加载 Java类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。<br><strong>用户自定义类加载器</strong>，通过继承 java.lang.ClassLoader类的方式实现。</p>\n<h2 id=\"2-22-你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理-过程中有哪些收获？\"><a href=\"#2-22-你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理-过程中有哪些收获？\" class=\"headerlink\" title=\"2.22.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？\"></a>2.22.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？</h2><p>常见的原因:<br>内存加载的数据量太大：一次性从数据库取太多数据；<br>集合类中有对对象的引用，使用后未清空，GC不能进行回收；<br>代码中存在循环产生过多的重复对象；<br>启动参数堆内存值小。</p>\n<h2 id=\"2-23-JDK-1-8之后Perm-Space有哪些变动-MetaSpace⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩\"><a href=\"#2-23-JDK-1-8之后Perm-Space有哪些变动-MetaSpace⼤⼩默认是⽆限的么-还是你们会通过什么⽅式来指定⼤⼩\" class=\"headerlink\" title=\"2.23.JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?\"></a>2.23.JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?</h2><p>JDK 1.8后用元空间替代了 Perm Space；字符串常量存放到堆内存中。<br>MetaSpace大小默认没有限制，一般根据系统内存的大小。JVM会动态改变此值。<br><strong>-XX:MetaspaceSize</strong>：分配给类元数据空间（以字节计）的初始大小（Oracle逻辑存储上的初始高水位，the initial high-water-mark）。此值为估计值，MetaspaceSize的值设置的过大会延长垃圾回收时<br>间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。<br><strong>-XX:MaxMetaspaceSize</strong>：分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</p>\n<h1 id=\"三、多线程-amp-并发篇\"><a href=\"#三、多线程-amp-并发篇\" class=\"headerlink\" title=\"三、多线程&amp;并发篇\"></a>三、多线程&amp;并发篇</h1><h2 id=\"3-1-Java中实现多线程有几种方法\"><a href=\"#3-1-Java中实现多线程有几种方法\" class=\"headerlink\" title=\"3.1.Java中实现多线程有几种方法\"></a>3.1.Java中实现多线程有几种方法</h2><ol>\n<li>继承Thread类；</li>\n<li>实现Runnable接口；</li>\n<li>实现Callable接口通过FutureTask包装器来创建Thread线程；</li>\n<li>使用ExecutorService、Callable、Future实现有返回结果的多线程（也就是使用了ExecutorService来管理前面的三种方式）</li>\n</ol>\n<h2 id=\"3-2-如何停止一个正在运行的线程\"><a href=\"#3-2-如何停止一个正在运行的线程\" class=\"headerlink\" title=\"3.2.如何停止一个正在运行的线程\"></a>3.2.如何停止一个正在运行的线程</h2><ol>\n<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>\n<li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li>\n<li>使用interrupt方法中断线程。<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span> stop <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" is running\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"week up from blcok...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                stop <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在异常处理代码中修改共享变量的状态</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" is exiting...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">InterruptThreadDemo3</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">MyThread</span> m1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Starting thread...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        m1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Interrupt thread...: \"</span> <span class=\"token operator\">+</span> m1<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        m1<span class=\"token punctuation\">.</span>stop <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 设置共享变量为true</span>\n        m1<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 阻塞时退出阻塞状态</span>\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 主线程休眠3秒以便观察线程m1的中断情况</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Stopping application...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"3-3-notify-和notifyAll-有什么区别？\"><a href=\"#3-3-notify-和notifyAll-有什么区别？\" class=\"headerlink\" title=\"3.3.notify()和notifyAll()有什么区别？\"></a>3.3.notify()和notifyAll()有什么区别？</h2><p>notify可能会导致死锁，而notifyAll则不会，任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized 中的代码使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。<br>wait() 应配合while循环使用，不应使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续wait()直至条件满足再往下执行。<br>notify() 是对notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是 WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中。</p>\n<h2 id=\"3-4-sleep-和wait-有什么区别？\"><a href=\"#3-4-sleep-和wait-有什么区别？\" class=\"headerlink\" title=\"3.4.sleep()和wait() 有什么区别？\"></a>3.4.sleep()和wait() 有什么区别？</h2><p>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。<br>sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。<br>当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</p>\n<h2 id=\"3-5-volatile-是什么-可以保证有序性吗\"><a href=\"#3-5-volatile-是什么-可以保证有序性吗\" class=\"headerlink\" title=\"3.5.volatile 是什么?可以保证有序性吗?\"></a>3.5.volatile 是什么?可以保证有序性吗?</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</li>\n<li>禁止进行指令重排序。</li>\n</ol></blockquote>\n<p>volatile 不是原子性操作<br>什么叫保证部分有序性?<br>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//语句1</span>\ny <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//语句2</span>\nflag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//语句3</span>\nx <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//语句4</span>\ny <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">//语句5</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>使用 Volatile 一般用于<strong>状态标记量和单例模式的双检锁</strong></p>\n<h2 id=\"3-6-Thread-类中的start-和-run-方法有什么区别？\"><a href=\"#3-6-Thread-类中的start-和-run-方法有什么区别？\" class=\"headerlink\" title=\"3.6.Thread 类中的start() 和 run() 方法有什么区别？\"></a>3.6.Thread 类中的start() 和 run() 方法有什么区别？</h2><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>\n<h2 id=\"3-7-为什么wait-notify-和-notifyAll这些方法不在thread类里面？\"><a href=\"#3-7-为什么wait-notify-和-notifyAll这些方法不在thread类里面？\" class=\"headerlink\" title=\"3.7.为什么wait, notify 和 notifyAll这些方法不在thread类里面？\"></a>3.7.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h2><p>明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>\n<h2 id=\"3-8-为什么wait和notify方法要在同步块中调用？\"><a href=\"#3-8-为什么wait和notify方法要在同步块中调用？\" class=\"headerlink\" title=\"3.8.为什么wait和notify方法要在同步块中调用？\"></a>3.8.为什么wait和notify方法要在同步块中调用？</h2><ol>\n<li>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。</li>\n<li>如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</li>\n<li>还有一个原因是为了避免wait和notify之间产生竞态条件。</li>\n</ol>\n<p>wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。<br>在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。<br>调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:“特殊状态已经被设置”。<br>这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。</p>\n<h2 id=\"3-9-Java中interrupted-和-isInterruptedd方法的区别？\"><a href=\"#3-9-Java中interrupted-和-isInterruptedd方法的区别？\" class=\"headerlink\" title=\"3.9.Java中interrupted 和 isInterruptedd方法的区别？\"></a>3.9.Java中interrupted 和 isInterruptedd方法的区别？</h2><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法<br>isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>\n<h2 id=\"3-10-Java中synchronized-和-ReentrantLock-有什么不同？\"><a href=\"#3-10-Java中synchronized-和-ReentrantLock-有什么不同？\" class=\"headerlink\" title=\"3.10.Java中synchronized 和 ReentrantLock 有什么不同？\"></a>3.10.Java中synchronized 和 ReentrantLock 有什么不同？</h2><p><strong>相似点</strong><br>这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.<br><strong>区别</strong><br>这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成。<br>Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。<br>由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：</p>\n<ol>\n<li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。</li>\n<li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</li>\n<li>锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。</li>\n</ol>\n<h2 id=\"3-11-有三个线程T1-T2-T3-如何保证顺序执行？\"><a href=\"#3-11-有三个线程T1-T2-T3-如何保证顺序执行？\" class=\"headerlink\" title=\"3.11.有三个线程T1,T2,T3,如何保证顺序执行？\"></a>3.11.有三个线程T1,T2,T3,如何保证顺序执行？</h2><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。<br>实际上先启动三个线程中哪一个都行，因为在每个线程的run方法中用join方法限定了三个线程的执行顺序</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JoinTest2</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n          <span class=\"token comment\">// 引用t1线程，等待t1线程执行完</span>\n          t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Thread</span> t3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token annotation punctuation\">@Override</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n          <span class=\"token comment\">// 引用t2线程，等待t2线程执行完</span>\n          t2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">&#125;</span>\n     <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t3<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这里三个线程的启动顺序可以任意，大家可以试下！</span>\n    t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-12-SynchronizedMap和ConcurrentHashMap有什么区别？\"><a href=\"#3-12-SynchronizedMap和ConcurrentHashMap有什么区别？\" class=\"headerlink\" title=\"3.12.SynchronizedMap和ConcurrentHashMap有什么区别？\"></a>3.12.SynchronizedMap和ConcurrentHashMap有什么区别？</h2><p>SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出ConcurrentModificationException。</p>\n<h2 id=\"3-13-什么是线程安全\"><a href=\"#3-13-什么是线程安全\" class=\"headerlink\" title=\"3.13.什么是线程安全\"></a>3.13.什么是线程安全</h2><p>线程安全就是说多线程访问同一代码，不会产生不确定的结果。<br>在多线程环境中，当各线程不共享数据的时候，即都是私有（private）成员，那么一定是线程安全的。<br>但这种情况并不多见，在多数情况下需要共享数据，这时就需要进行适当的同步控制了。<br>线程安全一般都涉及到synchronized， 就是一段代码同时只能有一个线程来操作 不然中间过程可能会产生不可预制的结果。<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>\n<h2 id=\"3-14-Thread类中的yield方法有什么作用？\"><a href=\"#3-14-Thread类中的yield方法有什么作用？\" class=\"headerlink\" title=\"3.14.Thread类中的yield方法有什么作用？\"></a>3.14.Thread类中的yield方法有什么作用？</h2><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行</p>\n<h2 id=\"3-15-Java线程池中submit-和-execute-方法有什么区别？\"><a href=\"#3-15-Java线程池中submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"3.15.Java线程池中submit() 和 execute()方法有什么区别？\"></a>3.15.Java线程池中submit() 和 execute()方法有什么区别？</h2><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>\n<h2 id=\"3-16-说一说自己对于-synchronized-关键字的了解\"><a href=\"#3-16-说一说自己对于-synchronized-关键字的了解\" class=\"headerlink\" title=\"3.16.说一说自己对于 synchronized 关键字的了解\"></a>3.16.说一说自己对于 synchronized 关键字的了解</h2><p>synchronized关键字解决的是<strong>多个线程之间访问资源的同步性</strong>，synchronized关键字可以<strong>保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。<br>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>\n<h2 id=\"3-17-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？\"><a href=\"#3-17-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗？\" class=\"headerlink\" title=\"3.17.说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？\"></a>3.17.说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</h2><p>synchronized关键字最主要的三种使用方式：</p>\n<ol>\n<li><strong>修饰实例方法</strong>: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>\n<li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>\n<li><strong>修饰代码块</strong>: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能</p></blockquote>\n</li>\n</ol>\n<h2 id=\"3-18-什么是线程安全？Vector是一个线程安全类吗？\"><a href=\"#3-18-什么是线程安全？Vector是一个线程安全类吗？\" class=\"headerlink\" title=\"3.18.什么是线程安全？Vector是一个线程安全类吗？\"></a>3.18.什么是线程安全？Vector是一个线程安全类吗？</h2><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。<strong>Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的</strong>。</p>\n<h2 id=\"3-19-volatile关键字的作用？\"><a href=\"#3-19-volatile关键字的作用？\" class=\"headerlink\" title=\"3.19.volatile关键字的作用？\"></a>3.19.volatile关键字的作用？</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<ol>\n<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>\n<li>禁止进行指令重排序。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。<br>volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改可见性和原子性。<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></blockquote>\n</li>\n</ol>\n<p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>\n<h2 id=\"3-20-常用的线程池有哪些？\"><a href=\"#3-20-常用的线程池有哪些？\" class=\"headerlink\" title=\"3.20.常用的线程池有哪些？\"></a>3.20.常用的线程池有哪些？</h2><p><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br><strong>newFixedThreadPool</strong>：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。<br><strong>newCachedThreadPool</strong>：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。<br><strong>newScheduledThreadPool</strong>：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。<br><strong>newSingleThreadExecutor</strong>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n<h2 id=\"3-21-简述一下你对线程池的理解\"><a href=\"#3-21-简述一下你对线程池的理解\" class=\"headerlink\" title=\"3.21.简述一下你对线程池的理解\"></a>3.21.简述一下你对线程池的理解</h2><p>（如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。</p>\n<ol>\n<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ol>\n<h2 id=\"3-22-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗\"><a href=\"#3-22-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗\" class=\"headerlink\" title=\"3.22.说说自己是怎么使用 synchronized 关键字，在项目中用到了吗\"></a>3.22.说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h2><p>synchronized关键字最主要的三种使用方式：</p>\n<ol>\n<li><strong>修饰实例方法</strong>：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>\n<li><strong>修饰静态方法</strong>：作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>\n<li><strong>修饰代码块</strong>：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里再提一下：<br>synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</p></blockquote>\n</li>\n</ol>\n<p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单利模式的原理！”<br><strong>双重校验锁实现对象单例（线程安全）</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> uniqueInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Singleton</span> <span class=\"token function\">getUniqueInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>uniqueInstance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//类对象加锁</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>uniqueInstance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    uniqueInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> uniqueInstance<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。<br>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 uniqueInstance 分配内存空间</li>\n<li>初始化 uniqueInstance</li>\n<li>将 uniqueInstance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回uniqueInstance，但此时 uniqueInstance 还未被初始化。<br>使用 volatile 可以<strong>禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。</p>\n<h2 id=\"3-23-讲一下-synchronized-关键字的底层原理\"><a href=\"#3-23-讲一下-synchronized-关键字的底层原理\" class=\"headerlink\" title=\"3.23.讲一下 synchronized 关键字的底层原理\"></a>3.23.讲一下 synchronized 关键字的底层原理</h2><p>synchronized 关键字底层原理属于 JVM 层面。</p>\n<h3 id=\"synchronized-同步语句块的情况\"><a href=\"#synchronized-同步语句块的情况\" class=\"headerlink\" title=\"synchronized 同步语句块的情况\"></a>synchronized 同步语句块的情况</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SynchronizedDemo</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"synchronized 代码块\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行** javap -c -s -v -l SynchronizedDemo.class **。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301181353329.png\"><br>从上面我们可以看出：<br>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。<br>当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>\n<h3 id=\"synchronized-修饰方法的的情况\"><a href=\"#synchronized-修饰方法的的情况\" class=\"headerlink\" title=\"synchronized 修饰方法的的情况\"></a>synchronized 修饰方法的的情况</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SynchronizedDemo</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"synchronized 方法\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301181354433.png\"><br>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>\n<h2 id=\"3-24-为什么要用线程池？\"><a href=\"#3-24-为什么要用线程池？\" class=\"headerlink\" title=\"3.24.为什么要用线程池？\"></a>3.24.为什么要用线程池？</h2><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>\n<ul>\n<li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h2 id=\"3-25-实现Runnable接口和Callable接口的区别\"><a href=\"#3-25-实现Runnable接口和Callable接口的区别\" class=\"headerlink\" title=\"3.25.实现Runnable接口和Callable接口的区别\"></a>3.25.实现Runnable接口和Callable接口的区别</h2><p>如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于Runnable 接口不会返回结果但是 Callable 接口可以返回结果。<br>备注： 工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。<br>( Executors.callable（Runnable task） 或 Executors.callable(Runnable task，Object resule))。</p>\n<h2 id=\"3-26-执行execute-方法和submit-方法的区别是什么呢？\"><a href=\"#3-26-执行execute-方法和submit-方法的区别是什么呢？\" class=\"headerlink\" title=\"3.26.执行execute()方法和submit()方法的区别是什么呢？\"></a>3.26.执行execute()方法和submit()方法的区别是什么呢？</h2><ol>\n<li>execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>\n<li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit） 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>\n</ol>\n<h2 id=\"3-27-如何创建线程池\"><a href=\"#3-27-如何创建线程池\" class=\"headerlink\" title=\"3.27.如何创建线程池\"></a>3.27.如何创建线程池</h2><ol>\n<li>通过构造方法实现</li>\n<li>通过Executor 框架的工具类Executors来实现，我们可以创建三种类型的ThreadPoolExecutor：<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。<br>当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<br><strong>SingleThreadExecutor</strong>： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<br><strong>CachedThreadPool</strong>： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p></blockquote>\n</li>\n</ol>\n<h1 id=\"四、Spring篇\"><a href=\"#四、Spring篇\" class=\"headerlink\" title=\"四、Spring篇\"></a>四、Spring篇</h1><h2 id=\"4-1-Spring的IOC和AOP机制？\"><a href=\"#4-1-Spring的IOC和AOP机制？\" class=\"headerlink\" title=\"4.1.Spring的IOC和AOP机制？\"></a>4.1.Spring的IOC和AOP机制？</h2><p>我们是在使用Spring框架的过程中，其实就是为了使用IOC，依赖注入，和AOP，面向切面编程，这两个是Spring的灵魂<br>主要用到的设计模式有<strong>工厂模式</strong>和<strong>代理模式</strong>。<br><strong>IOC就是典型的工厂模式</strong>，通过sessionfactory去注入实例。<br><strong>AOP就是典型的代理模式</strong>的体现。<br>代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。<br>spring的IOC容器是spring的核心，spring AOP是spring框架的重要组成部分。在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IOC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。<br>面向方面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面。spring AOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。在spring中，未来使<br>IOC方便地使用健壮、灵活的企业服务，需要利用spring AOP实现为IoC和企业服务之间建立联系。<br>IOC:控制反转也叫依赖注入。利用了工厂模式将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。<br>spring IOC初始化流程:<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301221118868.png\"><br>AOP:面向切面编程。（Aspect-Oriented Programming）<br>AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。<br>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p>\n<h2 id=\"4-2-Spring中Autowired和Resource关键字的区别？\"><a href=\"#4-2-Spring中Autowired和Resource关键字的区别？\" class=\"headerlink\" title=\"4.2.Spring中Autowired和Resource关键字的区别？\"></a>4.2.Spring中Autowired和Resource关键字的区别？</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>\n<h3 id=\"共同点\"><a href=\"#共同点\" class=\"headerlink\" title=\"共同点\"></a>共同点</h3><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>\n<h3 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h3><h4 id=\"Autowired\"><a href=\"#Autowired\" class=\"headerlink\" title=\"@Autowired\"></a>@Autowired</h4><p>@Autowired为Spring提供的注解，需要导入包<br>org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 下面两种@Autowired只要使用一种即可</span>\n  <span class=\"token annotation punctuation\">@Autowired</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDao</span> userDao<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 用于字段上</span>\n \n  <span class=\"token annotation punctuation\">@Autowired</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDao</span> userDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 用于属性的方法上</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDao<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p>\n<h4 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"@Resource\"></a>@Resource</h4><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。<br>@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 下面两种@Resource只要使用一种即可</span>\n  <span class=\"token annotation punctuation\">@Resource</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"userDao\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDao</span> userDao<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 用于字段上</span>\n \n  <span class=\"token annotation punctuation\">@Resource</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"userDao\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDao</span> userDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 用于属性的setter方法上</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDao<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p></blockquote>\n<p><strong>@Resource装配顺序：</strong></p>\n<ol>\n<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li>\n<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li>\n<li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li>\n<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</li>\n</ol>\n<h2 id=\"4-3-依赖注入的方式有几种，各是什么\"><a href=\"#4-3-依赖注入的方式有几种，各是什么\" class=\"headerlink\" title=\"4.3.依赖注入的方式有几种，各是什么?\"></a>4.3.依赖注入的方式有几种，各是什么?</h2><ol>\n<li>构造器注入<br>将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。<br>优点：对象初始化完成后便可获得可使用的对象。<br>缺点：当需要注入的对象很多时，构造器参数列表将会很长；不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</li>\n<li>setter方法注入<br>IoC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。<br>优点：灵活。可以选择性地注入需要的对象。<br>缺点：依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</li>\n<li>接口注入<br>依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。<br>优点：接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。<br>缺点：侵入行太强，不建议使用。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>PS：什么是侵入行？<br>如果类A要使用别人提供的一个功能，若为了使用这功能，需要在自己的类中增加额外的代码，这就是侵入性。</p></blockquote>\n</li>\n</ol>\n<h2 id=\"4-4-讲一下什么是Spring\"><a href=\"#4-4-讲一下什么是Spring\" class=\"headerlink\" title=\"4.4.讲一下什么是Spring\"></a>4.4.讲一下什么是Spring</h2><p>Spring是一个<strong>轻量级的IoC和AOP容器框架</strong>。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：<strong>基于XML的配置、基于注解的配置、基于Java的配置。</strong><br>主要由以下几个模块组成：<br><strong>Spring Core</strong>：核心类库，提供IOC服务；<br><strong>Spring Context</strong>：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；<br><strong>Spring AOP</strong>：AOP服务；<br><strong>Spring DAO</strong>：对JDBC的抽象，简化了数据访问异常的处理；<br><strong>Spring ORM</strong>：对现有的ORM框架的支持；<br><strong>Spring Web</strong>：提供了基本的面向Web的综合特性，例如多方文件上传；<br><strong>Spring MVC</strong>：提供面向Web应用的Model-View-Controller实现。</p>\n<h2 id=\"4-5-Spring-MVC流程\"><a href=\"#4-5-Spring-MVC流程\" class=\"headerlink\" title=\"4.5.Spring MVC流程\"></a>4.5.Spring MVC流程</h2><p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301221118084.png\"><br>执行前；当一个请求发来时先进服务器（Tomcat）,在服务器中会有拦截器，过滤器啊，等这些功能走完之后，才真正的进入了框架中。</p>\n<ol>\n<li>用户发来一个请求，首先进入的是前端控制器DispatcherServlet</li>\n<li>前端控制器将（DispacherServlet）用户发来的请求发送给处理器映射器（HandlerMapping）</li>\n<li>处理器映射器根据前端控制器发来的用户的请求找到对应符合的控制器（Handler）,并且将其封装成处理器执行链，返回给前端控制器。</li>\n<li>处理器适配器接收到来自前端控制器的执行链后，找到对应执行此执行链的处理器适配器（HandlerAdapter）来调用的具体的控制器（就是说其对应的方法或者逻辑）</li>\n<li>控制器执行完成后，会返回一个ModelAndView对象给处理器适配器</li>\n<li>处理器适配器将返回来的ModelAndView对象返回给前端控制器(到这里所有的业务处理过程就要完了，接下就是将结果以页面的的形式相应给用户)</li>\n<li>前端控制器将返回回来的ModelAndView对象交给视图解析器（ViewResolver），视图解析器根据传过里的View对象解析成对应的页面对象，然后将页面对象和Model对象返回给前端控制器。</li>\n<li>前端控制器再将返回回来的对象交给视图（View）,视图根据传过来的Model对象再一次的对页面进行渲染，然后在返回给前端控制器。</li>\n<li>前端控制器将完成的结果响应给浏览器，然后浏览器在展现给用户。</li>\n</ol>\n<p><strong>组件说明：</strong><br>以下组件通常使用框架提供实现：<br><strong>DispatcherServlet</strong>：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。<br><strong>HandlerMapping</strong>：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。<br><strong>HandlAdapter</strong>：通过扩展处理器适配器，支持更多类型的处理器。<br><strong>ViewResolver</strong>：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</p>\n<h2 id=\"4-6-SpringMVC怎么样设定重定向和转发的？\"><a href=\"#4-6-SpringMVC怎么样设定重定向和转发的？\" class=\"headerlink\" title=\"4.6.SpringMVC怎么样设定重定向和转发的？\"></a>4.6.SpringMVC怎么样设定重定向和转发的？</h2><p><strong>转发</strong>：在返回值前面加”forward:“，譬如”forward:user.do?name&#x3D;alihai5”<br><strong>重定向</strong>：在返回值前面加”redirect:”，如”redirect:<a href=\"https://www.alihai5.com/\">https://www.alihai5.com</a>“</p>\n<h2 id=\"4-7-SpringMVC常用的注解有哪些？\"><a href=\"#4-7-SpringMVC常用的注解有哪些？\" class=\"headerlink\" title=\"4.7.SpringMVC常用的注解有哪些？\"></a>4.7.SpringMVC常用的注解有哪些？</h2><p><strong>@RequestMapping</strong>：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。<br><strong>@RequestBody</strong>：注解实现接收http请求的json数据，将json转换为java对象。<br><strong>@ResponseBody</strong>：注解实现将conreoller方法返回对象转化为json对象响应给客户</p>\n<h2 id=\"4-8-Spring的AOP理解：\"><a href=\"#4-8-Spring的AOP理解：\" class=\"headerlink\" title=\"4.8.Spring的AOP理解：\"></a>4.8.Spring的AOP理解：</h2><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。<br>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务<br>处理。<br>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>\n<ol>\n<li>AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</li>\n<li>Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</li>\n<li>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>\n<ol>\n<li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li>\n<li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li>\n</ol></blockquote>\n</li>\n</ol>\n<h2 id=\"4-9-Spring的IOC理解\"><a href=\"#4-9-Spring的IOC理解\" class=\"headerlink\" title=\"4.9.Spring的IOC理解\"></a>4.9.Spring的IOC理解</h2><ol>\n<li>IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</li>\n<li>最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</li>\n<li>Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</li>\n</ol>\n<h2 id=\"4-10-解释一下spring-bean的生命周期\"><a href=\"#4-10-解释一下spring-bean的生命周期\" class=\"headerlink\" title=\"4.10.解释一下spring bean的生命周期\"></a>4.10.解释一下spring bean的生命周期</h2><p>首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；<br>Spring上下文中的Bean生命周期也类似，如下：</p>\n<ol>\n<li><p>实例化Bean：对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p>\n</li>\n<li><p>设置对象属性（依赖注入）：实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p>\n</li>\n<li><p>处理Aware接口：接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；<br>②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。<br>③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p></blockquote>\n</li>\n<li><p>BeanPostProcessor：如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p>\n</li>\n<li><p>InitializingBean 与 init-method：如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p>\n</li>\n<li><p>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术。</p>\n</li>\n</ol>\n<p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p>\n<ol start=\"7\">\n<li>DisposableBean：当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法。</li>\n<li>destroy-method：最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</li>\n</ol>\n<h2 id=\"4-11-解释Spring支持的几种bean的作用域。\"><a href=\"#4-11-解释Spring支持的几种bean的作用域。\" class=\"headerlink\" title=\"4.11.解释Spring支持的几种bean的作用域。\"></a>4.11.解释Spring支持的几种bean的作用域。</h2><p>Spring容器中的bean可以分为5个范围：</p>\n<ol>\n<li>singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</li>\n<li>prototype：为每一个bean请求提供一个实例。</li>\n<li>request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li>\n<li>session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li>\n<li>global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</li>\n</ol>\n<h2 id=\"4-12-Spring基于xml注入bean的几种方式：\"><a href=\"#4-12-Spring基于xml注入bean的几种方式：\" class=\"headerlink\" title=\"4.12. Spring基于xml注入bean的几种方式：\"></a>4.12. Spring基于xml注入bean的几种方式：</h2><ol>\n<li>Set方法注入；</li>\n<li>构造器注入：<ol>\n<li>通过index设置参数的位置；</li>\n<li>通过type设置参数类型；</li>\n</ol>\n</li>\n<li>静态工厂注入；</li>\n<li>实例工厂；</li>\n</ol>\n<h2 id=\"4-13-Spring框架中都用到了哪些设计模式？\"><a href=\"#4-13-Spring框架中都用到了哪些设计模式？\" class=\"headerlink\" title=\"4.13.Spring框架中都用到了哪些设计模式？\"></a>4.13.Spring框架中都用到了哪些设计模式？</h2><ol>\n<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li>\n<li>单例模式：Bean默认为单例模式。</li>\n<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li>\n<li>模板方法：用来解决代码重复的问题。比如RestTemplate,JmsTemplate, JpaTemplate。</li>\n<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener.</li>\n</ol>\n<h1 id=\"五、MyBatis篇\"><a href=\"#五、MyBatis篇\" class=\"headerlink\" title=\"五、MyBatis篇\"></a>五、MyBatis篇</h1><h2 id=\"5-1-什么是MyBatis\"><a href=\"#5-1-什么是MyBatis\" class=\"headerlink\" title=\"5.1.什么是MyBatis\"></a>5.1.什么是MyBatis</h2><ol>\n<li>Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</li>\n<li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>\n<li>通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</li>\n</ol>\n<h2 id=\"5-2-MyBatis的优点和缺点\"><a href=\"#5-2-MyBatis的优点和缺点\" class=\"headerlink\" title=\"5.2.MyBatis的优点和缺点\"></a>5.2.MyBatis的优点和缺点</h2><p><strong>优点</strong></p>\n<ol>\n<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</li>\n<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</li>\n<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</li>\n<li>能够与Spring很好的集成；</li>\n<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>\n<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>\n</ol>\n<h2 id=\"5-3-和-的区别是什么？\"><a href=\"#5-3-和-的区别是什么？\" class=\"headerlink\" title=\"5.3.#{}和${}的区别是什么？\"></a>5.3.#{}和${}的区别是什么？</h2><p><strong>#{}是预编译处理，$ {}是字符串替换</strong>。<br>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理$ {}时，就是把$ {}替换成变量的值。<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>\n<h2 id=\"5-4-当实体类中的属性名和表中的字段名不一样-，怎么办-？\"><a href=\"#5-4-当实体类中的属性名和表中的字段名不一样-，怎么办-？\" class=\"headerlink\" title=\"5.4.当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\"></a>5.4.当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h2><p>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>select</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>selectorder<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">parametertype</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>int<span class=\"token punctuation\">\"</span></span>\n  <span class=\"token attr-name\">resultetype</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>me.gacl.domain.order<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  select order_id id, order_no orderno ,order_price price form orders where\n  order_id=#&#123;id&#125;;\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>select</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第2种： 通过来映射字段名和实体类属性名的一一对应的关系。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>select</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>getOrder<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">parameterType</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>int<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">resultMap</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>orderresultmap<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  select * from orders where order_id=#&#123;id&#125;\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>select</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>resultMap</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>me.gacl.domain.order<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>orderresultmap<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>!–用id属性来映射主键字段–</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>id</span> <span class=\"token attr-name\">property</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>id<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">column</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>order_id<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>result</span> <span class=\"token attr-name\">property</span> <span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span> <span class=\"token punctuation\">\"</span>orderno<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">column</span> <span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>order_no<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>result</span> <span class=\"token attr-name\">property</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>price<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">column</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>order_price<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>reslutMap</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"5-5-Mybatis是如何进行分页的？分页插件的原理是什么？\"><a href=\"#5-5-Mybatis是如何进行分页的？分页插件的原理是什么？\" class=\"headerlink\" title=\"5.5.Mybatis是如何进行分页的？分页插件的原理是什么？\"></a>5.5.Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。<br>可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>\n<h2 id=\"5-6-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\"><a href=\"#5-6-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"5.6.Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\"></a>5.6.Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用标签，逐一定义数据库列名和对象属性名之间的映射关系。<br>第二种是使用sql列的别名功能，将列的别名书写为对象属性名。<br>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h2 id=\"5-7-如何执行批量插入？\"><a href=\"#5-7-如何执行批量插入？\" class=\"headerlink\" title=\"5.7.如何执行批量插入？\"></a>5.7.如何执行批量插入？</h2><p>首先,创建一个简单的insert语句:</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>insert</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>insertname<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  insert into names (name) values (#&#123;value&#125;)\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>insert</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>然后在java代码中像下面这样执行批处理插入:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">list<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>string<span class=\"token punctuation\">></span></span> names <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">arraylist</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnames<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>“fred”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnames<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>“barney”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnames<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>“betty”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nnames<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>“wilma”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 注意这里 executortype.batch</span>\nsqlsession sqlsession <span class=\"token operator\">=</span> sqlsessionfactory<span class=\"token punctuation\">.</span><span class=\"token function\">opensession</span><span class=\"token punctuation\">(</span>executortype<span class=\"token punctuation\">.</span>batch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n    namemapper mapper <span class=\"token operator\">=</span> sqlsession<span class=\"token punctuation\">.</span><span class=\"token function\">getmapper</span><span class=\"token punctuation\">(</span>namemapper<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>string name <span class=\"token operator\">:</span> names<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        mapper<span class=\"token punctuation\">.</span><span class=\"token function\">insertname</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    sqlsession<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    sqlSession<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">throw</span> e<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n    sqlsession<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"5-8-MyBatis实现一对一有几种方式-具体怎么操作的？\"><a href=\"#5-8-MyBatis实现一对一有几种方式-具体怎么操作的？\" class=\"headerlink\" title=\"5.8.MyBatis实现一对一有几种方式?具体怎么操作的？\"></a>5.8.MyBatis实现一对一有几种方式?具体怎么操作的？</h2><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；<br>嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。</p>\n<h2 id=\"5-9-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\"><a href=\"#5-9-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\" class=\"headerlink\" title=\"5.9.Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\"></a>5.9.Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。<br>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。<br>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的</p>\n<h2 id=\"5-10-Mybatis的一级、二级缓存\"><a href=\"#5-10-Mybatis的一级、二级缓存\" class=\"headerlink\" title=\"5.10.Mybatis的一级、二级缓存:\"></a>5.10.Mybatis的一级、二级缓存:</h2><ol>\n<li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li>\n<li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；</li>\n<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了C&#x2F;U&#x2F;D操作后，默认该作用域下所有 select 中的缓存将被 clear 掉并重新更新，如果开启了二级缓存，则只根据配置判断是否刷新。</li>\n</ol>\n<h1 id=\"六、SpringBoot篇\"><a href=\"#六、SpringBoot篇\" class=\"headerlink\" title=\"六、SpringBoot篇\"></a>六、SpringBoot篇</h1><h2 id=\"6-1-什么是SpringBoot？为什么要用SpringBoot\"><a href=\"#6-1-什么是SpringBoot？为什么要用SpringBoot\" class=\"headerlink\" title=\"6.1.什么是SpringBoot？为什么要用SpringBoot\"></a>6.1.什么是SpringBoot？为什么要用SpringBoot</h2><p>用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件）<br>创建独立的spring引用程序 main方法运行<br>嵌入的Tomcat 无需部署war文件简化maven配置<br>自动配置spring添加对应功能starter自动化配置<br>spring boot来简化spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用<br>Spring Boot 优点非常多，如：<br><strong>一、独立运行</strong><br>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。<br><strong>二、简化配置</strong><br>spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。<br><strong>三、自动配置</strong><br>Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。<br><strong>四、无代码生成和XML配置</strong><br>Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。<br><strong>五、应用监控</strong><br>Spring Boot提供一系列端点可以监控服务及应用，做健康检测。</p>\n<h2 id=\"6-2-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？\"><a href=\"#6-2-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？\" class=\"headerlink\" title=\"6.2.Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？\"></a>6.2.Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下<br>3 个注解：<br><strong>@SpringBootConfiguration</strong>：组合了 @Configuration 注解，实现配置文件的功能。<br><strong>@EnableAutoConfiguration</strong>：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源<br>自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。<br><strong>@ComponentScan</strong>：Spring组件扫描。</p>\n<h2 id=\"6-3-运行Spring-Boot有哪几种方式？\"><a href=\"#6-3-运行Spring-Boot有哪几种方式？\" class=\"headerlink\" title=\"6.3.运行Spring Boot有哪几种方式？\"></a>6.3.运行Spring Boot有哪几种方式？</h2><ol>\n<li>打包用命令或者放到容器中运行</li>\n<li>用 Maven&#x2F;Gradle 插件运行</li>\n<li>直接执行 main 方法运行</li>\n</ol>\n<h2 id=\"6-4-如何理解-Spring-Boot-中的-Starters？\"><a href=\"#6-4-如何理解-Spring-Boot-中的-Starters？\" class=\"headerlink\" title=\"6.4.如何理解 Spring Boot 中的 Starters？\"></a>6.4.如何理解 Spring Boot 中的 Starters？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Starters是什么：<br>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA访问数据库，只要加入spring-boot-starter-data-jpa启动器依赖就能使用了。Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。<br>Starters命名：<br>Spring Boot官方的启动器都是以spring-boot-starter-命名的，代表了一个特定的应用类型。第三方的启动器不能以spring-boot开头命名，它们都被Spring Boot官方保留。一般一个第三方的应该这样命名，像mybatis的mybatis-spring-boot-starter。</p></blockquote>\n<p>Starters分类：</p>\n<ol>\n<li><p>Spring Boot应用类启动器</p>\n<table>\n<thead>\n<tr>\n<th><strong>启动器名称</strong></th>\n<th><strong>功能描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>spring-boot-starter</td>\n<td>包含自动配置、日志、YAML的支持。</td>\n</tr>\n<tr>\n<td>spring-boot-starter-web</td>\n<td>使用Spring MVC构建web 工程，包含restful，默认使用Tomcat容器。</td>\n</tr>\n<tr>\n<td>……</td>\n<td>…..</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>Spring Boot生产启动器</p>\n<table>\n<thead>\n<tr>\n<th><strong>启动器名称</strong></th>\n<th><strong>功能描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>spring-boot-starter-actuator</td>\n<td>提供生产环境特性，能监控管理应用。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>Spring Boot技术类启动器</p>\n<table>\n<thead>\n<tr>\n<th><strong>启动器名称</strong></th>\n<th><strong>功能描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>spring-boot-starter-json</td>\n<td>提供对JSON的读写支持。</td>\n</tr>\n<tr>\n<td>spring-boot-starter-logging</td>\n<td>默认的日志启动器，默认使用Logback。</td>\n</tr>\n<tr>\n<td>……</td>\n<td>…..</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>其他第三方启动器</p>\n</li>\n</ol>\n<h2 id=\"6-5-如何在Spring-Boot启动的时候运行一些特定的代码？\"><a href=\"#6-5-如何在Spring-Boot启动的时候运行一些特定的代码？\" class=\"headerlink\" title=\"6.5.如何在Spring Boot启动的时候运行一些特定的代码？\"></a>6.5.如何在Spring Boot启动的时候运行一些特定的代码？</h2><p>如果你想在Spring Boot启动的时候运行一些特定的代码，你可以实现接口ApplicationRunner或者CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个run方法。<br>CommandLineRunner：启动获取命令行参数</p>\n<h2 id=\"6-6-Spring-Boot-需要独立的容器运行吗？\"><a href=\"#6-6-Spring-Boot-需要独立的容器运行吗？\" class=\"headerlink\" title=\"6.6.Spring Boot 需要独立的容器运行吗？\"></a>6.6.Spring Boot 需要独立的容器运行吗？</h2><p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p>\n<h2 id=\"6-7-Spring-Boot中的监视器是什么？\"><a href=\"#6-7-Spring-Boot中的监视器是什么？\" class=\"headerlink\" title=\"6.7. Spring Boot中的监视器是什么？\"></a>6.7. Spring Boot中的监视器是什么？</h2><p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态</p>\n<h2 id=\"6-8-如何使用Spring-Boot实现异常处理？\"><a href=\"#6-8-如何使用Spring-Boot实现异常处理？\" class=\"headerlink\" title=\"6.8. 如何使用Spring Boot实现异常处理？\"></a>6.8. 如何使用Spring Boot实现异常处理？</h2><p>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法。 我们通过实现一个ControlerAdvice类，来处理控制器类抛出的所有异常</p>\n<h2 id=\"6-9-你如何理解-Spring-Boot-中的-Starters？\"><a href=\"#6-9-你如何理解-Spring-Boot-中的-Starters？\" class=\"headerlink\" title=\"6.9.你如何理解 Spring Boot 中的 Starters？\"></a>6.9.你如何理解 Spring Boot 中的 Starters？</h2><p>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成 Spring及其他技术，而不需要到处找示例代码和依赖包。如你想使用 Spring JPA 访问数据库，只要加入spring-boot-starter-data-jpa 启动器依赖就能使用了</p>\n<h2 id=\"6-10-springboot常用的starter有哪些\"><a href=\"#6-10-springboot常用的starter有哪些\" class=\"headerlink\" title=\"6.10. springboot常用的starter有哪些\"></a>6.10. springboot常用的starter有哪些</h2><p><strong>spring-boot-starter-web</strong> 嵌入tomcat和web开发需要servlet与jsp支持<br><strong>spring-boot-starter-data-jpa</strong> 数据库支持<br><strong>spring-boot-starter-data-redis</strong> redis数据库支持<br><strong>spring-boot-starter-data-solr</strong> solr支持<br><strong>mybatis-spring-boot-starter</strong> 第三方的mybatis集成starter</p>\n<h2 id=\"6-11-SpringBoot-实现热部署有哪几种方式？\"><a href=\"#6-11-SpringBoot-实现热部署有哪几种方式？\" class=\"headerlink\" title=\"6.11.SpringBoot 实现热部署有哪几种方式？\"></a>6.11.SpringBoot 实现热部署有哪几种方式？</h2><p>主要有两种方式：</p>\n<ol>\n<li>Spring Loaded</li>\n<li>Spring-boot-devtools</li>\n</ol>\n<h2 id=\"6-12-如何理解-Spring-Boot-配置加载顺序？\"><a href=\"#6-12-如何理解-Spring-Boot-配置加载顺序？\" class=\"headerlink\" title=\"6.12.如何理解 Spring Boot 配置加载顺序？\"></a>6.12.如何理解 Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>\n<ol>\n<li>properties文件；</li>\n<li>YAML文件；</li>\n<li>系统环境变量；</li>\n<li>命令行参数；<br>等等……</li>\n</ol>\n<h2 id=\"6-13-Spring-Boot-的核心配置文件有哪几个？它们的区别是什么？\"><a href=\"#6-13-Spring-Boot-的核心配置文件有哪几个？它们的区别是什么？\" class=\"headerlink\" title=\"6.13.Spring Boot 的核心配置文件有哪几个？它们的区别是什么？\"></a>6.13.Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</h2><p>spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。<br>application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。<br>bootstrap 配置文件有以下几个应用场景：</p>\n<ol>\n<li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li>\n<li>一些固定的不能被覆盖的属性；</li>\n<li>一些加密&#x2F;解密的场景；</li>\n</ol>\n<h2 id=\"6-14-如何集成-Spring-Boot-和-ActiveMQ？\"><a href=\"#6-14-如何集成-Spring-Boot-和-ActiveMQ？\" class=\"headerlink\" title=\"6.14.如何集成 Spring Boot 和 ActiveMQ？\"></a>6.14.如何集成 Spring Boot 和 ActiveMQ？</h2><p>对于集成 Spring Boot 和 ActiveMQ，我们使用spring-boot-starter-activemq依赖关系。 它只需要很少的配置，并且不需要样板代码。</p>\n<h2 id=\"6-15-如何重新加载Spring-Boot上的更改，而无需重新启动服务器？\"><a href=\"#6-15-如何重新加载Spring-Boot上的更改，而无需重新启动服务器？\" class=\"headerlink\" title=\"6.15.如何重新加载Spring Boot上的更改，而无需重新启动服务器？\"></a>6.15.如何重新加载Spring Boot上的更改，而无需重新启动服务器？</h2><p>这可以使用DEV工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat将重新启动。<br>Spring Boot有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。<br>开发人员可以重新加载Spring Boot上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot在发布它的第一个版本时没有这个功能。<br>这是开发人员最需要的功能。DevTools模块完全满足开发人员的需求。该模块将在生产环境中被禁用。</p>\n<h2 id=\"6-16-Spring-Boot、Spring-MVC-和-Spring-有什么区别？\"><a href=\"#6-16-Spring-Boot、Spring-MVC-和-Spring-有什么区别？\" class=\"headerlink\" title=\"6.16.Spring Boot、Spring MVC 和 Spring 有什么区别？\"></a>6.16.Spring Boot、Spring MVC 和 Spring 有什么区别？</h2><p><strong>Spring</strong><br>Spring最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。<br>当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。<br><strong>Spring MVC</strong><br>Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。<br><strong>SpringBoot</strong><br>Spring 和 SpringMVC 的问题在于需要配置大量的参数。Spring Boot 通过一个自动配置和启动的项来目解决这个问题。为了更快的构建产品就绪应用程序，Spring Boot 提供了一些非功能性特征。</p>\n<h2 id=\"6-17-pring-Boot-还提供了其它的哪些-Starter-Project-Options？\"><a href=\"#6-17-pring-Boot-还提供了其它的哪些-Starter-Project-Options？\" class=\"headerlink\" title=\"6.17.pring Boot 还提供了其它的哪些 Starter Project Options？\"></a>6.17.pring Boot 还提供了其它的哪些 Starter Project Options？</h2><p>Spring Boot 也提供了其它的启动器项目包括，包括用于开发特定类型应用程序的典型依赖项。<br><strong>spring-boot-starter-web-services</strong> - SOAP Web Services；<br><strong>spring-boot-starter-web</strong> - Web 和 RESTful 应用程序；<br><strong>spring-boot-starter-test</strong> - 单元测试和集成测试；<br><strong>spring-boot-starter-jdbc</strong> - 传统的 JDBC；<br><strong>spring-boot-starter-hateoas</strong> - 为服务添加 HATEOAS 功能；<br><strong>spring-boot-starter-security</strong> - 使用 SpringSecurity 进行身份验证和授权；<br><strong>spring-boot-starter-data-jpa</strong> - 带有 Hibeernate 的 Spring Data JPA；<br><strong>spring-boot-starter-data-rest</strong> - 使用 Spring Data REST 公布简单的 REST 服务；</p>\n<h1 id=\"七、MySQL篇\"><a href=\"#七、MySQL篇\" class=\"headerlink\" title=\"七、MySQL篇\"></a>七、MySQL篇</h1><h2 id=\"7-1-数据库的三范式是什么\"><a href=\"#7-1-数据库的三范式是什么\" class=\"headerlink\" title=\"7.1.数据库的三范式是什么\"></a>7.1.数据库的三范式是什么</h2><p><strong>第一范式</strong>：列不可再分<br><strong>第二范式</strong>：行可以唯一区分，主键约束<br><strong>第三范式</strong>：表的非主属性不能依赖与其他表的非主属性 外键约束<br>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p>\n<h2 id=\"7-2-数据库引擎有哪些\"><a href=\"#7-2-数据库引擎有哪些\" class=\"headerlink\" title=\"7.2.数据库引擎有哪些\"></a>7.2.数据库引擎有哪些</h2><p>如何查看mysql提供的所有存储引擎</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">show</span> engines<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>mysql常用引擎包括：<strong>MYISAM</strong>、<strong>Innodb</strong>、<strong>Memory</strong>、<strong>MERGE</strong><br><strong>MYISAM</strong>：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎<br><strong>Innodb</strong>：行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些<br><strong>Memory</strong>：全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变化不频繁的代码表<br><strong>MERGE</strong>：是一组MYISAM表的组合</p>\n<h2 id=\"7-3-InnoDB与MyISAM的区别\"><a href=\"#7-3-InnoDB与MyISAM的区别\" class=\"headerlink\" title=\"7.3.InnoDB与MyISAM的区别\"></a>7.3.InnoDB与MyISAM的区别</h2><ol>\n<li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>\n<li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li>\n<li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>\n<li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>\n<li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li>\n</ol>\n<p>如何选择引擎？<br>如果没有特别的需求，使用默认的 Innodb 即可。<br><strong>MyISAM</strong>：以读写插入为主的应用程序，比如博客系统、新闻门户网站。<br><strong>Innodb</strong>：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统</p>\n<h2 id=\"7-4-数据库的事务\"><a href=\"#7-4-数据库的事务\" class=\"headerlink\" title=\"7.4.数据库的事务\"></a>7.4.数据库的事务</h2><p>什么是事务？： 多条sql语句，要么全部成功，要么全部失败。<br>事务的特性：<br>数据库事务特性：<strong>原子性(Atomic)、一致性(Consistency)、隔离性(Isolation)、持久性(Durabiliy)。简称ACID</strong>。<br><strong>原子性</strong>：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。<br><strong>一致性</strong>：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。<br><strong>隔离性</strong>：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰<br><strong>持久性</strong>：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。</p>\n<h2 id=\"7-5-索引问题\"><a href=\"#7-5-索引问题\" class=\"headerlink\" title=\"7.5.索引问题\"></a>7.5.索引问题</h2><p>索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。<br>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。<br>mysql 有4种不同的索引：<br><strong>主键索引（PRIMARY）</strong><br>数据列不允许重复，不允许为NULL，一个表只能有一个主键。<br><strong>唯一索引（UNIQUE）</strong><br>数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。<br>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引<br>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引<br><strong>普通索引（INDEX）</strong><br>可以通过 ALTER TABLE table_name ADD INDEX index_name (column); 创建普通索引可以通过 ALTER TABLE table_name ADD INDEX index_name(column1,column2,column3); 创建组合索引<br><strong>全文索引（FULLTEXT）</strong><br>可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引<br>索引<strong>并非是越多越好</strong>，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时要花费较多的时间维护索引</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>索引加快数据库的检索速度<br>索引降低了插入、删除、修改等维护任务的速度<br>唯一索引可以确保每一行数据的唯一性<br>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能<br>索引需要占物理和数据空间</p></blockquote>\n<h2 id=\"7-6-SQL优化\"><a href=\"#7-6-SQL优化\" class=\"headerlink\" title=\"7.6.SQL优化\"></a>7.6.SQL优化</h2><ol>\n<li>查询语句中不要使用select *</li>\n<li>尽量减少子查询，使用关联查询（left join,right join,inner join）替代</li>\n<li>减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代</li>\n<li>or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好)</li>\n<li>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>\n<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num&#x3D;0</li>\n</ol>\n<h2 id=\"7-7-简单说一说drop、delete与truncate的区别\"><a href=\"#7-7-简单说一说drop、delete与truncate的区别\" class=\"headerlink\" title=\"7.7.简单说一说drop、delete与truncate的区别\"></a>7.7.简单说一说drop、delete与truncate的区别</h2><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别<br>delete和truncate只删除表的数据不删除表的结构<br>速度,一般来说: <strong>drop&gt; truncate &gt;delete</strong><br>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger。</p>\n<h2 id=\"7-8-什么是视图\"><a href=\"#7-8-什么是视图\" class=\"headerlink\" title=\"7.8.什么是视图\"></a>7.8.什么是视图</h2><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>\n<h2 id=\"7-9-什么是内联接、左外联接、右外联接？\"><a href=\"#7-9-什么是内联接、左外联接、右外联接？\" class=\"headerlink\" title=\"7.9.什么是内联接、左外联接、右外联接？\"></a>7.9.什么是内联接、左外联接、右外联接？</h2><ol>\n<li>内联接（Inner Join）：匹配2张表中相关联的记录。</li>\n<li>左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。</li>\n<li>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右位置关系。</li>\n</ol>\n<h2 id=\"7-10-并发事务带来哪些问题\"><a href=\"#7-10-并发事务带来哪些问题\" class=\"headerlink\" title=\"7.10.并发事务带来哪些问题?\"></a>7.10.并发事务带来哪些问题?</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。<br><strong>脏读（Dirty read）</strong>: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<br><strong>丢失修改（Lost to modify）</strong>: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。<br><strong>不可重复读（Unrepeatableread）</strong>: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<br><strong>幻读（Phantom read）</strong>: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>不可重复读和幻读区别：</strong><br>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p></blockquote>\n<h2 id=\"7-11-事务隔离级别有哪些-MySQL的默认隔离级别是\"><a href=\"#7-11-事务隔离级别有哪些-MySQL的默认隔离级别是\" class=\"headerlink\" title=\"7.11.事务隔离级别有哪些?MySQL的默认隔离级别是?\"></a>7.11.事务隔离级别有哪些?MySQL的默认隔离级别是?</h2><p>SQL 标准定义了四个隔离级别：<br><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>\n<table>\n<thead>\n<tr>\n<th><strong>隔离级别</strong></th>\n<th><strong>脏读</strong></th>\n<th><strong>不可重复读</strong></th>\n<th><strong>幻影读</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>READ-UNCOMMITTED</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>READ-COMMITTED</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>REPEATABLE-READ</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>SERIALIZABLE</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation; 命令来查看</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@tx_isolation</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span>\n<span class=\"token operator\">|</span> @<span class=\"token variable\">@tx_isolation</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span>\n<span class=\"token operator\">|</span> <span class=\"token keyword\">REPEATABLE</span><span class=\"token operator\">-</span><span class=\"token keyword\">READ</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token comment\">-----------------+</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。<br>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。</p></blockquote>\n<h2 id=\"7-12-大表如何优化？\"><a href=\"#7-12-大表如何优化？\" class=\"headerlink\" title=\"7.12.大表如何优化？\"></a>7.12.大表如何优化？</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下:</p>\n<ol>\n<li>限定数据的范围<br>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li>\n<li>读&#x2F;写分离<br>经典的数据库拆分方案，主库负责写，从库负责读；</li>\n<li>垂直分区<br>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。<br>垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。<br>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>\n<li>水平分区<br>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。<br>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响<br>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。<br>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I&#x2F;O。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>下面补充一下数据库分片的两种常见方案：<br><strong>客户端代理</strong>： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。<br><strong>中间件代理</strong>： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p></blockquote>\n</li>\n</ol>\n<h2 id=\"7-13-分库分表之后-id-主键如何处理？\"><a href=\"#7-13-分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"7.13.分库分表之后,id 主键如何处理？\"></a>7.13.分库分表之后,id 主键如何处理？</h2><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。生成全局 id 有下面这几种方式：<br><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。<br><strong>数据库自增 id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。<br><strong>利用 redis 生成 id</strong> : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。<br><strong>Twitter的snowflake算法</strong> ：Github 地址：<a href=\"https://github.com/twitter-archive/snowflake\">snowflake</a>。<br><strong>美团的Leaf分布式ID生成系统</strong> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<a href=\"https://tech.meituan.com/2017/04/21/mt-leaf.html\">leaf</a> 。</p>\n<h2 id=\"7-14-mysql有关权限的表都有哪几个\"><a href=\"#7-14-mysql有关权限的表都有哪几个\" class=\"headerlink\" title=\"7.14.mysql有关权限的表都有哪几个\"></a>7.14.mysql有关权限的表都有哪几个</h2><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<br><strong>user权限表</strong>：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。<br><strong>db权限表</strong>：记录各个帐号在各个数据库上的操作权限。<br><strong>table_priv权限表</strong>：记录数据表级的操作权限。<br><strong>columns_priv权限表</strong>：记录数据列级的操作权限。<br><strong>host权限表</strong>：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</p>\n<h2 id=\"7-15-mysql有哪些数据类型\"><a href=\"#7-15-mysql有哪些数据类型\" class=\"headerlink\" title=\"7.15.mysql有哪些数据类型\"></a>7.15.mysql有哪些数据类型</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可搭配<a href=\"https://www.alihai5.com/post/MySQL%2FMySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB\">MySQL 常用函数&amp;数据类型</a> 食用。</p></blockquote>\n<h3 id=\"整数类型\"><a href=\"#整数类型\" class=\"headerlink\" title=\"整数类型\"></a>整数类型</h3><p>包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>\n<h3 id=\"实数类型\"><a href=\"#实数类型\" class=\"headerlink\" title=\"实数类型\"></a>实数类型</h3><p>包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>\n<h3 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h3><p>包括VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。<br>使用策略：<br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT&#x2F;BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>\n<h3 id=\"枚举类型（ENUM）\"><a href=\"#枚举类型（ENUM）\" class=\"headerlink\" title=\"枚举类型（ENUM）\"></a>枚举类型（ENUM）</h3><p>把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>\n<h3 id=\"日期和时间类型\"><a href=\"#日期和时间类型\" class=\"headerlink\" title=\"日期和时间类型\"></a>日期和时间类型</h3><p>尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。</p>\n<h2 id=\"7-16-创建索引的三种方式，删除索引\"><a href=\"#7-16-创建索引的三种方式，删除索引\" class=\"headerlink\" title=\"7.16.创建索引的三种方式，删除索引\"></a>7.16.创建索引的三种方式，删除索引</h2><h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><p>第一种方式：在执行CREATE TABLE时创建索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> user_index2 <span class=\"token punctuation\">(</span>\n  id <span class=\"token keyword\">INT</span> <span class=\"token keyword\">auto_increment</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span>\n  first_name <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  last_name <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  id_card <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  information <span class=\"token keyword\">text</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> name <span class=\"token punctuation\">(</span>first_name<span class=\"token punctuation\">,</span> last_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  FULLTEXT <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>information<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>id_card<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第二种方式：使用ALTER TABLE命令去增加索引</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> table_name <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token punctuation\">(</span>column_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。<br>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。<br>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p></blockquote>\n<p>第三种方式：使用CREATE INDEX命令创建</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token keyword\">ON</span> table_name <span class=\"token punctuation\">(</span>column_list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>\n<h3 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h3><p>根据索引名删除普通索引、唯一索引、全文索引： alter table 表名 drop KEY 索引名</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">alter</span> <span class=\"token keyword\">table</span> user_index <span class=\"token keyword\">drop</span> <span class=\"token keyword\">KEY</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">alter</span> <span class=\"token keyword\">table</span> user_index <span class=\"token keyword\">drop</span> <span class=\"token keyword\">KEY</span> id_card<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">alter</span> <span class=\"token keyword\">table</span> user_index <span class=\"token keyword\">drop</span> <span class=\"token keyword\">KEY</span> information<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>删除主键索引： alter table 表名 drop primary key （因为主键只有一个）。这里值得注意的是，<br>如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token punctuation\">[</span>SQLjalter <span class=\"token keyword\">table</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">index</span> <span class=\"token keyword\">drop</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span>\n<span class=\"token punctuation\">[</span>Err<span class=\"token punctuation\">]</span> <span class=\"token number\">1075</span> Incorrect <span class=\"token keyword\">table</span> definition<span class=\"token punctuation\">;</span> there can be only one auto <span class=\"token keyword\">column</span> <span class=\"token operator\">and</span> it must be defined <span class=\"token keyword\">as</span> a <span class=\"token keyword\">key</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>需要取消自增长再行删除：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">alter</span> <span class=\"token keyword\">table</span> user_index\n<span class=\"token comment\">-- 重新定义字段</span>\n<span class=\"token keyword\">MODIFY</span> id <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">drop</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>\n<h1 id=\"八、Redis篇\"><a href=\"#八、Redis篇\" class=\"headerlink\" title=\"八、Redis篇\"></a>八、Redis篇</h1><h2 id=\"8-1-Redis持久化机制\"><a href=\"#8-1-Redis持久化机制\" class=\"headerlink\" title=\"8.1.Redis持久化机制\"></a>8.1.Redis持久化机制</h2><p>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br><strong>实现</strong>：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。<br><strong>RDB</strong>：Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br><strong>AOF</strong>：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。<br>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>\n<h2 id=\"8-2-缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题\"><a href=\"#8-2-缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题\" class=\"headerlink\" title=\"8.2.缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题\"></a>8.2.缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br><strong>解决方案</strong>：大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>缓存穿透是指用户<strong>查询数据，在数据库没有，自然在缓存中也不会有</strong>。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br><strong>解决方案</strong>：最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。</p>\n<h3 id=\"缓存预热\"><a href=\"#缓存预热\" class=\"headerlink\" title=\"缓存预热\"></a>缓存预热</h3><p>缓存预热这个应该是一个比较常见的概念，就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>解决方案：</p>\n<ol>\n<li>直接写个缓存刷新页面，上线时手工操作下；</li>\n<li>数据量不大，可以在项目启动的时候自动进行加载；</li>\n<li>定时刷新缓存；</li>\n</ol>\n<h3 id=\"缓存更新\"><a href=\"#缓存更新\" class=\"headerlink\" title=\"缓存更新\"></a>缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>\n<ol>\n<li>定时去清理过期的缓存；</li>\n<li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li>\n</ol>\n<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>\n<h3 id=\"缓存降级\"><a href=\"#缓存降级\" class=\"headerlink\" title=\"缓存降级\"></a>缓存降级</h3><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<strong>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）</strong>。<br>以参考日志级别设置预案：</p>\n<ol>\n<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>\n<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>\n<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>\n<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>\n</ol>\n<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>\n<h2 id=\"8-3-热点数据和冷数据是什么\"><a href=\"#8-3-热点数据和冷数据是什么\" class=\"headerlink\" title=\"8.3.热点数据和冷数据是什么\"></a>8.3.热点数据和冷数据是什么</h2><p>所谓热点数据就是经常被大量访问的数据<br>所谓冷数据就是频繁被修改的数据或者访问次数少之又少的数据</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>经常被访问的数据可以直接进行缓存，这样做可以避免高并发情况下大量请求访问数据库，造成数据库压力瞬间增大，只有数据在更新前至少被读取两次的才进行缓存，对于频繁被更改并且频繁被访问的数据也可以进行缓存，减少数据库的压力（点赞数、分享数、收藏数）。</p></blockquote>\n<h2 id=\"8-4-Memcache与Redis的区别都有哪些？\"><a href=\"#8-4-Memcache与Redis的区别都有哪些？\" class=\"headerlink\" title=\"8.4.Memcache与Redis的区别都有哪些？\"></a>8.4.Memcache与Redis的区别都有哪些？</h2><ol>\n<li>存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据</li>\n<li>数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储</li>\n<li>使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>\n<li>value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</li>\n<li>redis的速度比memcached快很多</li>\n<li>Redis支持数据的备份，即master-slave模式的数据备份</li>\n</ol>\n<h2 id=\"8-5-单线程的redis为什么这么快\"><a href=\"#8-5-单线程的redis为什么这么快\" class=\"headerlink\" title=\"8.5.单线程的redis为什么这么快\"></a>8.5.单线程的redis为什么这么快</h2><ol>\n<li>纯内存操作</li>\n<li>单线程操作，避免了频繁的上下文切换</li>\n<li>采用了非阻塞I&#x2F;O多路复用机制</li>\n</ol>\n<h2 id=\"8-6-redis的数据类型，以及每种数据类型的使用场景\"><a href=\"#8-6-redis的数据类型，以及每种数据类型的使用场景\" class=\"headerlink\" title=\"8.6.redis的数据类型，以及每种数据类型的使用场景\"></a>8.6.redis的数据类型，以及每种数据类型的使用场景</h2><p>回答：一共五种</p>\n<ol>\n<li>String<br>这个其实没啥好说的，最常规的set&#x2F;get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存</li>\n<li>hash<br>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</li>\n<li>list<br>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。</li>\n<li>set<br>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li>\n<li>sorted set<br>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。</li>\n</ol>\n<h2 id=\"8-7-redis的过期策略以及内存淘汰机制\"><a href=\"#8-7-redis的过期策略以及内存淘汰机制\" class=\"headerlink\" title=\"8.7.redis的过期策略以及内存淘汰机制\"></a>8.7.redis的过期策略以及内存淘汰机制</h2><p>redis采用的是<strong>定期删除+惰性删除策略</strong>。<br><em>为什么不用定时删除策略?</em><br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。<br>在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.<br><em>定期删除+惰性删除是如何工作的呢?</em><br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br><em>采用定期删除+惰性删除就没其他问题了么?</em><br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在redis.conf中有一行配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">maxmemory-policy volatile-lru<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>该配置就是配内存淘汰策略的<br><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰<br><strong>no-enviction（驱逐）</strong>：禁止驱逐数据，新写入操作会报错</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p></blockquote>\n<h2 id=\"8-8-Redis-为什么是单线程的\"><a href=\"#8-8-Redis-为什么是单线程的\" class=\"headerlink\" title=\"8.8.Redis 为什么是单线程的\"></a>8.8.Redis 为什么是单线程的</h2><p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问。</p>\n<h2 id=\"8-9-Redis-常见性能问题和解决方案？\"><a href=\"#8-9-Redis-常见性能问题和解决方案？\" class=\"headerlink\" title=\"8.9.Redis 常见性能问题和解决方案？\"></a>8.9.Redis 常见性能问题和解决方案？</h2><ol>\n<li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</li>\n<li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li>\n<li>为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内</li>\n<li>尽量避免在压力很大的主库上增加从库</li>\n<li>主从复制不要用图状结构，用单向链表结构更为稳定，即： Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3…</li>\n</ol>\n<h2 id=\"8-10-为什么Redis的操作是原子性的，怎么保证原子性的？\"><a href=\"#8-10-为什么Redis的操作是原子性的，怎么保证原子性的？\" class=\"headerlink\" title=\"8.10.为什么Redis的操作是原子性的，怎么保证原子性的？\"></a>8.10.为什么Redis的操作是原子性的，怎么保证原子性的？</h2><p>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>Redis的操作之所以是原子性的，是因为Redis是单线程的。<br>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>多个命令在并发中也是原子性的吗？<br>不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua&#x3D;&#x3D;的方式实现.</p></blockquote>\n<h2 id=\"8-11-Redis事务\"><a href=\"#8-11-Redis事务\" class=\"headerlink\" title=\"8.11.Redis事务\"></a>8.11.Redis事务</h2><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>\n<ul>\n<li>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li>\n<li>EXEC：执行事务中的所有操作命令。</li>\n<li>DISCARD：取消事务，放弃执行事务块中的所有命令。</li>\n<li>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li>\n<li>UNWATCH：取消WATCH对所有key的监视。</li>\n</ul>\n<h1 id=\"九、SpringCloud篇\"><a href=\"#九、SpringCloud篇\" class=\"headerlink\" title=\"九、SpringCloud篇\"></a>九、SpringCloud篇</h1><h2 id=\"9-1-什么是SpringCloud？\"><a href=\"#9-1-什么是SpringCloud？\" class=\"headerlink\" title=\"9.1.什么是SpringCloud？\"></a>9.1.什么是SpringCloud？</h2><p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p>\n<h2 id=\"9-2-什么是微服务\"><a href=\"#9-2-什么是微服务\" class=\"headerlink\" title=\"9.2.什么是微服务\"></a>9.2.什么是微服务</h2><p>微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分为一组小的服务，每个服务运行在其独立的自己的进程中，服务之间相互协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）,每个服务都围绕着具体的业务进行构建，并且能够被独立的构建在生产环境、类生产环境等。另外，应避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p>\n<h2 id=\"9-3-SpringCloud有什么优势\"><a href=\"#9-3-SpringCloud有什么优势\" class=\"headerlink\" title=\"9.3.SpringCloud有什么优势\"></a>9.3.SpringCloud有什么优势</h2><p>使用 Spring Boot 开发分布式微服务时，我们面临以下问题</p>\n<ol>\n<li>与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</li>\n<li>服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</li>\n<li>冗余-分布式系统中的冗余问题。</li>\n<li>负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</li>\n<li>性能-问题 由于各种运营开销导致的性能问题。</li>\n<li>部署复杂性-Devops 技能的要求。</li>\n</ol>\n<h2 id=\"9-4-什么是服务熔断？什么是服务降级？\"><a href=\"#9-4-什么是服务熔断？什么是服务降级？\" class=\"headerlink\" title=\"9.4.什么是服务熔断？什么是服务降级？\"></a>9.4.什么是服务熔断？什么是服务降级？</h2><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。<br>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，好歹可用，比直接挂掉强。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Hystrix相关注解<br>@EnableHystrix：开启熔断<br>@HystrixCommand(fallbackMethod&#x3D;”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</p></blockquote>\n<h2 id=\"9-5-ureka和zookeeper都可以提供服务注册与发现的功能，有何区别？\"><a href=\"#9-5-ureka和zookeeper都可以提供服务注册与发现的功能，有何区别？\" class=\"headerlink\" title=\"9.5.ureka和zookeeper都可以提供服务注册与发现的功能，有何区别？\"></a>9.5.ureka和zookeeper都可以提供服务注册与发现的功能，有何区别？</h2><p><strong>Zookeeper保证了CP（C：一致性，P：分区容错性），Eureka保证了AP（A：高可用）</strong></p>\n<ol>\n<li>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。</li>\n<li>Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况：<ol>\n<li>Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。</li>\n<li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）</li>\n<li>当网络稳定时，当前实例新的注册信息会被同步到其他节点。</li>\n</ol>\n</li>\n</ol>\n<p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper那样使整个微服务瘫痪。</p>\n<h2 id=\"9-6-SpringBoot和SpringCloud的区别？\"><a href=\"#9-6-SpringBoot和SpringCloud的区别？\" class=\"headerlink\" title=\"9.6.SpringBoot和SpringCloud的区别？\"></a>9.6.SpringBoot和SpringCloud的区别？</h2><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务<br>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系.<br><strong>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</strong></p>\n<h2 id=\"9-7-负载平衡的意义什么？\"><a href=\"#9-7-负载平衡的意义什么？\" class=\"headerlink\" title=\"9.7.负载平衡的意义什么？\"></a>9.7.负载平衡的意义什么？</h2><p>负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>\n<h2 id=\"9-8-什么是Hystrix？它如何实现容错？\"><a href=\"#9-8-什么是Hystrix？它如何实现容错？\" class=\"headerlink\" title=\"9.8.什么是Hystrix？它如何实现容错？\"></a>9.8.什么是Hystrix？它如何实现容错？</h2><p>Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。<br>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p>\n<h2 id=\"9-9-什么是Hystrix断路器？我们需要它吗？\"><a href=\"#9-9-什么是Hystrix断路器？我们需要它吗？\" class=\"headerlink\" title=\"9.9.什么是Hystrix断路器？我们需要它吗？\"></a>9.9.什么是Hystrix断路器？我们需要它吗？</h2><h3 id=\"断路器-amp-amp-hystrix简介\"><a href=\"#断路器-amp-amp-hystrix简介\" class=\"headerlink\" title=\"断路器&amp;&amp;hystrix简介\"></a>断路器&amp;&amp;hystrix简介</h3><p>断路器代理了服务调用方对提供方的请求。监控最近请求的失败和超时次数，在下游服务因为过载或者故障无法提供响应时，断路器中请求失败率会大大提升，超过一定阈值后，断路器会打开，切断服务调用方和提供方的联系，此时调用者会执行失败逻辑或者直接返回异常。同时断路器还有检测恢复机制，允许服务调用者尝试调用服务提供者以检测它是否恢复正常，若恢复正常则关闭断路器，恢复正常调用。<br><em>断路器的三态</em><br><strong>关闭状态</strong>：程序正常运行时，大多数都处于此状态，服务调用者正常访问服务提供者。断路器会统计周期时间内的请求总次数和失败数的比例。<br><strong>打开状态</strong>：最近失败频率超过了预设的阈值以后，断路器进入打开状态，服务调用者对服务提供者的调用失效，服务调用进入失败逻辑或者返回异常。<br><strong>半开状态</strong>：断路器在进入打开状态时候会启动一个超时定时器，在定时器到达时，它会进入到半开状态，此时执行“恢复检测机制”，即调用者尝试对服务提供者发起少量调用请求。如果这些请求都成功执行，那么断路器就认为服务提供者已恢复正常，断路器则关闭，失败计数器复位。如果这些请求失败，断路器返回到打开状态，并重新启动超时定时器，重新进行检测恢复。<br><em>hystrix</em><br>hystrix是一个延迟和容错的库。作用于隔离三方系统，服务，第三方库之间的调用，防止级联故障。并且在分布式系统中实现故障出现后的复原能力。git地址：<a href=\"https://pkg.go.dev/github.com/afex/hystrix-go/hystrix\">hystrix</a></p>\n<h3 id=\"hystrix执行流程\"><a href=\"#hystrix执行流程\" class=\"headerlink\" title=\"hystrix执行流程\"></a>hystrix执行流程</h3><p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301221503975.png\"></p>\n<h2 id=\"9-10-说说-RPC-的实现原理\"><a href=\"#9-10-说说-RPC-的实现原理\" class=\"headerlink\" title=\"9.10.说说 RPC 的实现原理\"></a>9.10.说说 RPC 的实现原理</h2><p>RPC（Remote Procedure Call）：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。<br>RPC 是一种技术思想而非一种规范或协议，常见 RPC 技术和框架有：</p>\n<ul>\n<li>应用级的服务框架：阿里的 Dubbo&#x2F;Dubbox、Google gRPC、Spring Boot&#x2F;Spring Cloud。</li>\n<li>远程通信协议：RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)。</li>\n<li>通信框架：MINA 和 Netty。</li>\n</ul>\n<p>目前流行的开源 RPC 框架还是比较多的，有阿里巴巴的 Dubbo、Facebook 的 Thrift、Google 的 gRPC、Twitter 的 Finagle 等。<br>下面重点介绍三种：</p>\n<ul>\n<li>gRPC：是 Google 公布的开源软件，基于最新的 HTTP 2.0 协议，并支持常见的众多编程语言。RPC 框架是基于 HTTP 协议实现的，底层使用到了 Netty 框架的支持。</li>\n<li>Thrift：是 Facebook 的开源 RPC 框架，主要是一个跨语言的服务开发框架。 用户只要在其之上进行二次开发就行，应用对于底层的 RPC 通讯等都是透明的。不过这个对于用户来说需要学习特定领域语言这个特性，还是有一定成本的。</li>\n<li>Dubbo：是阿里集团开源的一个极为出名的 RPC 框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是极其鲜明的特色。</li>\n</ul>\n<p>完整的 RPC 框架<br>在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202301221503867.png\"></p>\n<p><strong>基础汇总篇完结于2023年01月22日15:10:37，后续开始整理进阶专题篇</strong></p>\n","text":" 2023年1月份最新基础汇总篇，Java开发技术栈知识点都有涉及，主要面向1-2年修为的浪浪山小妖，温故而知新旅游前读这一篇就够了 一、基础篇 基础篇可搭配Java 技术栈（基础篇） 食用。 1.1.Java语言有哪些特点 简单易学、有丰富的类库 面向对象（Java最重要的特性...","link":"","photos":[],"count_time":{"symbolsCount":"77k","symbolsTime":"1:10"},"categories":[{"name":"浪浪山打工人","slug":"浪浪山打工人","count":2,"path":"api/categories/浪浪山打工人.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":4,"path":"api/tags/JAVA.json"},{"name":"Java基础","slug":"Java基础","count":3,"path":"api/tags/Java基础.json"},{"name":"Java面试题","slug":"Java面试题","count":2,"path":"api/tags/Java面试题.json"},{"name":"2023汇总篇","slug":"2023汇总篇","count":1,"path":"api/tags/2023汇总篇.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87\"><span class=\"toc-text\">一、基础篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-Java%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.1.Java语言有哪些特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.2.面向对象和面向过程的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E5%B0%81%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">1.3.八种基本数据类型的大小，以及他们的封装类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">1.4.标识符的命名规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-instanceof-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.5.instanceof 关键字的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-Java%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1\"><span class=\"toc-text\">1.6.Java自动装箱与拆箱</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-7-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.7.重载和重写的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99-Override\"><span class=\"toc-text\">重写(Override)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">重写总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89\"><span class=\"toc-text\">重载（Overload）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">重载总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-8-equals%E4%B8%8E-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.8.equals与&#x3D;&#x3D;的区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#x3D-x3D\"><span class=\"toc-text\">&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#equals\"><span class=\"toc-text\">equals</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-9-Hashcode%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.9.Hashcode的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-10-String%E3%80%81String-StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.10.String、String StringBuffer 和 StringBuilder 的区别是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-11-ArrayList%E5%92%8ClinkedList%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.11.ArrayList和linkedList的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-12-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.12.HashMap和HashTable的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-13-Collection%E5%8C%85%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%8ECollections%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.13.Collection包结构，与Collections的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-14-Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%BA%E5%BC%B1%E8%BD%AF%E8%99%9A\"><span class=\"toc-text\">1.14. Java的四种引用，强弱软虚</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">强引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">软引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%B1%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">弱引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">虚引用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-15-%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.15.泛型常用特点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-16-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">1.16.Java创建对象有几种方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-17-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode\"><span class=\"toc-text\">1.17.有没有可能两个不相等的对象有相同的hashcode</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-18-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.18.深拷贝和浅拷贝的区别是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-19-final%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.19.final有哪些用法?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-20-static%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.20.static都有哪些用法?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-21-3-0-1-x3D-x3D-0-3%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.21.3*0.1&#x3D;&#x3D;0.3返回值是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-22-a-x3D-a-b%E4%B8%8Ea-x3D-b%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97\"><span class=\"toc-text\">1.22.a&#x3D;a+b与a+&#x3D;b有什么区别吗?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-23-try-catch-finally%EF%BC%8Ctry%E9%87%8C%E6%9C%89return%EF%BC%8Cfinally%E8%BF%98%E6%89%A7%E8%A1%8C%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.23.try catch finally，try里有return，finally还执行么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-24-Excption%E4%B8%8EError%E5%8C%85%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.24.Excption与Error包结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">运行时异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A2%AB%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">被检查异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">错误</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-25-OOM%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%8CSOF%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5\"><span class=\"toc-text\">1.25.OOM你遇到过哪些情况，SOF你遇到过哪些情况</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OutOfMemoryError%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">OutOfMemoryError异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">虚拟机栈和本地方法栈溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">运行时常量池溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">方法区溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SOF%EF%BC%88%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BAStackOverflow%EF%BC%89\"><span class=\"toc-text\">SOF（堆栈溢出StackOverflow）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-26-%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%82%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-27-%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9F%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%9A%84\"><span class=\"toc-text\">1.27.线程有哪些基本状态？这些状态是如何定义的?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-28-Java-%E4%B8%AD-IO-%E6%B5%81\"><span class=\"toc-text\">1.28.Java 中 IO 流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-29-java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.29.java反射的作用于原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F\"><span class=\"toc-text\">什么是反射？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">哪里会用到反射机制？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">反射的实现方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0Java%E5%8F%8D%E5%B0%84%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">实现Java反射的类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">反射机制的优缺点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">缺点</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-30-%E8%AF%B4%E8%AF%B4List-Set-Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">1.30.说说List,Set,Map三者的区别？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81JVM%E7%AF%87\"><span class=\"toc-text\">二、JVM篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">2.1.知识点汇总</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">2.2.知识点详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">JVM内存模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><span class=\"toc-text\">本地方法栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">程序计数器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">方法区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVM-%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">JVM 内存可见性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD\"><span class=\"toc-text\">2.3.类加载与卸载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">类加载过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">类加载时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">类加载器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">类加载机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">回收算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#G1%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">G1算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ZGC%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">ZGC算法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.4.简述一下JVM的内存模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA\"><span class=\"toc-text\">线程私有区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-1\"><span class=\"toc-text\">程序计数器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">虚拟机栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-1\"><span class=\"toc-text\">本地方法栈</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA\"><span class=\"toc-text\">线程共享区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA-1\"><span class=\"toc-text\">方法区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86-1\"><span class=\"toc-text\">堆</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2.5.堆和栈的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91FullGC\"><span class=\"toc-text\">2.6.什么时候会触发FullGC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-7-%E4%BB%80%E4%B9%88%E6%98%AFJava%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Java%E8%A2%AB%E7%A7%B0%E4%BD%9C%E6%98%AF%E2%80%9C%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%9D%EF%BC%9F\"><span class=\"toc-text\">2.7.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-8-Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.8.Java内存结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-9-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">2.9.对象分配规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-10-Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">2.10.Java对象创建过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-11-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">2.11.类的生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-12-%E7%AE%80%E8%BF%B0Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2.12.简述Java的对象结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-13-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F\"><span class=\"toc-text\">2.13.如何判断对象可以被回收？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-14-JVM%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">2.14.JVM的永久代中会发生垃圾回收么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-15-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.15.垃圾收集算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-16-%E8%B0%83%E4%BC%98%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">2.16.调优命令有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-17-%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">2.17.调优工具</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-18-Minor-GC%E4%B8%8EFull-GC%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%EF%BC%9F\"><span class=\"toc-text\">2.18.Minor GC与Full GC分别在什么时候发生？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-19-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9BJVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">2.19.你知道哪些JVM性能调优</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-20-%E7%AE%80%E8%BF%B0Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.20.简述Java垃圾回收机制?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-21-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">2.21.什么是类加载器，类加载器有哪些?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-22-%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87OutOfMemory%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F%E5%A4%84%E7%90%86-%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B6%E8%8E%B7%EF%BC%9F\"><span class=\"toc-text\">2.22.你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理 过程中有哪些收获？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-23-JDK-1-8%E4%B9%8B%E5%90%8EPerm-Space%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8A%A8-MetaSpace%E2%BC%A4%E2%BC%A9%E9%BB%98%E8%AE%A4%E6%98%AF%E2%BD%86%E9%99%90%E7%9A%84%E4%B9%88-%E8%BF%98%E6%98%AF%E4%BD%A0%E4%BB%AC%E4%BC%9A%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E2%BD%85%E5%BC%8F%E6%9D%A5%E6%8C%87%E5%AE%9A%E2%BC%A4%E2%BC%A9\"><span class=\"toc-text\">2.23.JDK 1.8之后Perm Space有哪些变动? MetaSpace⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B-amp-%E5%B9%B6%E5%8F%91%E7%AF%87\"><span class=\"toc-text\">三、多线程&amp;并发篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.1.Java中实现多线程有几种方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">3.2.如何停止一个正在运行的线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-notify-%E5%92%8CnotifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3.3.notify()和notifyAll()有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-sleep-%E5%92%8Cwait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3.4.sleep()和wait() 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-volatile-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E5%90%97\"><span class=\"toc-text\">3.5.volatile 是什么?可以保证有序性吗?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-Thread-%E7%B1%BB%E4%B8%AD%E7%9A%84start-%E5%92%8C-run-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3.6.Thread 类中的start() 和 run() 方法有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify-%E5%92%8C-notifyAll%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E4%B8%8D%E5%9C%A8thread%E7%B1%BB%E9%87%8C%E9%9D%A2%EF%BC%9F\"><span class=\"toc-text\">3.7.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-8-%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E8%A6%81%E5%9C%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">3.8.为什么wait和notify方法要在同步块中调用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-9-Java%E4%B8%ADinterrupted-%E5%92%8C-isInterruptedd%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3.9.Java中interrupted 和 isInterruptedd方法的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-10-Java%E4%B8%ADsynchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">3.10.Java中synchronized 和 ReentrantLock 有什么不同？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-11-%E6%9C%89%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8BT1-T2-T3-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F\"><span class=\"toc-text\">3.11.有三个线程T1,T2,T3,如何保证顺序执行？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-12-SynchronizedMap%E5%92%8CConcurrentHashMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3.12.SynchronizedMap和ConcurrentHashMap有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-13-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">3.13.什么是线程安全</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-14-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">3.14.Thread类中的yield方法有什么作用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-15-Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsubmit-%E5%92%8C-execute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">3.15.Java线程池中submit() 和 execute()方法有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-16-%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3\"><span class=\"toc-text\">3.16.说一说自己对于 synchronized 关键字的了解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-17-%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3.17.说说自己是怎么使用 synchronized 关键字，在项目中用到了吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-18-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9FVector%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">3.18.什么是线程安全？Vector是一个线程安全类吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-19-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">3.19.volatile关键字的作用？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-20-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">3.20.常用的线程池有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-21-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">3.21.简述一下你对线程池的理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-22-%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%90%97\"><span class=\"toc-text\">3.22.说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-23-%E8%AE%B2%E4%B8%80%E4%B8%8B-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">3.23.讲一下 synchronized 关键字的底层原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#synchronized-%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">synchronized 同步语句块的情况</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#synchronized-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">synchronized 修饰方法的的情况</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-24-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F\"><span class=\"toc-text\">3.24.为什么要用线程池？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-25-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3.25.实现Runnable接口和Callable接口的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-26-%E6%89%A7%E8%A1%8Cexecute-%E6%96%B9%E6%B3%95%E5%92%8Csubmit-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">3.26.执行execute()方法和submit()方法的区别是什么呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-27-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">3.27.如何创建线程池</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81Spring%E7%AF%87\"><span class=\"toc-text\">四、Spring篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-Spring%E7%9A%84IOC%E5%92%8CAOP%E6%9C%BA%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">4.1.Spring的IOC和AOP机制？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-Spring%E4%B8%ADAutowired%E5%92%8CResource%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">4.2.Spring中Autowired和Resource关键字的区别？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">共同点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">不同点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Autowired\"><span class=\"toc-text\">@Autowired</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Resource\"><span class=\"toc-text\">@Resource</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%90%84%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">4.3.依赖注入的方式有几种，各是什么?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFSpring\"><span class=\"toc-text\">4.4.讲一下什么是Spring</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5-Spring-MVC%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">4.5.Spring MVC流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-6-SpringMVC%E6%80%8E%E4%B9%88%E6%A0%B7%E8%AE%BE%E5%AE%9A%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">4.6.SpringMVC怎么样设定重定向和转发的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-7-SpringMVC%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">4.7.SpringMVC常用的注解有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-8-Spring%E7%9A%84AOP%E7%90%86%E8%A7%A3%EF%BC%9A\"><span class=\"toc-text\">4.8.Spring的AOP理解：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-9-Spring%E7%9A%84IOC%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">4.9.Spring的IOC理解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-10-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bspring-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">4.10.解释一下spring bean的生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-11-%E8%A7%A3%E9%87%8ASpring%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8Dbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%82\"><span class=\"toc-text\">4.11.解释Spring支持的几种bean的作用域。</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-12-Spring%E5%9F%BA%E4%BA%8Exml%E6%B3%A8%E5%85%A5bean%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">4.12. Spring基于xml注入bean的几种方式：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-13-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">4.13.Spring框架中都用到了哪些设计模式？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81MyBatis%E7%AF%87\"><span class=\"toc-text\">五、MyBatis篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E4%BB%80%E4%B9%88%E6%98%AFMyBatis\"><span class=\"toc-text\">5.1.什么是MyBatis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-MyBatis%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">5.2.MyBatis的优点和缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">5.3.#{}和${}的区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-%E5%BD%93%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7-%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E-%EF%BC%9F\"><span class=\"toc-text\">5.4.当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">5.5.Mybatis是如何进行分页的？分页插件的原理是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86sql%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">5.6.Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-7-%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%EF%BC%9F\"><span class=\"toc-text\">5.7.如何执行批量插入？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-8-MyBatis%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">5.8.MyBatis实现一对一有几种方式?具体怎么操作的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-9-Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">5.9.Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-10-Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">5.10.Mybatis的一级、二级缓存:</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81SpringBoot%E7%AF%87\"><span class=\"toc-text\">六、SpringBoot篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-1-%E4%BB%80%E4%B9%88%E6%98%AFSpringBoot%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8SpringBoot\"><span class=\"toc-text\">6.1.什么是SpringBoot？为什么要用SpringBoot</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-2-Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%B1%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">6.2.Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-3-%E8%BF%90%E8%A1%8CSpring-Boot%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">6.3.运行Spring Boot有哪几种方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-4-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E4%B8%AD%E7%9A%84-Starters%EF%BC%9F\"><span class=\"toc-text\">6.4.如何理解 Spring Boot 中的 Starters？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-5-%E5%A6%82%E4%BD%95%E5%9C%A8Spring-Boot%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%90%E8%A1%8C%E4%B8%80%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F\"><span class=\"toc-text\">6.5.如何在Spring Boot启动的时候运行一些特定的代码？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-6-Spring-Boot-%E9%9C%80%E8%A6%81%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">6.6.Spring Boot 需要独立的容器运行吗？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-7-Spring-Boot%E4%B8%AD%E7%9A%84%E7%9B%91%E8%A7%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">6.7. Spring Boot中的监视器是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-8-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Spring-Boot%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">6.8. 如何使用Spring Boot实现异常处理？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-9-%E4%BD%A0%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E4%B8%AD%E7%9A%84-Starters%EF%BC%9F\"><span class=\"toc-text\">6.9.你如何理解 Spring Boot 中的 Starters？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-10-springboot%E5%B8%B8%E7%94%A8%E7%9A%84starter%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">6.10. springboot常用的starter有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-11-SpringBoot-%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">6.11.SpringBoot 实现热部署有哪几种方式？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-12-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%9F\"><span class=\"toc-text\">6.12.如何理解 Spring Boot 配置加载顺序？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-13-Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">6.13.Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-14-%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90-Spring-Boot-%E5%92%8C-ActiveMQ%EF%BC%9F\"><span class=\"toc-text\">6.14.如何集成 Spring Boot 和 ActiveMQ？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-15-%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BDSpring-Boot%E4%B8%8A%E7%9A%84%E6%9B%B4%E6%94%B9%EF%BC%8C%E8%80%8C%E6%97%A0%E9%9C%80%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F\"><span class=\"toc-text\">6.15.如何重新加载Spring Boot上的更改，而无需重新启动服务器？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-16-Spring-Boot%E3%80%81Spring-MVC-%E5%92%8C-Spring-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">6.16.Spring Boot、Spring MVC 和 Spring 有什么区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-17-pring-Boot-%E8%BF%98%E6%8F%90%E4%BE%9B%E4%BA%86%E5%85%B6%E5%AE%83%E7%9A%84%E5%93%AA%E4%BA%9B-Starter-Project-Options%EF%BC%9F\"><span class=\"toc-text\">6.17.pring Boot 还提供了其它的哪些 Starter Project Options？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81MySQL%E7%AF%87\"><span class=\"toc-text\">七、MySQL篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">7.1.数据库的三范式是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">7.2.数据库引擎有哪些</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-3-InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">7.3.InnoDB与MyISAM的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">7.4.数据库的事务</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-5-%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">7.5.索引问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-6-SQL%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">7.6.SQL优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-7-%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E8%AF%B4drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">7.7.简单说一说drop、delete与truncate的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-8-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">7.8.什么是视图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-9-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%81%94%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%81%94%E6%8E%A5%EF%BC%9F\"><span class=\"toc-text\">7.9.什么是内联接、左外联接、右外联接？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-10-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">7.10.并发事务带来哪些问题?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-11-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B-MySQL%E7%9A%84%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF\"><span class=\"toc-text\">7.11.事务隔离级别有哪些?MySQL的默认隔离级别是?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-12-%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">7.12.大表如何优化？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E-id-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F\"><span class=\"toc-text\">7.13.分库分表之后,id 主键如何处理？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-14-mysql%E6%9C%89%E5%85%B3%E6%9D%83%E9%99%90%E7%9A%84%E8%A1%A8%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA\"><span class=\"toc-text\">7.14.mysql有关权限的表都有哪几个</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-15-mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">7.15.mysql有哪些数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">整数类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%95%B0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">实数类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">字符串类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%EF%BC%88ENUM%EF%BC%89\"><span class=\"toc-text\">枚举类型（ENUM）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">日期和时间类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-16-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">7.16.创建索引的三种方式，删除索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">创建索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">删除索引</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81Redis%E7%AF%87\"><span class=\"toc-text\">八、Redis篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-1-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">8.1.Redis持久化机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%E3%80%81%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7%E7%AD%89%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">8.2.缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9\"><span class=\"toc-text\">缓存雪崩</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\"><span class=\"toc-text\">缓存穿透</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD\"><span class=\"toc-text\">缓存预热</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">缓存更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7\"><span class=\"toc-text\">缓存降级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-3-%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%B7%E6%95%B0%E6%8D%AE%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">8.3.热点数据和冷数据是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-4-Memcache%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">8.4.Memcache与Redis的区别都有哪些？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-5-%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB\"><span class=\"toc-text\">8.5.单线程的redis为什么这么快</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-6-redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%AF%8F%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">8.6.redis的数据类型，以及每种数据类型的使用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-7-redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">8.7.redis的过期策略以及内存淘汰机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-8-Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84\"><span class=\"toc-text\">8.8.Redis 为什么是单线程的</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-9-Redis-%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F\"><span class=\"toc-text\">8.9.Redis 常见性能问题和解决方案？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-10-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E7%9A%84%E6%93%8D%E4%BD%9C%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">8.10.为什么Redis的操作是原子性的，怎么保证原子性的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-11-Redis%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">8.11.Redis事务</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81SpringCloud%E7%AF%87\"><span class=\"toc-text\">九、SpringCloud篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-1-%E4%BB%80%E4%B9%88%E6%98%AFSpringCloud%EF%BC%9F\"><span class=\"toc-text\">9.1.什么是SpringCloud？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">9.2.什么是微服务</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-3-SpringCloud%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">9.3.SpringCloud有什么优势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%EF%BC%9F\"><span class=\"toc-text\">9.4.什么是服务熔断？什么是服务降级？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-5-ureka%E5%92%8Czookeeper%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">9.5.ureka和zookeeper都可以提供服务注册与发现的功能，有何区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-6-SpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">9.6.SpringBoot和SpringCloud的区别？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-7-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%84%8F%E4%B9%89%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">9.7.负载平衡的意义什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-8-%E4%BB%80%E4%B9%88%E6%98%AFHystrix%EF%BC%9F%E5%AE%83%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%B9%E9%94%99%EF%BC%9F\"><span class=\"toc-text\">9.8.什么是Hystrix？它如何实现容错？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-9-%E4%BB%80%E4%B9%88%E6%98%AFHystrix%E6%96%AD%E8%B7%AF%E5%99%A8%EF%BC%9F%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%AE%83%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">9.9.什么是Hystrix断路器？我们需要它吗？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%AD%E8%B7%AF%E5%99%A8-amp-amp-hystrix%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">断路器&amp;&amp;hystrix简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hystrix%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">hystrix执行流程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-10-%E8%AF%B4%E8%AF%B4-RPC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">9.10.说说 RPC 的实现原理</span></a></li></ol></li></ol>","author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> 浪浪山打工人 <br /> @ <b>TG：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Druid监控导致的内存溢出问题定位处理","uid":"9736882d32005a945dbd1b55fb5920ee","slug":"Java/Druid监控导致的内存溢出问题定位处理","date":"2018-08-06T06:03:15.000Z","updated":"2023-01-17T07:32:06.801Z","comments":true,"path":"api/articles/Java/Druid监控导致的内存溢出问题定位处理.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/jks.jpg","text":"0、起因 一台部署于商户私有云中的应用频繁宕机，经查为 OOM，周期大约一周一次，较规律，所谓千里之堤毁于蚁穴，初步怀疑是轻微的内存泄漏不断积累导致的内存溢出，所以再次宕机出现时果断 dump 内存镜像开始分析 1、内存溢出原理 常见内存溢出： 相信通过写 java 程序讨生活的...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":7,"path":"api/categories/JAVA.json"}],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"OOM","slug":"OOM","count":2,"path":"api/tags/OOM.json"},{"name":"Druid","slug":"Druid","count":1,"path":"api/tags/Druid.json"}],"author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> 浪浪山打工人 <br /> @ <b>TG：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"SpringBoot集成TrueLicense实现授权管理","uid":"b778d1ad8e59c9ee0ece8d1989b81254","slug":"Java/SpringBoot集成TrueLicense实现授权管理","date":"2022-12-31T06:03:15.000Z","updated":"2023-01-09T08:19:07.717Z","comments":true,"path":"api/articles/Java/SpringBoot集成TrueLicense实现授权管理.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/ktln.jpg","text":"前言之前做低代码平台，为了保护平台知识产权，需要对低代码平台增加授权管理功能。功能已经实现好久了，最近梳理总结。所谓授权（License）就是对软件使用时间及使用范围进行管控，初步想法是校验部署机器特征码并添加时间范围校验，调研许久发现TrueLicense方案比较成熟，SO 安...","link":"","photos":[],"count_time":{"symbolsCount":"69k","symbolsTime":"1:03"},"categories":[{"name":"JAVA","slug":"JAVA","count":7,"path":"api/categories/JAVA.json"}],"tags":[{"name":"JAVA","slug":"JAVA","count":4,"path":"api/tags/JAVA.json"},{"name":"TrueLicense","slug":"TrueLicense","count":1,"path":"api/tags/TrueLicense.json"},{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"},{"name":"License","slug":"License","count":1,"path":"api/tags/License.json"}],"author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> 浪浪山打工人 <br /> @ <b>TG：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}