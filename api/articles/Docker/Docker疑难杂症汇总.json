{"title":"Docker 疑难杂症汇总","uid":"ab7fec85f604492a9899cdf945faa570","slug":"Docker/Docker疑难杂症汇总","date":"2020-06-23T05:32:16.000Z","updated":"2022-12-29T06:15:41.334Z","comments":true,"path":"api/articles/Docker/Docker疑难杂症汇总.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/lion.jpg","content":"<h2 id=\"1-Docker-迁移存储目录\"><a href=\"#1-Docker-迁移存储目录\" class=\"headerlink\" title=\"1. Docker 迁移存储目录\"></a>1. Docker 迁移存储目录</h2><p><strong>默认情况系统会将 Docker 容器存放在 &#x2F;var&#x2F;lib&#x2F;docker 目录下</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 今天通过监控系统，发现公司其中一台服务器的磁盘快慢，随即上去看了下，发现 &#x2F;var&#x2F;lib&#x2F;docker 这个目录特别大。由上述原因，我们都知道，在 &#x2F;var&#x2F;lib&#x2F;docker 中存储的都是相关于容器的存储，所以也不能随便的将其删除掉。</p>\n</li>\n<li><p>那就准备迁移 docker 的存储目录吧，或者对 &#x2F;var 设备进行扩容来达到相同的目的。更多关于 dockerd 的详细参数，请点击查看 <a href=\"https://docs.docker.com/engine/reference/commandline/dockerd/\">官方文档</a> 地址。</p>\n</li>\n<li><p>但是需要注意的一点就是，尽量不要用软链， 因为一些 docker 容器编排系统不支持这样做，比如我们所熟知的 k8s 就在内。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 发现容器启动不了了 </span>\nERROR：cannot  create temporary directory<span class=\"token operator\">!</span> \n<span class=\"token comment\"># 查看系统存储情况 </span>\n$ <span class=\"token function\">du</span> <span class=\"token parameter variable\">-h</span> --max-depth<span class=\"token operator\">=</span><span class=\"token number\">1</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法 1] 添加软链接</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 1.停止docker服务 </span>\n$ <span class=\"token function\">sudo</span> systemctl stop <span class=\"token function\">docker</span> \n<span class=\"token comment\"># 2.开始迁移目录 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> /var/lib/docker /data/\n<span class=\"token comment\"># 3.添加软链接 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">ln</span> <span class=\"token parameter variable\">-s</span> /data/docker /var/lib/docker \n<span class=\"token comment\"># 4.启动docker服务 </span>\n$ <span class=\"token function\">sudo</span> systemctl start <span class=\"token function\">docker</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法 2] 改动 docker 配置文件</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># [方式一] 改动docker启动配置文件 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /lib/systemd/system/docker.service <span class=\"token assign-left variable\">ExecStart</span><span class=\"token operator\">=</span>/usr/bin/dockerd <span class=\"token parameter variable\">--graph</span><span class=\"token operator\">=</span>/data/docker/ \n<span class=\"token comment\"># [方式二] 改动docker启动配置文件 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /etc/docker/daemon.json <span class=\"token punctuation\">&#123;</span>     <span class=\"token string\">\"live-restore\"</span><span class=\"token builtin class-name\">:</span> true,     <span class=\"token string\">\"graph\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"/data/docker/\"</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#125;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[操作注意事项]</strong> 在迁移 docker 目录的时候注意使用的命令，要么使用 mv 命令直接移动，要么使用 cp 命令复制文件，但是需要注意同时复制文件权限和对应属性，不然在使用的时候可能会存在权限问题。如果容器中，也是使用 root 用户，则不会存在该问题，但是也是需要按照正确的操作来迁移目录。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 使用mv命令 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">mv</span> /var/lib/docker /data/docker \n<span class=\"token comment\"># 使用cp命令 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">cp</span> <span class=\"token parameter variable\">-arv</span> /data/docker /data2/docker <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>因为启动的容器使用的是普通用户运行进程的，且在运行当中需要使用 &#x2F;tmp 目录，结果提示没有权限。在我们导入容器镜像的时候，其实是会将容器启动时需要的各个目录的权限和属性都赋予了。如果我们直接是 cp 命令单纯复制文件内容的话，就会出现属性不一致的情况，同时还会有一定的安全问题。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-Docker-设备空间不足\"><a href=\"#2-Docker-设备空间不足\" class=\"headerlink\" title=\"2. Docker 设备空间不足\"></a>2. Docker 设备空间不足</h2><p><a href=\"https://stackoverflow.com/questions/50140939/increase-docker-container-size-from-default-10gb-on-rhel7/52971594#52971594\">Increase Docker container size from default 10GB on rhel7.</a></p>\n<ul>\n<li><p><strong>[问题起因一]</strong> 容器在导入或者启动的时候，如果提示磁盘空间不足的，那么多半是真的因为物理磁盘空间真的有问题导致的。如下所示，我们可以看到 &#x2F; 分区确实满了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看物理磁盘空间 </span>\n$ <span class=\"token function\">df</span> <span class=\"token parameter variable\">-Th</span> \nFilesystem    Size    Used    Avail    Use%    Mounted on \n/dev/vda1      40G     40G       0G    <span class=\"token number\">100</span>%    / \ntmpfs         <span class=\"token number\">7</span>.8G       <span class=\"token number\">0</span>     <span class=\"token number\">7</span>.8G      <span class=\"token number\">0</span>%    /dev/shm \n/dev/vdb1     493G    289G     179G     <span class=\"token number\">62</span>%    /mnt <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>如果发现真的是物理磁盘空间满了的话，就需要查看到底是什么占据了如此大的空间，导致因为容器没有空间无法启动。其中，docker 自带的命令就是一个很好的能够帮助我们发现问题的工具。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看基本信息 </span>\n<span class=\"token comment\"># 硬件驱动使用的是devicemapper，空间池为docker-252 </span>\n<span class=\"token comment\"># 磁盘可用容量仅剩16.78MB，可用供我们使用 </span>\n$ <span class=\"token function\">docker</span> info \nContainers: <span class=\"token number\">1</span> \nImages: <span class=\"token number\">28</span> \nStorage Driver: devicemapper\n  Pool Name: docker-252:1-787932-pool\n  Pool Blocksize: <span class=\"token number\">65.54</span> kB\n  Backing Filesystem: extfs\n  Data file: /dev/loop0\n  Metadata file: /dev/loop1\n  Data Space Used: <span class=\"token number\">1.225</span> GB\n  Data Space Total: <span class=\"token number\">107.4</span> GB\n  Data Space Available: <span class=\"token number\">16.78</span> MB\n  Metadata Space Used: <span class=\"token number\">2.073</span> MB\n  Metadata Space Total: <span class=\"token number\">2.147</span> GB <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 通过查看信息，我们知道正是因为 docker 可用的磁盘空间不足，所以导致启动的时候没有足够的空间进行加载启动镜像。解决的方法也很简单，第一就是清理无效数据文件释放磁盘空间(<strong>清除日志</strong>)，第二就是修改 docker 数据的存放路径(<strong>大分区</strong>)。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 显示哪些容器目录具有最大的日志文件 </span>\n$ <span class=\"token function\">du</span> <span class=\"token parameter variable\">-d1</span> <span class=\"token parameter variable\">-h</span> /var/lib/docker/containers <span class=\"token operator\">|</span> <span class=\"token function\">sort</span> <span class=\"token parameter variable\">-h</span> \n<span class=\"token comment\"># 清除您选择的容器日志文件的内容 </span>\n$ <span class=\"token function\">cat</span> /dev/null <span class=\"token operator\">></span> /var/lib/docker/containers/container_id/container_log_name <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<ul>\n<li><p><strong>[问题起因二]</strong> 显然我遇到的不是上一种情况，而是在启动容器的时候，容器启动之后不久就显示是 unhealthy 的状态，通过如下日志发现，原来是复制配置文件启动的时候，提示磁盘空间不足。</p>\n</li>\n<li><p>后面发现是因为 CentOS7 的系统使用的 docker 容器默认的创建大小就是 10G 而已，然而我们使用的容器却超过了这个限制，导致无法启动时提示空间不足。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token number\">2019</span>-08-16 <span class=\"token number\">11</span>:11:15,816 INFO spawned: <span class=\"token string\">'app-demo'</span> with pid <span class=\"token number\">835</span> \n<span class=\"token number\">2019</span>-08-16 <span class=\"token number\">11</span>:11:16,268 INFO exited: app <span class=\"token punctuation\">(</span>exit status <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> not expected<span class=\"token punctuation\">)</span> \n<span class=\"token number\">2019</span>-08-16 <span class=\"token number\">11</span>:11:17,270 INFO gave up: app entered FATAL state, too many start retries too quickly \ncp: cannot create regular <span class=\"token function\">file</span> <span class=\"token string\">'/etc/supervisor/conf.d/grpc-app-demo.conf'</span><span class=\"token builtin class-name\">:</span> No space left on device \ncp: cannot create regular <span class=\"token function\">file</span> <span class=\"token string\">'/etc/supervisor/conf.d/grpc-app-demo.conf'</span><span class=\"token builtin class-name\">:</span> No space left on device \ncp: cannot create regular <span class=\"token function\">file</span> <span class=\"token string\">'/etc/supervisor/conf.d/grpc-app-demo.conf'</span><span class=\"token builtin class-name\">:</span> No space left on device \ncp: cannot create regular <span class=\"token function\">file</span> <span class=\"token string\">'/etc/supervisor/conf.d/grpc-app-demo.conf'</span><span class=\"token builtin class-name\">:</span> No space left on device <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法 1] 改动 docker 启动配置文件</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># /etc/docker/daemon.json </span>\n<span class=\"token punctuation\">&#123;</span>     \n  <span class=\"token string\">\"live-restore\"</span><span class=\"token builtin class-name\">:</span> true,     \n  <span class=\"token string\">\"storage-opt\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"dm.basesize=20G\"</span> <span class=\"token punctuation\">]</span> \n<span class=\"token punctuation\">&#125;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法 2] 改动 systemctl 的 docker 启动文件</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 1.stop the docker service </span>\n$ <span class=\"token function\">sudo</span> systemctl stop <span class=\"token function\">docker</span> \n<span class=\"token comment\"># 2.rm exised container </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> /var/lib/docker \n<span class=\"token comment\"># 2.edit your docker service file </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /usr/lib/systemd/system/docker.service \n<span class=\"token comment\"># 3.find the execution line</span>\n <span class=\"token assign-left variable\">ExecStart</span><span class=\"token operator\">=</span>/usr/bin/dockerd \nand change it to: \n<span class=\"token assign-left variable\">ExecStart</span><span class=\"token operator\">=</span>/usr/bin/dockerd --storage-opt <span class=\"token assign-left variable\">dm.basesize</span><span class=\"token operator\">=</span>20G \n<span class=\"token comment\"># 4.start docker service again </span>\n$ <span class=\"token function\">sudo</span> systemctl start <span class=\"token function\">docker</span> \n<span class=\"token comment\"># 5.reload daemon </span>\n$ <span class=\"token function\">sudo</span> systemctl daemon-reload <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<ul>\n<li><p><strong>[问题起因三]</strong> 还有一种情况也会让容器无法启动，并提示磁盘空间不足，但是使用命令查看发现并不是因为物理磁盘真的不足导致的。而是，因为对于分区的 inode 节点数满了导致的。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 报错信息 No space left on device </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 因为 ext3 文件系统使用 inode table 存储 inode 信息，而 xfs 文件系统使用 B+ tree 来进行存储。考虑到性能问题，默认情况下这个 B+ tree 只会使用前 1TB 空间，当这 1TB 空间被写满后，就会导致无法写入 inode 信息，报磁盘空间不足的错误。我们可以在 mount 时，指定 inode64 即可将这个 B+ tree 使用的空间扩展到整个文件系统。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看系统的inode节点使用情况 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">df</span> <span class=\"token parameter variable\">-i</span> \n<span class=\"token comment\"># 尝试重新挂载 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">mount</span> <span class=\"token parameter variable\">-o</span> remount <span class=\"token parameter variable\">-o</span> noatime,nodiratime,inode64,nobarrier /dev/vda1 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[补充知识]</strong> 文件储存在硬盘上，硬盘的最小存储单位叫做 <strong>扇区</strong>(Sector)。每个扇区储存 512 字节(相当于0.5KB)。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个<strong>块</strong>(block)。这种由多个扇区组成的<strong>块</strong>，是文件存取的最小单位。<strong>块</strong>的大小，最常见的是4KB，即连续八个 sector 组成一个 block 块。文件数据都储存在<strong>块</strong>中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做<strong>索引节点</strong>(inode)。每一个文件都有对应的 inode，里面包含了除了文件名以外的所有文件信息。</p>\n</li>\n<li><p>inode 也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是 inode 区(inode table)，存放 inode 所包含的信息。每个 inode 节点的大小，一般是 128 字节或 256 字节。inode 节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个 inode 节点。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 每个节点信息的内容 </span>\n$ <span class=\"token function\">stat</span> check_port_live.sh \n   File: check_port_live.sh\n   Size: <span class=\"token number\">225</span>           Blocks: <span class=\"token number\">8</span>          IO Block: <span class=\"token number\">4096</span>   regular <span class=\"token function\">file</span> \nDevice: 822h/2082d    Inode: <span class=\"token number\">99621663</span>    Links: <span class=\"token number\">1</span> \nAccess: <span class=\"token punctuation\">(</span>0755/-rwxr-xr-x<span class=\"token punctuation\">)</span>  Uid: <span class=\"token punctuation\">(</span> <span class=\"token number\">1006</span>/  escape<span class=\"token punctuation\">)</span>   Gid: <span class=\"token punctuation\">(</span> <span class=\"token number\">1006</span>/  escape<span class=\"token punctuation\">)</span> \nAccess: <span class=\"token number\">2019</span>-07-29 <span class=\"token number\">14</span>:59:59.498076903 +0800 \nModify: <span class=\"token number\">2019</span>-07-29 <span class=\"token number\">14</span>:59:59.498076903 +0800 \nChange: <span class=\"token number\">2019</span>-07-29 <span class=\"token number\">23</span>:20:27.834866649 +0800  \n  Birth: - \n<span class=\"token comment\"># 磁盘的inode使用情况 </span>\n$ <span class=\"token function\">df</span> <span class=\"token parameter variable\">-i</span> Filesystem                 Inodes   IUsed     IFree IUse% Mounted on \nudev                     <span class=\"token number\">16478355</span>     <span class=\"token number\">801</span>  <span class=\"token number\">16477554</span>    <span class=\"token number\">1</span>% /dev \ntmpfs                    <span class=\"token number\">16487639</span>    <span class=\"token number\">2521</span>  <span class=\"token number\">16485118</span>    <span class=\"token number\">1</span>% /run \n/dev/sdc2               <span class=\"token number\">244162560</span> <span class=\"token number\">4788436</span> <span class=\"token number\">239374124</span>    <span class=\"token number\">2</span>% / \ntmpfs                    <span class=\"token number\">16487639</span>       <span class=\"token number\">5</span>  <span class=\"token number\">16487634</span>    <span class=\"token number\">1</span>% /dev/shm <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"3-Docker-缺共享链接库\"><a href=\"#3-Docker-缺共享链接库\" class=\"headerlink\" title=\"3. Docker 缺共享链接库\"></a>3. Docker 缺共享链接库</h2><p><strong>Docker 命令需要对&#x2F;tmp 目录下面有访问权限</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 给系统安装完 compose 之后，查看版本的时候，提示缺少一个名为 libz.so.1 的共享链接库。第一反应就是，是不是系统少安装那个软件包导致的。随即，搜索了一下，将相关的依赖包都给安装了，却还是提示同样的问题。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 提示错误信息 </span>\n$ <span class=\"token function\">docker-compose</span> <span class=\"token parameter variable\">--version</span> \nerror <span class=\"token keyword\">while</span> loading shared libraries: libz.so.1: failed to map segment from shared object: Operation not permitted <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 后来发现，是因为系统中 docker 没有对 &#x2F;tmp 目录的访问权限导致，需要重新将其挂载一次，就可以解决了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 重新挂载 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">mount</span> /tmp <span class=\"token parameter variable\">-o</span> remount,exec <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"4-Docker-容器文件损坏\"><a href=\"#4-Docker-容器文件损坏\" class=\"headerlink\" title=\"4. Docker 容器文件损坏\"></a>4. Docker 容器文件损坏</h2><p><strong>对 dockerd 的配置有可能会影响到系统稳定</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 容器文件损坏，经常会导致容器无法操作。正常的 docker 命令已经无法操控这台容器了，无法关闭、重启、删除。正巧，前天就需要这个的问题，主要的原因是因为重新对 docker 的默认容器进行了重新的分配限制导致的。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 操作容器遇到类似的错误 </span>\nb<span class=\"token string\">'devicemapper: Error running deviceCreate (CreateSnapDeviceRaw) dm_task_run failed'</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 可以通过以下操作将容器删除&#x2F;重建。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 1.关闭docker </span>\n$ <span class=\"token function\">sudo</span> systemctl stop <span class=\"token function\">docker</span> \n<span class=\"token comment\"># 2.删除容器文件 </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> /var/lib/docker/containers\n <span class=\"token comment\"># 3.重新整理容器元数据 </span>\n$ <span class=\"token function\">sudo</span> thin_check /var/lib/docker/devicemapper/devicemapper/metadata \n$ <span class=\"token function\">sudo</span> thin_check --clear-needs-check-flag /var/lib/docker/devicemapper/devicemapper/metadata\n<span class=\"token comment\"># 4.重启docker </span>\n$ <span class=\"token function\">sudo</span> systemctl start <span class=\"token function\">docker</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"5-Docker-容器优雅重启\"><a href=\"#5-Docker-容器优雅重启\" class=\"headerlink\" title=\"5. Docker 容器优雅重启\"></a>5. Docker 容器优雅重启</h2><p><strong>不停止服务器上面运行的容器，重启 dockerd 服务是多么好的一件事</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 默认情况下，当 Docker 守护程序终止时，它会关闭正在运行的容器。从 Docker-ce 1.12 开始，可以在配置文件中添加 live-restore 参数，以便在守护程序变得不可用时容器保持运行。需要注意的是 Windows 平台暂时还是不支持该参数的配置。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># Keep containers alive during daemon downtime </span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /etc/docker/daemon.yaml \n<span class=\"token punctuation\">&#123;</span>  \n <span class=\"token string\">\"live-restore\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token boolean\">true</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token comment\"># 在守护进程停机期间保持容器存活 </span>\n$ <span class=\"token function\">sudo</span> dockerd --live-restore \n<span class=\"token comment\"># 只能使用reload重载 #</span>\n 相当于发送SIGHUP信号量给dockerd守护进程 \n$ <span class=\"token function\">sudo</span> systemctl reload <span class=\"token function\">docker</span> \n<span class=\"token comment\"># 但是对应网络的设置需要restart才能生效 </span>\n$ <span class=\"token function\">sudo</span> systemctl restart <span class=\"token function\">docker</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 可以通过以下操作将容器删除&#x2F;重建。</p>\n</li>\n</ul>\n<p><strong>json</strong></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># /etc/docker/daemon.yaml</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token key atrule\">\"registry-mirrors\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"https://vec0xydj.mirror.aliyuncs.com\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 配置获取官方镜像的仓库地址</span>\n    <span class=\"token key atrule\">\"experimental\"</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 启用实验功能</span>\n    <span class=\"token key atrule\">\"default-runtime\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"nvidia\"</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 容器的默认OCI运行时(默认为runc)</span>\n    <span class=\"token key atrule\">\"live-restore\"</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># 重启dockerd服务的时候容易不终止</span>\n    <span class=\"token key atrule\">\"runtimes\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\"># 配置容器运行时</span>\n        <span class=\"token key atrule\">\"nvidia\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token key atrule\">\"path\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/usr/bin/nvidia-container-runtime\"</span><span class=\"token punctuation\">,</span>\n            <span class=\"token key atrule\">\"runtimeArgs\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token key atrule\">\"default-address-pools\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>  <span class=\"token comment\"># 配置容器使用的子网地址池</span>\n        <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token key atrule\">\"scope\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"local\"</span><span class=\"token punctuation\">,</span>\n            \"base\"<span class=\"token punctuation\">:</span><span class=\"token string\">\"172.17.0.0/12\"</span><span class=\"token punctuation\">,</span>\n            \"size\"<span class=\"token punctuation\">:</span><span class=\"token number\">24</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">vim</span> /etc/docker/daemon.json\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token string\">\"default-address-pools\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token string\">\"base\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"172.240.0.0/16\"</span>,\n      <span class=\"token string\">\"size\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token number\">24</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"6-Docker-容器无法删除\"><a href=\"#6-Docker-容器无法删除\" class=\"headerlink\" title=\"6. Docker 容器无法删除\"></a>6. Docker 容器无法删除</h2><p><strong>找不到对应容器进程是最吓人的</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 今天遇到 docker 容器无法停止&#x2F;终止&#x2F;删除，以为这个容器可能又出现了 dockerd 守护进程托管的情况，但是通过 ps -ef <container id> 无法查到对应的运行进程。哎，后来开始开始查 supervisor 以及 Dockerfile 中的进程，都没有。这种情况的可能原因是容器启动之后，主机因任何原因重新启动并且没有优雅地终止容器。剩下的文件现在阻止你重新生成旧名称的新容器，因为系统认为旧容器仍然存在。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 删除容器</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-f</span> f8e8c3<span class=\"token punctuation\">..</span>\nError response from daemon: Conflict, cannot remove the default name of the container<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 找到 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F; 下的对应容器的文件夹，将其删除，然后重启一下 dockerd 即可。我们会发现，之前无法删除的容器没有了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 删除容器文件</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> /var/lib/docker/containers/f8e8c3<span class=\"token punctuation\">..</span>.65720\n\n<span class=\"token comment\"># 重启服务</span>\n$ <span class=\"token function\">sudo</span> systemctl restart docker.service<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"7-Docker-容器中文异常\"><a href=\"#7-Docker-容器中文异常\" class=\"headerlink\" title=\"7. Docker 容器中文异常\"></a>7. Docker 容器中文异常</h2><p><strong>容器存在问题话，记得优先在官网查询</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 今天登陆之前部署的 MySQL 数据库查询，发现使用 SQL 语句无法查询中文字段，即使直接输入中文都没有办法显示。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看容器支持的字符集</span>\nroot@b18f56aa1e15:<span class=\"token comment\"># locale -a</span>\nC\nC.UTF-8\nPOSIX<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> Docker 部署的 MySQL 系统使用的是 POSIX 字符集。然而 POSIX 字符集是不支持中文的，而 C.UTF-8 是支持中文的只要把系统中的环境 LANG 改为 “C.UTF-8” 格式即可解决问题。同理，在 K8S 进入 pod 不能输入中文也可用此方法解决。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 临时解决</span>\n<span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> some-mysql <span class=\"token function\">env</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">LANG</span></span><span class=\"token operator\">=</span>C.UTF-8 /bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 永久解决</span>\n<span class=\"token function\">docker</span> run <span class=\"token parameter variable\">--name</span> some-mysql <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span>my-secret-pw <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-d</span> mysql:tag --character-set-server<span class=\"token operator\">=</span>utf8mb4 <span class=\"token punctuation\">\\</span>\n    --collation-server<span class=\"token operator\">=</span>utf8mb4_unicode_ci<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"8-Docker-容器网络互通\"><a href=\"#8-Docker-容器网络互通\" class=\"headerlink\" title=\"8. Docker 容器网络互通\"></a>8. Docker 容器网络互通</h2><p><strong>了解 Docker 的四种网络模型</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 在本机部署 Nginx 容器想代理本机启动的 Python 后端服务程序，但是对代码服务如下的配置，结果访问的时候一直提示 502 错误。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 启动Nginx服务</span>\n$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 <span class=\"token environment constant\">$PWD</span>:/etc/nginx nginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">server <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">..</span>.\n    location /api <span class=\"token punctuation\">&#123;</span>\n        proxy_pass http://localhost:8080\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">..</span>.\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 后面发现是因为 nginx.conf 配置文件中的 localhost 配置的有问题，由于 Nginx 是在容器中运行，所以 localhost 为容器中的 localhost，而非本机的 localhost，所以导致无法访问。</p>\n</li>\n<li><p>可以将 nginx.conf 中的 localhost 改为宿主机的 IP 地址，就可以解决 502 的错误。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查询宿主机IP地址 => 172.17.0.1</span>\n$ <span class=\"token function\">ip</span> addr show docker0\ndocker0: <span class=\"token operator\">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class=\"token operator\">></span> mtu <span class=\"token number\">1500</span> qdisc noqueue state UP group default\n    link/ether 02:42:d5:4c:f2:1e brd ff:ff:ff:ff:ff:ff\n    inet <span class=\"token number\">172.17</span>.0.1/16 scope global docker0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::42:d5ff:fe4c:f21e/64 scope <span class=\"token function\">link</span>\n       valid_lft forever preferred_lft forever<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">server <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">..</span>.\n    location /api <span class=\"token punctuation\">&#123;</span>\n        proxy_pass http://172.17.0.1:8080\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">..</span>.\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>当容器使用 host 网络时，容器与宿主共用网络，这样就能在容器中访问宿主机网络，那么容器的 localhost 就是宿主机的 localhost 了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 服务的启动方式有所改变(没有映射出来端口)</span>\n<span class=\"token comment\"># 因为本身与宿主机共用了网络，宿主机暴露端口等同于容器中暴露端口</span>\n$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 <span class=\"token parameter variable\">--network</span><span class=\"token operator\">=</span>host <span class=\"token environment constant\">$PWD</span>:/etc/nginx nginxx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"9-Docker-容器总线错误\"><a href=\"#9-Docker-容器总线错误\" class=\"headerlink\" title=\"9. Docker 容器总线错误\"></a>9. Docker 容器总线错误</h2><p><strong>总线错误看到的时候还是挺吓人了</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 在 docker 容器中运行程序的时候，提示 bus error 错误。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 总线报错</span>\n$ inv app.user_op <span class=\"token parameter variable\">--name</span><span class=\"token operator\">=</span>zhangsan\nBus error <span class=\"token punctuation\">(</span>core dumped<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 原因是在 docker 运行的时候，shm 分区设置太小导致 share memory 不够。不设置 –shm-size 参数时，docker 给容器默认分配的 shm 大小为 64M，导致程序启动时不足。具体原因还是因为安装 pytorch 包导致了，多进程跑任务的时候，docker 容器分配的共享内存太小，导致 torch 要在 tmpfs 上面放模型数据用于子线程的 <a href=\"https://github.com/pytorch/pytorch/issues/2244\">共享不足</a>，就出现报错了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 问题原因</span>\nroot@18<span class=\"token punctuation\">..</span>.35:/opt/app<span class=\"token comment\"># df -TH</span>\nFilesystem     Type     Size  Used Avail Use% Mounted on\noverlay        overlay  <span class=\"token number\">2</span>.0T  221G  <span class=\"token number\">1</span>.4T   <span class=\"token number\">3</span>% /\ntmpfs          tmpfs     68M     <span class=\"token number\">0</span>   68M   <span class=\"token number\">0</span>% /dev\nshm            tmpfs     68M   41k   68M   <span class=\"token number\">1</span>% /dev/shm\n\n<span class=\"token comment\"># 启动docker的时候加上--shm-size参数(单位为b,k,m或g)</span>\n$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">--rm</span> --shm-size<span class=\"token operator\">=</span>200m pytorch/pytorch:latest\n\n<span class=\"token comment\"># 在docker-compose添加对应配置</span>\n$ shm_size: <span class=\"token string\">'2gb'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 还有一种情况就是容器内的磁盘空间不足，也会导致 bus error 这样的报错，所以如果出现了，清除多余文件和目录或者分配一个大的磁盘空间，就可以解决了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 磁盘空间不足</span>\n$ <span class=\"token function\">df</span> <span class=\"token parameter variable\">-Th</span>\nFilesystem     Type     Size  Used Avail Use% Mounted on\noverlay        overlay    1T    1T    0G <span class=\"token number\">100</span>% /\nshm            tmpfs     64M   24K   64M   <span class=\"token number\">1</span>% /dev/shm<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"10-Docker-NFS-挂载报错\"><a href=\"#10-Docker-NFS-挂载报错\" class=\"headerlink\" title=\"10. Docker NFS 挂载报错\"></a>10. Docker NFS 挂载报错</h2><p><strong>NFS 挂载之后容器程序使用异常为内核版本太低导致的</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 我们将服务部署到 openshift 集群中，启动服务调用资源文件的时候，报错信息如下所示。从报错信息中，得知是在 Python3 程序执行 read_file() 读取文件的内容，给文件加锁的时候报错了。但是奇怪的是，本地调试的时候发现服务都是可以正常运行的，文件加锁也是没问题的。后来发现，在 openshift 集群中使用的是 NFS 挂载的共享磁盘。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 报错信息</span>\nTraceback <span class=\"token punctuation\">(</span>most recent call last<span class=\"token punctuation\">)</span>:\n    <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n    File <span class=\"token string\">\"xxx/utils/storage.py\"</span>, line <span class=\"token number\">34</span>, <span class=\"token keyword\">in</span> xxx.utils.storage.LocalStorage.read_file\nOSError: <span class=\"token punctuation\">[</span>Errno <span class=\"token number\">9</span><span class=\"token punctuation\">]</span> Bad <span class=\"token function\">file</span> descriptor<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 文件加锁代码</span>\n<span class=\"token punctuation\">..</span>.\n    with open<span class=\"token punctuation\">(</span>self.mount<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span>, <span class=\"token string\">'rb'</span><span class=\"token punctuation\">)</span> as fileobj:\n        fcntl.flock<span class=\"token punctuation\">(</span>fileobj, fcntl.LOCK_EX<span class=\"token punctuation\">)</span>\n        data <span class=\"token operator\">=</span> fileobj.read<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin class-name\">return</span> data\n<span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 从下面的信息得知，要在 Linux 中使用 flock() 的话，就需要升级内核版本到 2.6.11+ 才行。后来才发现，这实际上是由 RedHat 內核中的一个错误引起的，并在 kernel-3.10.0-693.18.1.el7 版本中得到修复。 所以对于 NFSv3 和 NFSv4 服务而已，就需要升级 Linux 内核版本才能够解决这个问题。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># https://t.codebug.vip/questions-930901.htm</span>\n$ In Linux kernels up to <span class=\"token number\">2.6</span>.11, flock<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> does not lock files over NFS <span class=\"token punctuation\">(</span>i.e.,\nthe scope of locks was limited to the <span class=\"token builtin class-name\">local</span> system<span class=\"token punctuation\">)</span>. <span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span> Since Linux <span class=\"token number\">2.6</span>.12,\nNFS clients support flock<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> locks by emulating them as byte-range locks on the entire file.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"11-Docker-使用默认网段\"><a href=\"#11-Docker-使用默认网段\" class=\"headerlink\" title=\"11. Docker 使用默认网段\"></a>11. Docker 使用默认网段</h2><p><strong>启动的容器网络无法相互通信，很是奇怪！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 我们在使用 Docker 启动服务的时候，发现有时候服务之前可以相互连通，而有时启动的多个服务之前却出现了无法访问的情况。究其原因，发现原来是因为使用的内部私有地址网段不一致导致的。有的服务启动到了 172.17 - 172.31 的网段，有的服务跑到了 192.169.0 - 192.168.224 的网段，这样导致服务启动之后出现无法访问的情况(默认情况下，有下面这个两个网段可供其使用)。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291405111.png\"><br><strong>Docker默认使用网段</strong></p>\n</li>\n<li><p><strong>[解决方法]</strong> 上述问题的处理方式，就是手动指定 Docker 服务的启动网段，二选一就可以了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看docker容器配置</span>\n$ <span class=\"token function\">cat</span> /etc/docker/daemon.json\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token string\">\"registry-mirrors\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"https://vec0xydj.mirror.aliyuncs.com\"</span><span class=\"token punctuation\">]</span>,\n    <span class=\"token string\">\"default-address-pools\"</span>:<span class=\"token punctuation\">[</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"base\"</span><span class=\"token builtin class-name\">:</span><span class=\"token string\">\"172.17.0.0/12\"</span>, <span class=\"token string\">\"size\"</span>:24<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span>,\n    <span class=\"token string\">\"experimental\"</span><span class=\"token builtin class-name\">:</span> true,\n    <span class=\"token string\">\"default-runtime\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"nvidia\"</span>,\n    <span class=\"token string\">\"live-restore\"</span><span class=\"token builtin class-name\">:</span> true,\n    <span class=\"token string\">\"runtimes\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token string\">\"nvidia\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token string\">\"path\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"/usr/bin/nvidia-container-runtime\"</span>,\n            <span class=\"token string\">\"runtimeArgs\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"12-Docker-服务启动串台\"><a href=\"#12-Docker-服务启动串台\" class=\"headerlink\" title=\"12. Docker 服务启动串台\"></a>12. Docker 服务启动串台</h2><p><strong>使用 docker-compose 命令各自启动两组服务，发现服务会串台！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 在两个不同名称的目录目录下面，使用 docker-compose 来启动服务，发现当 A 组服务启动完毕之后，再启动 B 组服务的时候，发现 A 组当中对应的一部分服务又重新启动了一次，这就非常奇怪了！因为这个问题的存在会导致，A 组服务和 B 组服务无法同时启动。之前还以为是工具的 Bug，后来请教了 <strong>“上峰”</strong>，才知道了原因，恍然大悟。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 服务目录结构如下所示</span>\nA: /data1/app/docker-compose.yml\nB: /data2/app/docker-compose.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 发现 A 和 B 两组服务会串台的原因，原来是 docker-compose 会给启动的容器加 label 标签，然后根据这些 label 标签来识别和判断对应的容器服务是由谁启动的、谁来管理的，等等。而这里，我们需要关注的 label 变量是 com.docker.compose.project，其对应的值是使用启动配置文件的目录的最底层子目录名称，即上面的 app 就是对应的值。我们可以发现， A 和 B 两组服务对应的值都是 app，所以启动的时候被认为是同一个，这就出现了上述的问题。如果需要深入了解的话，可以去看对应源代码。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291406483.png\"><br><strong>Docker服务启动串台</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 可以将目录结构调整为如下所示</span>\nA: /data/app1/docker-compose.yml\nB: /data/app2/docker-compose.yml\n\nA: /data1/app-old/docker-compose.yml\nB: /data2/app-new/docker-compose.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>或者使用 docker-compose 命令提供的参数 -p 手动指定标签，来规避该问题的发生。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 指定项目项目名称</span>\n$ <span class=\"token function\">docker-compose</span> <span class=\"token parameter variable\">-f</span> ./docker-compose.yml <span class=\"token parameter variable\">-p</span> app1 up <span class=\"token parameter variable\">-d</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"13-Docker-命令调用报错\"><a href=\"#13-Docker-命令调用报错\" class=\"headerlink\" title=\"13. Docker 命令调用报错\"></a>13. Docker 命令调用报错</h2><p><strong>在编写脚本的时候常常会执行 docker 相关的命令，但是需要注意使用细节！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> CI 更新环境执行了一个脚本，但是脚本执行过程中报错了，如下所示。通过对应的输出信息，可以看到提示说正在执行的设备不是一个 tty。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291406569.png\"><br><strong>Docker命令调用报错</strong></p>\n</li>\n<li><p>随即，查看了脚本发现报错地方是执行了一个 exec 的 docker 命令，大致如下所示。很奇怪的是，手动执行或直接调脚本的时候，怎么都是没有问题的，但是等到 CI 调用的时候怎么都是有问题。后来好好看下，下面这个命令，注意到 -it 这个参数了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 脚本调用docker命令</span>\n<span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> <span class=\"token operator\">&lt;</span>container_name<span class=\"token operator\">></span> psql <span class=\"token parameter variable\">-Upostgres</span> <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>我们可以一起看下 exec 命令的这两个参数，自然就差不多理解了。</p>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>参数</th>\n<th>解释说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>-i&#x2F;-interactive</td>\n<td>即使没有附加也保持 STDIN 打开；如果你需要执行命令则需要开启这个选项</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-t&#x2F;–tty</td>\n<td>分配一个伪终端进行执行；一个连接用户的终端与容器 stdin 和 stdout 的桥梁</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>[解决方法]</strong> docker exec 的参数 -t 是指 Allocate a pseudo-TTY 的意思，而 CI 在执行 job 的时候并不是在 TTY 终端中执行，所以 -t 这个参数会报错。同时在 『<a href=\"https://stackoverflow.com/questions/43099116/error-the-input-device-is-not-a-tty\">stackoverflow</a>』也有人给出原因，可以自行查看。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291407326.png\"><br><strong>Docker命令调用报错</strong></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"14-Docker-定时任务异常\"><a href=\"#14-Docker-定时任务异常\" class=\"headerlink\" title=\"14. Docker 定时任务异常\"></a>14. Docker 定时任务异常</h2><p><strong>在 Crontab 定时任务中也存在 Docker 命令执行异常的情况！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 今天发现了一个问题，就是在备份 Mysql 数据库的时候，使用 docker 容器进行备份，然后使用 Crontab 定时任务来触发备份。但是发现备份的 MySQL 数据库居然是空的，但是手动执行对应命令切是好的，很奇怪。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># Crontab定时任务</span>\n<span class=\"token number\">0</span> */6 * * * <span class=\"token punctuation\">\\</span>\n    <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> <span class=\"token operator\">&lt;</span>container_name<span class=\"token operator\">></span> <span class=\"token function\">sh</span> <span class=\"token parameter variable\">-c</span> <span class=\"token punctuation\">\\</span>\n        <span class=\"token string\">'exec mysqldump --all-databases -uroot -ppassword ......'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 后来发现是因为执行的 docker 命令多个 -i 导致的。因为 Crontab 命令执行的时候，并不是交互式的，所以需要把这个去掉才可以。总结就是，如果你需要回显的话则需要 -t 选项，如果需要交互式会话则需要 -i 选项。</p>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>参数</th>\n<th>解释说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>-i&#x2F;-interactive</td>\n<td>即使没有附加也保持 STDIN 打开；如果你需要执行命令则需要开启这个选项</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-t&#x2F;–tty</td>\n<td>分配一个伪终端进行执行；一个连接用户的终端与容器 stdin 和 stdout 的桥梁</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<hr>\n<h2 id=\"15-Docker-变量使用引号\"><a href=\"#15-Docker-变量使用引号\" class=\"headerlink\" title=\"15. Docker 变量使用引号\"></a>15. Docker 变量使用引号</h2><p><strong>compose 里边环境变量带不带引号的问题！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 使用过 compose 的朋友可能都遇到过，在编写启服务启动配置文件的时候，添加环境变量时到底是使用单引号、双引号还是不使用引号的问题？时间长了，我们可能会将三者混用，认为其效果是一样的。但是后来，发现的坑越来越多，才发现其越来越隐晦。</p>\n</li>\n<li><p>反正我是遇到过很多问题，都是因为添加引号导致的服务启动异常的，后来得出的结论就是一律不使引号。裸奔，体验前所未有的爽快！直到现在看到了 Github 中对应的 <a href=\"https://github.com/docker/compose/issues/2854\">issus</a> 之后，才终于破案了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在Compose中进行引用TEST_VAR变量，无法找到</span>\n<span class=\"token assign-left variable\">TEST_VAR</span><span class=\"token operator\">=</span><span class=\"token string\">\"test\"</span>\n\n<span class=\"token comment\"># 在Compose中进行引用TEST_VAR变量，可以找到</span>\n<span class=\"token assign-left variable\">TEST_VAR</span><span class=\"token operator\">=</span>test\n\n<span class=\"token comment\"># 后来发现docker本身其实已经正确地处理了引号的使用</span>\n<span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">--rm</span> <span class=\"token parameter variable\">-e</span> <span class=\"token assign-left variable\">TEST_VAR</span><span class=\"token operator\">=</span><span class=\"token string\">\"test\"</span> test:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 得到的结论就是，因为 Compose 解析 yaml 配置文件，发现引号也进行了解释包装。这就导致原本的 TEST_VAR&#x3D;”test” 被解析成了 ‘TEST_VAR&#x3D;”test”‘，所以我们在引用的时候就无法获取到对应的值。现在解决方法就是，不管是我们直接在配置文件添加环境变量或者使用 env_file 配置文件，能不使用引号就不适用引号。</p>\n</li>\n<li><p>需要注意的是环境变量配置的是日志格式的话(2022-01-01)，如果使用的是 Python 的 yaml.load 模块的话，会被当做是 date 类型的，这是如果希望保持原样信息的话，可以使用 ‘&#x2F;“ 引起来将其变成字符串格式的。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"16-Docker-删除镜像报错\"><a href=\"#16-Docker-删除镜像报错\" class=\"headerlink\" title=\"16. Docker 删除镜像报错\"></a>16. Docker 删除镜像报错</h2><p><strong>无法删除镜像，归根到底还是有地方用到了！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 清理服器磁盘空间的时候，删除某个镜像的时候提示如下信息。提示需要强制删除，但是发现及时执行了强制删除依旧没有效果。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 删除镜像</span>\n$ <span class=\"token function\">docker</span> rmi 3ccxxxx2e862\nError response from daemon: conflict: unable to delete 3ccxxxx2e862 <span class=\"token punctuation\">(</span>cannot be forced<span class=\"token punctuation\">)</span> - image has dependent child images\n\n<span class=\"token comment\"># 强制删除</span>\n$ dcoker rmi <span class=\"token parameter variable\">-f</span> 3ccxxxx2e862\nError response from daemon: conflict: unable to delete 3ccxxxx2e862 <span class=\"token punctuation\">(</span>cannot be forced<span class=\"token punctuation\">)</span> - image has dependent child images<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 后来才发现，出现这个原因主要是因为 TAG，即存在其他镜像引用了这个镜像。这里我们可以使用如下命令查看对应镜像文件的依赖关系，然后根据对应 TAG 来删除镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查询依赖 - image_id表示镜像名称</span>\n$ <span class=\"token function\">docker</span> image inspect <span class=\"token parameter variable\">--format</span><span class=\"token operator\">=</span><span class=\"token string\">'&#123;&#123;.RepoTags&#125;&#125; &#123;&#123;.Id&#125;&#125; &#123;&#123;.Parent&#125;&#125;'</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> image <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-q</span> <span class=\"token parameter variable\">--filter</span> <span class=\"token assign-left variable\">since</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>image_id<span class=\"token operator\">></span><span class=\"token variable\">)</span></span>\n\n<span class=\"token comment\"># 根据TAG删除镜像</span>\n$ <span class=\"token function\">docker</span> rmi <span class=\"token parameter variable\">-f</span> c565xxxxc87f<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 删除悬空镜像</span>\n$ <span class=\"token function\">docker</span> rmi <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> images <span class=\"token parameter variable\">--filter</span> <span class=\"token string\">\"dangling=true\"</span> <span class=\"token parameter variable\">-q</span> --no-trunc<span class=\"token variable\">)</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"17-Docker-普通用户切换\"><a href=\"#17-Docker-普通用户切换\" class=\"headerlink\" title=\"17. Docker 普通用户切换\"></a>17. Docker 普通用户切换</h2><p><strong>切换 Docker 启动用户的话，还是需要注意下权限问题的！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 我们知道在 Docker 容器里面使用 root 用户的话，是不安全的，很容易出现越权的安全问题，所以一般情况下，我们都会使用普通用户来代替 root 进行服务的启动和管理的。今天给一个服务切换用户的时候，发现 Nginx 服务一直无法启动，提示如下权限问题。因为对应的配置文件也没有配置 var 相关的目录，无奈 🤷‍♀ ！️</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># Nginx报错信息</span>\nnginx: <span class=\"token punctuation\">[</span>alert<span class=\"token punctuation\">]</span> could not <span class=\"token function\">open</span> error log file: open<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"/var/log/nginx/error.log\"</span> failed <span class=\"token punctuation\">(</span><span class=\"token number\">13</span>: Permission denied<span class=\"token punctuation\">)</span>\n<span class=\"token number\">2020</span>/11/12 <span class=\"token number\">15</span>:25:47 <span class=\"token punctuation\">[</span>emerg<span class=\"token punctuation\">]</span> <span class=\"token number\">23</span><span class=\"token comment\">#23: mkdir() \"/var/cache/nginx/client_temp\" failed (13: Permission denied)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 后来发现还是 nginx.conf 配置文件，配置的有问题，需要将 Nginx 服务启动时候需要的文件都配置到一个无权限的目录，即可解决。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">user  www-data<span class=\"token punctuation\">;</span>\nworker_processes  <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\nerror_log  /data/logs/master_error.log warn<span class=\"token punctuation\">;</span>\npid        /dev/shm/nginx.pid<span class=\"token punctuation\">;</span>\n\nevents <span class=\"token punctuation\">&#123;</span>\n    worker_connections  <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\nhttp <span class=\"token punctuation\">&#123;</span>\n    include       /etc/nginx/mime.types<span class=\"token punctuation\">;</span>\n    default_type  application/octet-stream<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">gzip</span>               on<span class=\"token punctuation\">;</span>\n    sendfile           on<span class=\"token punctuation\">;</span>\n    tcp_nopush         on<span class=\"token punctuation\">;</span>\n    keepalive_timeout  <span class=\"token number\">65</span><span class=\"token punctuation\">;</span>\n\n    client_body_temp_path  /tmp/client_body<span class=\"token punctuation\">;</span>\n    fastcgi_temp_path      /tmp/fastcgi_temp<span class=\"token punctuation\">;</span>\n    proxy_temp_path        /tmp/proxy_temp<span class=\"token punctuation\">;</span>\n    scgi_temp_path         /tmp/scgi_temp<span class=\"token punctuation\">;</span>\n    uwsgi_temp_path        /tmp/uwsgi_temp<span class=\"token punctuation\">;</span>\n\n    include /etc/nginx/conf.d/*.conf<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"18-Docker-绑定到-IPv6-上\"><a href=\"#18-Docker-绑定到-IPv6-上\" class=\"headerlink\" title=\"18. Docker 绑定到 IPv6 上\"></a>18. Docker 绑定到 IPv6 上</h2><p><strong>Docker 服务在启动的时候，将地址绑定到 IPv6 地址上面了，提示报错信息！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 物理机器更新了对应补丁之后，重启了服务，导致原本可以正常启动的 docker-compose 服务提示如下报错信息。不清楚是否修改了操作系统的相关配置，还是对应 docker 进行的其他方面的配置，比如修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 或者 docker 的 service 启动文件。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># Docker的报错信息</span>\n<span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">80</span>:80 nginx:alpine succeeds. Previously, this was failing with Error <span class=\"token punctuation\">\\</span>\nstarting userland proxy: listen tcp6 <span class=\"token punctuation\">[</span>::<span class=\"token punctuation\">]</span>:80: socket: address family not supported by protocol.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 通过如上所示的报错信息，可以看到服务的启动端口绑定到了 tcp6 上面了，但是对应的 socket 发现系统本身并不支持。这时，我们一看下对应的操作系统 ipv6 的设置，发现系统禁用了，所有的 ipv6 地址。需要了解的朋友，可以参考 <a href=\"https://github.com/moby/moby/pull/42322\">fix port forwarding with ipv6.disable&#x3D;1</a> 和 <a href=\"https://github.com/moby/moby/issues/42288\">cannot start if ipv6 is disabled on host</a> 这两个 issus 来获取更多信息。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 操作系统配置</span>\n$ <span class=\"token function\">cat</span> /etc/sysctl.conf <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> ipv6\n<span class=\"token assign-left variable\">net.ipv6.conf.all.disable_ipv6</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[方法一]</strong> 最为简单的解决方法，就是在 docker-compose.yml 文件中，手动指定将对应服务的端口绑定到 ipv4 上面，如下所示。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3\"</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> on<span class=\"token punctuation\">-</span>failure\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> app_web\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> app<span class=\"token punctuation\">:</span>latest\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"0.0.0.0:80:80/tcp\"</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"./app_web:/data\"</span>\n    <span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> app_network<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[方法二]</strong> 或者修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件，在配置中，阻止 Docker 错误的将端口映射到 IPv6 上，即可达到同样的效果，且不用再次修改多个服务的启动配置文件了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 修改配置</span>\n$ <span class=\"token function\">vim</span> /etc/docker/daemon.json\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token string\">\"ipv6\"</span><span class=\"token builtin class-name\">:</span> false,\n  <span class=\"token string\">\"fixed-cidr-v6\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"2001:db8:1::/64\"</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 重启服务</span>\n$ systemctl reload <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[方法三]</strong> Docker 默认情况下会同时将端口映射于 IPv4 与 IPv6 两者上，而且有的时候会出现只绑定到了 IPv6，导致服务无法正常访问的情况。现在通用的始终还是 IPv4 地址，因此最简单的做法就是关闭 IPv6 地址。详细的配置，可以参考 <a href=\"https://github.com/moby/moby/issues/2174\">Port redirecting binding to IPv6 but not IPv4 interfaces</a> 这个 issus 地址。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 修改系统配置</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span> <span class=\"token operator\">></span> /proc/sys/net/ipv6/conf/lo/disable_ipv6\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span> <span class=\"token operator\">></span> /proc/sys/net/ipv6/conf/lo/disable_ipv6\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span> <span class=\"token operator\">></span> /proc/sys/net/ipv6/conf/all/disable_ipv6\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'1'</span> <span class=\"token operator\">></span> /proc/sys/net/ipv6/conf/default/disable_ipv6\n\n<span class=\"token comment\"># 重启网络</span>\n$ /etc/init.d/networking restart\n\n<span class=\"token comment\"># 最后检测是否已关闭IPv6</span>\n<span class=\"token function\">ip</span> addr show <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> net6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"19-Docker-容器启动超时\"><a href=\"#19-Docker-容器启动超时\" class=\"headerlink\" title=\"19. Docker 容器启动超时\"></a>19. Docker 容器启动超时</h2><p><strong>Docker 服务在启动的时候，提示超时，被直接终止了！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 使用 docker-compose 启动容器的时候，等待了很久的时候(大约 2-3 分钟左右)，之后提示如下信息。通过阅读信息内容，可以看到是因为超时导致的，提示可以通过设置环境变量，加大超时的时间。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span>\nERROR: <span class=\"token keyword\">for</span> xxx  UnixHTTPConnectionPool<span class=\"token punctuation\">(</span>host<span class=\"token operator\">=</span><span class=\"token string\">'localhost'</span>, <span class=\"token assign-left variable\">port</span><span class=\"token operator\">=</span>None<span class=\"token punctuation\">)</span>: Read timed out. <span class=\"token punctuation\">(</span>read <span class=\"token assign-left variable\">timeout</span><span class=\"token operator\">=</span><span class=\"token number\">70</span><span class=\"token punctuation\">)</span>\nERROR: An HTTP request took too long to complete. Retry with <span class=\"token parameter variable\">--verbose</span> to obtain debug information.\nIf you encounter this issue regularly because of slow network conditions, consider setting COMPOSE_HTTP_TIMEOUT to a higher value <span class=\"token punctuation\">(</span>current value: <span class=\"token number\">60</span><span class=\"token punctuation\">)</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 按照提示设置的环境变量之后，再次启动发现确实可以正常启动了，但是还是能够感觉到有些慢。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /etc/profile\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">COMPOSE_HTTP_TIMEOUT</span><span class=\"token operator\">=</span><span class=\"token number\">500</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">DOCKER_CLIENT_TIMEOUT</span><span class=\"token operator\">=</span><span class=\"token number\">500</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>排除了下启动流程，因为容器启动有映射目录到容器里面且目录大小比较大，所以怀疑是因为 i&#x2F;o 导致的。随即使用 iotop 命令查看服务器目前的 i&#x2F;o 情况，发现存在很多个 rg 命令，且都处于 100% 左右。查了下，发现是 vscode 远程服务器启动的搜索目录结构的进程，西八，有些坑呀！</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> iotop\n <span class=\"token number\">4269</span> be/4 escape     <span class=\"token number\">15.64</span> K/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">98.36</span> % rg <span class=\"token parameter variable\">--files</span> <span class=\"token parameter variable\">--hidden</span>\n <span class=\"token number\">4270</span> be/4 escape     <span class=\"token number\">28.15</span> K/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">97.46</span> % rg <span class=\"token parameter variable\">--files</span> <span class=\"token parameter variable\">--hidden</span>\n <span class=\"token number\">4272</span> be/4 escape     <span class=\"token number\">31.27</span> K/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">97.39</span> % rg <span class=\"token parameter variable\">--files</span> <span class=\"token parameter variable\">--hidden</span>\n <span class=\"token number\">4276</span> be/4 escape     <span class=\"token number\">34.40</span> K/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">96.98</span> % rg <span class=\"token parameter variable\">--files</span> <span class=\"token parameter variable\">--hidden</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"20-Docker-端口网络限制\"><a href=\"#20-Docker-端口网络限制\" class=\"headerlink\" title=\"20. Docker 端口网络限制\"></a>20. Docker 端口网络限制</h2><p><strong>如果发现服务都一切正常，但是无法无法访问的话，则多为网络问题！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 启用服务之后，登录跳转发现直接 502 报错了。排除了配置等相关原因都没有任何问题(做过相关测试)，这就非常奇怪了！</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 部署服务架构</span>\nnginx<span class=\"token punctuation\">(</span><span class=\"token number\">80</span><span class=\"token punctuation\">)</span> -<span class=\"token operator\">></span> web1<span class=\"token punctuation\">(</span><span class=\"token number\">8080</span><span class=\"token punctuation\">)</span>\n          -<span class=\"token operator\">></span> web2<span class=\"token punctuation\">(</span><span class=\"token number\">8081</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 报错信息如下所示</span>\nnginx connect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> failed <span class=\"token punctuation\">(</span><span class=\"token number\">113</span>: No route to <span class=\"token function\">host</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">while</span> connecting to upstream<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 根据错误信息可知，是因为没有路由到指定的 host 导致了，随即看了下防火墙是开着的，看了日志发现被过滤掉了，西八！问题找到了，现在需要做的就是，要么添加防火墙规则，要么关闭防火墙。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 检查开放的端口</span>\n$ <span class=\"token function\">sudo</span> firewall-cmd <span class=\"token parameter variable\">--permanent</span> <span class=\"token parameter variable\">--zone</span><span class=\"token operator\">=</span>public --list-ports\n\n<span class=\"token comment\"># 开启需要路由的端口</span>\n$ <span class=\"token function\">sudo</span> firewall-cmd <span class=\"token parameter variable\">--permanent</span> <span class=\"token parameter variable\">--zone</span><span class=\"token operator\">=</span>public --add-port<span class=\"token operator\">=</span><span class=\"token number\">8080</span>/tcp\n$ <span class=\"token function\">sudo</span> firewall-cmd <span class=\"token parameter variable\">--permanent</span> <span class=\"token parameter variable\">--zone</span><span class=\"token operator\">=</span>public --add-port<span class=\"token operator\">=</span><span class=\"token number\">8081</span>/tcp\n\n<span class=\"token comment\"># 配置立即生效</span>\nfirewall-cmd <span class=\"token parameter variable\">--reload</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 关闭防火墙</span>\n$ <span class=\"token function\">sudo</span> systemctl stop firewalld.service\n\n<span class=\"token comment\"># 禁用自启动</span>\n$ <span class=\"token function\">sudo</span> systemctl disable firewalld.service<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"21-Docker-无法获取镜像\"><a href=\"#21-Docker-无法获取镜像\" class=\"headerlink\" title=\"21. Docker 无法获取镜像\"></a>21. Docker 无法获取镜像</h2><p><strong>新初始化的机器，无法获取私有仓库的镜像文件！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 机器初始化之后，使用如下命令登录私有 docker 仓库，发现提示无法获取对应镜像，但是在其他机器上面获取该镜像就可以执行成功，这就非常奇怪了！</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 登录私有仓库</span>\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'123456'</span> <span class=\"token operator\">|</span> <span class=\"token function\">docker</span> login <span class=\"token parameter variable\">-u</span> escape --password-stdin docker.escapelife.site\n\n<span class=\"token comment\"># 异常信息提示</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> pull docker.escapelife.site/app:0.10\nError response from daemon: manifest <span class=\"token keyword\">for</span> docker.escapelife.site/app:0.10 not found: manifest unknown: manifest unknown<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 太坑了，我还以为我发现某个隐藏的 bug 了，可劲的排查，最后发现，原来是自己镜像包名字写错了，应该写成 0.0.10 的，自己却写成了 0.10。这里，纪念一下，以后碰到上述报错，那肯定是镜像不存在的。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 登录私有仓库之后会在用户家目录下生成一个docker配置</span>\n<span class=\"token comment\"># 其用来记录docker私有仓库的登录认证信息(是加密过的信息但不安全) => base64</span>\n$ <span class=\"token function\">cat</span> .docker/config.json\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token string\">\"auths\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token string\">\"docker.escapelife.site\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token string\">\"auth\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"d00u11Fu22B3355VG2xasE12w==\"</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"22-Docker-使容器不退出\"><a href=\"#22-Docker-使容器不退出\" class=\"headerlink\" title=\"22. Docker 使容器不退出\"></a>22. Docker 使容器不退出</h2><p><strong>如何使使用 docker-compose 启动的容器服务 hang 住而不退出</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 有时候我们启动的服务，因为某些问题(bug)导致服务无法正常启动，就会出现容器无限重启(restart: on-failure)的情况，这时就很不利于排除问题。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜ <span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-a</span>\n4e6xxx9a4   app:latest   <span class=\"token string\">\"/xxx/…\"</span>   <span class=\"token number\">26</span> seconds ago   Restarting <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">2</span> seconds ago<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 这时我们就需要根据，服务构建使用命令来决定是用什么命令来 hang 住服务。卡住的原理，就类似于使用 &#x2F;bin&#x2F;bash 进入容器是一样的，这里我就不过多解释了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 类似原理</span>\n<span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">--rm</span> <span class=\"token parameter variable\">--entrypoint</span><span class=\"token operator\">=</span>/bin/bash xxx/app:latest\n\n<span class=\"token comment\"># 使用Command命令</span>\ntty: <span class=\"token boolean\">true</span>\ncommand: <span class=\"token function\">tail</span> <span class=\"token parameter variable\">-f</span> /dev/null\n\n<span class=\"token comment\"># 使用Entrypoint命令</span>\ntty: <span class=\"token boolean\">true</span>\nentrypoint: <span class=\"token function\">tail</span> <span class=\"token parameter variable\">-f</span> /dev/null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>同理，我们在使用 docker-compose 或者 k8s 平台部署服务的时候，也有时会因为启动问题需要，使启动的服务不直接退出，来手动调试和排查问题原因。所以，我这里记录下其不同部署方式的，暂停方式。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># Compose</span>\n\n<span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3\"</span>\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">:</span>latest\n    <span class=\"token key atrule\">tty</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">entrypoint</span><span class=\"token punctuation\">:</span> /usr/bin/tail\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"-f /dev/null\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># K8S</span>\n\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> ubuntu\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> ubuntu\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">:</span>latest\n      <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"/bin/bash\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"--\"</span><span class=\"token punctuation\">]</span>\n      <span class=\"token key atrule\">args</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"while true; do sleep 30; done;\"</span><span class=\"token punctuation\">]</span>\n      <span class=\"token comment\"># command: [\"sleep\"]</span>\n      <span class=\"token comment\"># args: [\"infinity\"]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"23-Docker-不使用默认网段\"><a href=\"#23-Docker-不使用默认网段\" class=\"headerlink\" title=\"23. Docker 不使用默认网段\"></a>23. Docker 不使用默认网段</h2><p><strong>有些情况，内部规划的网段和可能和 Dockerd 默认的网段有冲突，导致异常出现！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 今天在新机器上面，部署了一整套服务(多台机器)，服务部署完毕之后，通过前置 Nginx 服务发现并不能访问，后置机器开放的端口，发现发到对应端口的请求都没有转发出去。这就比较奇怪了，因为端口控制是已经开通了的，不应该出现不通的情况。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜ <span class=\"token function\">nc</span> <span class=\"token parameter variable\">-v</span> <span class=\"token number\">172.16</span>.100.12 <span class=\"token number\">8000</span>\nnc: connect to <span class=\"token number\">172.16</span>.100.12 port <span class=\"token number\">8000</span> <span class=\"token punctuation\">(</span>tcp<span class=\"token punctuation\">)</span> failed: Connection refused<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 发现服务器端口不通，我这里怀疑可能是 dockerd 服务启动导致的，所以我先将服务都停掉，直接在机器上面启动了 Python 的服务端程序(Linux 机器自带 Python2.7.x 的版本)，然后在前置 Nginx 服务发现，端口确实是通的。后来，排除发现是内部服务默认网段和 dockerd 服务启动的默认网段是冲突的，导致重写了机器的防火墙规则，导致出现上述异常的。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ python <span class=\"token parameter variable\">-m</span> SimpleHTTPServer <span class=\"token number\">8000</span>\nServing HTTP on <span class=\"token number\">0.0</span>.0.0 port <span class=\"token number\">8000</span> <span class=\"token punctuation\">..</span>.\n\n➜ <span class=\"token function\">nc</span> <span class=\"token parameter variable\">-v</span> <span class=\"token number\">172.16</span>.100.12 <span class=\"token number\">8000</span>\nConnection to <span class=\"token number\">172.16</span>.100.12 <span class=\"token number\">8000</span> port <span class=\"token punctuation\">[</span>tcp/*<span class=\"token punctuation\">]</span> succeeded<span class=\"token operator\">!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>既然问题已经知道了，现在需要做的就是非常简单了：不适用默认网段！通过 <a href=\"https://docs.mirantis.com/mke/3.4/install/plan-deployment/mcr-considerations/default-address-pools.html\">『mirantis』</a> 里面，我们可以选择进行设置，然后重启服务 dockerd 服务，即可。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 修改配置</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> /etc/docker/daemon.json\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token string\">\"default-address-pools\"</span>:<span class=\"token punctuation\">[</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"base\"</span><span class=\"token builtin class-name\">:</span><span class=\"token string\">\"192.168.100.0/20\"</span>,<span class=\"token string\">\"size\"</span>:24<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 重启服务</span>\n$ <span class=\"token function\">sudo</span> systemctl restart <span class=\"token function\">docker</span>\n\n<span class=\"token comment\"># 启动服务验证是否生效</span>\n$ <span class=\"token function\">ip</span> a\n$ <span class=\"token function\">docker</span> network inspect app <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> Subnet<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291407482.png\"><br><strong>Docker 不使用默认网段</strong></p>\n</li>\n<li><p>这时，就到了考验我们网络的子网划分的能力了：如何在给定的网段下面合理且高效的进行划分呢？咳咳，确实难倒我了，这时我们可以再这个在线网站上面 <a href=\"https://www.sojson.com/convert/subnetmask.html\">JSON 在线解析</a> 进行划分，然后选定合理的 base 和 size 就可以了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 报错信息</span>\nError response from daemon: could not <span class=\"token function\">find</span> an available, non-overlapping IPv4 address pool among the defaults to assign to the network\n\n<span class=\"token comment\"># 按照下图我们可以对 pool 进行合理划分</span>\n<span class=\"token comment\"># 给定 10.210.200.0 + 255.255.255.0 的网段来划分子网</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> /etc/docker/daemon.json\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token string\">\"default-address-pools\"</span>:<span class=\"token punctuation\">[</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"base\"</span><span class=\"token builtin class-name\">:</span><span class=\"token string\">\"10.210.200.0/24\"</span>,<span class=\"token string\">\"size\"</span>:28<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>其中，base 告诉我们划分子网的网段是什么(从来开始)，是从前两位(&#x2F;16)开始，还是第三位开始(&#x2F;24)呢？而 size 则告诉我们划分的每个子网有多少 IP 地址可以使用呢？从 “10.210.200.0&#x2F;24” 我们可以知道，该网络下面只有 254 个可用的 IP 地址(直接使用肯定不够)，然后我们需要给 docker 使用，划分每个子网可用 16 个 IP 地址，所以子网就应该写成 28 了。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291408753.png\"><br><strong>Docker 不使用默认网段</strong></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"24-Docker-添加私有仓库\"><a href=\"#24-Docker-添加私有仓库\" class=\"headerlink\" title=\"24. Docker 添加私有仓库\"></a>24. Docker 添加私有仓库</h2><p><strong>有些情况，我们服务器上面需要使用内部私有的容器镜像地址！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 如果新机器上面需要使用私有仓库的话，但是又没有配置，再获取镜像的时候就会出现如下报错信息。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 拉取/登陆私库时提示</span>\n$ <span class=\"token function\">docker</span> pull <span class=\"token number\">192.168</span>.31.191:5000/nginx:latest\nx509: certificate signed by unknown authority<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 该问题的处理方式很简单，如下所示，配置一下仓库地址，重启服务并登陆私有仓库就可以了。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 添加配置</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> /etc/docker/daemon.json\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token string\">\"insecure-registries\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"192.168.31.191:5000\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\"># 重启docker</span>\n$ <span class=\"token function\">sudo</span> systemctl restart <span class=\"token function\">docker</span>\n\n<span class=\"token comment\"># 重新登录即可</span>\n$ <span class=\"token function\">docker</span> login 私库地址 <span class=\"token parameter variable\">-u</span> 用户名 <span class=\"token parameter variable\">-p</span> 密码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"25-Docker-解决时间同步\"><a href=\"#25-Docker-解决时间同步\" class=\"headerlink\" title=\"25. Docker 解决时间同步\"></a>25. Docker 解决时间同步</h2><p><strong>解决 Docker 容器时间时区和宿主机不同步的问题！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 有时间我们会遇到新创建的容器，容器内部和外部时间不一致，这就导致服务的日志、定时任务等不能按照我们既定的时间触发，非常麻烦。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 容器内部时间(CST - 东八区 - 北京时间)</span>\n<span class=\"token punctuation\">[</span>root@server ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># date</span>\nFri Apr <span class=\"token number\">27</span> <span class=\"token number\">22</span>:49:47 CST <span class=\"token number\">2022</span>\n\n<span class=\"token comment\"># 容器外部时间(UTC - 格林尼治 - 标准时间)</span>\n<span class=\"token punctuation\">[</span>root@server ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker run --rm nginx date</span>\nFri Apr <span class=\"token number\">27</span> <span class=\"token number\">14</span>:49:51 UTC <span class=\"token number\">2022</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>[解决方法]</strong> 宿主机设置了时区，而 Docker 容器并没有设置，导致两者相差 8 小时。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 以 docker run 方式启动</span>\n$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">--name</span> <span class=\"token string\">'app'</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token parameter variable\">-v</span> /etc/localtime:/etc/localtime <span class=\"token punctuation\">\\</span>\n    escape/nginx:v1\n\n<span class=\"token comment\"># 以 Dockerfile 构建</span>\nENV <span class=\"token assign-left variable\">TimeZone</span><span class=\"token operator\">=</span>Asia/Shanghai\nRUN <span class=\"token function\">ln</span> <span class=\"token parameter variable\">-sf</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n<span class=\"token comment\"># 以 docker-compose 方式启动</span>\nenvironment:\n  TZ: Asia/Shanghai<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<hr>\n<h2 id=\"26-Docker-容器磁盘不足\"><a href=\"#26-Docker-容器磁盘不足\" class=\"headerlink\" title=\"26. Docker 容器磁盘不足\"></a>26. Docker 容器磁盘不足</h2><p><strong>启动很多容器服务，导致存储和运行的容器目录(&#x2F;var&#x2F;lib&#x2F;docker&#x2F;)磁盘消耗很大！</strong></p>\n<ul>\n<li><p><strong>[问题起因]</strong> 服务器使用久了，就会出现磁盘不足的问题，这时候就需要排除到底是什么服务或者数据导致的。但如果使用容器化部署服务的话(docker)，大多数都是因为启动的容器导致，即启动的服务占用了大量的磁盘空间。<br><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291408180.png\"><br><strong>Docker 容器导致磁盘不足</strong></p>\n</li>\n<li><p><strong>[分析思路]</strong> 我们知道 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2 目录下的文件夹名基本都是以 md5 编码命名的，而 overlay2 是 docker 使用的文件存储驱动，也就是说该目录里面存储的就是现在服务器运行的容器。同时，我们知道镜像是分层的结构，所以这容器每次层都在这里得到了体现。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看容器的默认文件驱动</span>\n$ <span class=\"token function\">docker</span> info <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">\"Storage Driver\"</span>\nStorage Driver: overlay2\n\n<span class=\"token comment\"># 查看磁盘消耗大户</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">du</span> <span class=\"token parameter variable\">-sh</span> /var/lib/docker/overlay2\n900G    /var/lib/docker/overlay2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291408529.png\"><br><strong>Docker 容器导致磁盘不足</strong></p>\n</li>\n<li><p><strong>[分析思路]</strong> 如果我们临时启动了一个服务，当时只是打算只是临时使用，但是后续因为某些原因导致长期使用。同时因为运行中产生的数据或者文件并没有挂载映射到宿主机，导致写入容器内本地的文件最终到了一个很大的量级(比如容器产生的日志文件、数据文件)。这就导致我们看到，对应层下面 diff 和 merged 目录很大的原因。</p>\n<ul>\n<li>diff -&gt; 保存的就是差分信息 -&gt; 容器的可读可写层且初始为空</li>\n<li>merged -&gt; 容器运行时才会出现的存储情况集合 -&gt; 容器的挂载点</li>\n<li>upperdir -&gt; 容器层</li>\n<li>lowerdir -&gt; 初始镜像层</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 里面到底存储的啥</span>\n<span class=\"token comment\"># diff文件夹占用100G+，merged文件夹占用200+G</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-lh</span> /var/lib/docker/overlay2/1e3137<span class=\"token punctuation\">..</span>.9706bca6\ndrwxr-xr-x  <span class=\"token number\">10</span> root root  <span class=\"token number\">4096</span> <span class=\"token number\">8</span>月   <span class=\"token number\">5</span>  <span class=\"token number\">2021</span> diff/   <span class=\"token comment\"># 大</span>\n-rw-r--r--   <span class=\"token number\">1</span> root root    <span class=\"token number\">26</span> <span class=\"token number\">8</span>月   <span class=\"token number\">5</span>  <span class=\"token number\">2021</span> <span class=\"token function\">link</span>\n-rw-r--r--   <span class=\"token number\">1</span> root root   <span class=\"token number\">376</span> <span class=\"token number\">8</span>月   <span class=\"token number\">5</span>  <span class=\"token number\">2021</span> lower\ndrwxr-xr-x   <span class=\"token number\">1</span> root root  <span class=\"token number\">4096</span> <span class=\"token number\">8</span>月   <span class=\"token number\">5</span>  <span class=\"token number\">2021</span> merged/ <span class=\"token comment\"># 大</span>\ndrwx------   <span class=\"token number\">3</span> root root  <span class=\"token number\">4096</span> <span class=\"token number\">4</span>月  <span class=\"token number\">24</span> <span class=\"token number\">12</span>:22 work/\n\n<span class=\"token comment\"># link文件的内容对应了/var/lib/docker/overlay2/l的文件夹名称</span>\n<span class=\"token comment\"># 保存了镜像层的短标识；用于解决mount参数中长字符超过页大小限制的问题</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212291409947.png\"><br><strong>Docker 容器导致磁盘不足</strong></p>\n<ul>\n<li><strong>[解决方法]</strong> 宿主机设置了时区，而 Docker 容器并没有设置，导致两者相差 8 小时。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看那个容器层占用了大量磁盘空间</span>\n$ <span class=\"token function\">sudo</span> <span class=\"token function\">du</span> <span class=\"token parameter variable\">-sh</span> /var/lib/docker/overlay2/* <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> G <span class=\"token operator\">|</span> <span class=\"token function\">sort</span> <span class=\"token parameter variable\">-rn</span>\n121G    1e3137<span class=\"token punctuation\">..</span>.9706bca6\n33G     9d50b3<span class=\"token punctuation\">..</span>.ef3ae1b0\n12G     <span class=\"token number\">462157</span><span class=\"token punctuation\">..</span>.03ce3935\n\n<span class=\"token comment\"># 查找对应层所属于那个容器镜像</span>\n$ <span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-q</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token function\">xargs</span> <span class=\"token function\">docker</span> inspect <span class=\"token parameter variable\">--format</span> <span class=\"token string\">'&#123;&#123;.State.Pid&#125;&#125;, &#123;&#123;.Id&#125;&#125;, &#123;&#123;.Name&#125;&#125;, &#123;&#123;.GraphDriver.Data.WorkDir&#125;&#125;'</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">\\</span>\n    <span class=\"token function\">grep</span> xxx\n\n<span class=\"token comment\"># 可以根据容器id和名称查看他的层数信息(从低到高)</span>\n$ <span class=\"token function\">docker</span> inspect xxx <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token parameter variable\">-E</span> <span class=\"token string\">\"LowerDir|UpperDir|MergedDir|WorkDir\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 在该目录下也存在一个同样名字容器的文件夹(xxx)</span>\n$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-lh</span> /var/lib/docker/image/overlay2/layerdb/mounts/\nfff30d<span class=\"token punctuation\">..</span>.bc6a0222\n8078cf<span class=\"token punctuation\">..</span>.73bda80b\nb801ce<span class=\"token punctuation\">..</span>.cc78e234\n\n<span class=\"token comment\"># mount-id: 表示了我们刚才创建的容器的目录(/var/lib/docker/overlay2)</span>\n$ <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-lh</span> /var/lib/docker/image/overlay2/layerdb/mounts/ff30d<span class=\"token punctuation\">..</span>.bc6a0222/\n-rw-r--r--  <span class=\"token number\">1</span> root root    <span class=\"token number\">69</span> <span class=\"token number\">8</span>月   <span class=\"token number\">5</span>  <span class=\"token number\">2021</span> init-id\n-rw-r--r--  <span class=\"token number\">1</span> root root    <span class=\"token number\">64</span> <span class=\"token number\">8</span>月   <span class=\"token number\">5</span>  <span class=\"token number\">2021</span> mount-id\n-rw-r--r--  <span class=\"token number\">1</span> root root    <span class=\"token number\">71</span> <span class=\"token number\">8</span>月   <span class=\"token number\">5</span>  <span class=\"token number\">2021</span> parent<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","feature":true,"text":"1. Docker 迁移存储目录默认情况系统会将 Docker 容器存放在 &#x2F;var&#x2F;lib&#x2F;docker 目录下 [问题起因] 今天通过监控系统，发现公司其中一台服务器的磁盘快慢，随即上去看了下，发现 &#x2F;var&#x2F;lib&#x2F...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[{"name":"Docker","slug":"Docker","count":1,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Docker-%E8%BF%81%E7%A7%BB%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">1. Docker 迁移存储目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Docker-%E8%AE%BE%E5%A4%87%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3\"><span class=\"toc-text\">2. Docker 设备空间不足</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Docker-%E7%BC%BA%E5%85%B1%E4%BA%AB%E9%93%BE%E6%8E%A5%E5%BA%93\"><span class=\"toc-text\">3. Docker 缺共享链接库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-Docker-%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F\"><span class=\"toc-text\">4. Docker 容器文件损坏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-Docker-%E5%AE%B9%E5%99%A8%E4%BC%98%E9%9B%85%E9%87%8D%E5%90%AF\"><span class=\"toc-text\">5. Docker 容器优雅重启</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Docker-%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">6. Docker 容器无法删除</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-Docker-%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%96%87%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">7. Docker 容器中文异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-Docker-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A\"><span class=\"toc-text\">8. Docker 容器网络互通</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-Docker-%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BA%BF%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">9. Docker 容器总线错误</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-Docker-NFS-%E6%8C%82%E8%BD%BD%E6%8A%A5%E9%94%99\"><span class=\"toc-text\">10. Docker NFS 挂载报错</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-Docker-%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5\"><span class=\"toc-text\">11. Docker 使用默认网段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-Docker-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B8%B2%E5%8F%B0\"><span class=\"toc-text\">12. Docker 服务启动串台</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-Docker-%E5%91%BD%E4%BB%A4%E8%B0%83%E7%94%A8%E6%8A%A5%E9%94%99\"><span class=\"toc-text\">13. Docker 命令调用报错</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-Docker-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">14. Docker 定时任务异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-Docker-%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E5%BC%95%E5%8F%B7\"><span class=\"toc-text\">15. Docker 变量使用引号</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-Docker-%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E6%8A%A5%E9%94%99\"><span class=\"toc-text\">16. Docker 删除镜像报错</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-Docker-%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">17. Docker 普通用户切换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-Docker-%E7%BB%91%E5%AE%9A%E5%88%B0-IPv6-%E4%B8%8A\"><span class=\"toc-text\">18. Docker 绑定到 IPv6 上</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-Docker-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E8%B6%85%E6%97%B6\"><span class=\"toc-text\">19. Docker 容器启动超时</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-Docker-%E7%AB%AF%E5%8F%A3%E7%BD%91%E7%BB%9C%E9%99%90%E5%88%B6\"><span class=\"toc-text\">20. Docker 端口网络限制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-Docker-%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">21. Docker 无法获取镜像</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-Docker-%E4%BD%BF%E5%AE%B9%E5%99%A8%E4%B8%8D%E9%80%80%E5%87%BA\"><span class=\"toc-text\">22. Docker 使容器不退出</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23-Docker-%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%BD%91%E6%AE%B5\"><span class=\"toc-text\">23. Docker 不使用默认网段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-Docker-%E6%B7%BB%E5%8A%A0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93\"><span class=\"toc-text\">24. Docker 添加私有仓库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-Docker-%E8%A7%A3%E5%86%B3%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">25. Docker 解决时间同步</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26-Docker-%E5%AE%B9%E5%99%A8%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3\"><span class=\"toc-text\">26. Docker 容器磁盘不足</span></a></li></ol>","author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> @ <b>微信：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Mybatis一级缓存导致的内存溢出","uid":"d8253a8b0f6101721f69eb1f7316985f","slug":"Java/Mybatis一级缓存导致的内存溢出","date":"2018-09-29T12:06:29.000Z","updated":"2022-12-29T02:21:21.894Z","comments":true,"path":"api/articles/Java/Mybatis一级缓存导致的内存溢出.json","keywords":"阿里孩舞,五月西恩,Anchor,阁楼麻雀,码农,程序猿,JAVA","cover":"/medias/dva.jpg","text":" 接上篇 Druid 监控导致的内存溢出问题定位处理 JVM 内存溢出相关，废话不多说直接上分析过程。 1、服务器内存快照分析 首先通过快照查看最大的二十个对象如下图： 根据反馈数据可以发现前十个对象大小基本差不多，猜测应该由一个问题导致，点击去进一步定位问题。 2、定位引起内存...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"JAVA","slug":"JAVA","count":7,"path":"api/categories/JAVA.json"}],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"OOM","slug":"OOM","count":2,"path":"api/tags/OOM.json"},{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"Anchor","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/heyshoop/imageRepository@master/images/202212281657361.png","link":"/","description":"新生代农民工 <br /> 技术无产阶级 <br /> @ <b>微信：Alihai5</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}